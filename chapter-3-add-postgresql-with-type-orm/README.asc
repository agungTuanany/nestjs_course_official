//{{{ ** ASCIIDOC HEADER
:description:   nestjs official course | chapter-3
:url-repo:      https://github.com/agungTuanany/nestjs_course_official
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Thu Mar 25 12:36:52 AM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
//}}}

[[_chapter_3_add_postgresql_with_typeorm]]
= Chapter-3 Add PostgreSQL With TypeORM
:figure-caption!:
:source-highlighter: highlight.js

//{{{== Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_creating_a_basic_controller[Creating a Basic Controller]
| 2.    | xref:_prerequisite_instal_docker[Prerequisite: Instal Docker]
| 2.    | xref:_running_postgresql[Running PostgreSQL]
|====
//}}}

//{{{ 1 == Before We Get Started
== Before We Get Started
:fn-link_chapter_2: link:../chapter-2-creating-rest-api-application/README.asc
:fn-link_chapter_9: link:../chapter-9-add-mongodb-with-mongoose/README.asc
:fn-link_chapter_9_: footnote:[WIP | Work In Progress]

[#img-chapter]
[link=./images/chapter-3-1.png]
.Before we get started
image::./images/chapter-3-1.png[align="center"]

This chapter is a continuation of {fn-link_chapter_2}[chapter-2: creating a rest
API application] which is part of the *standard path* of this course. There's
also a bonus NoSQL MongoDB chapter{fn-link_chapter_9_} that begins right where
Chapter Two left off as well.

[#img-chapter]
[link=./images/chapter-3-2.png]
.Create backup git - branch
image::./images/chapter-3-2.png[align="center"]

If you want to code along through both of these database chapters. Make sure
you save your progress from this last chapter, into separate branch. This way
you can use it later for the MongoDB bonus chapter. If you using Git, make sure
to create a new Branch to store your current progress, and then head back to
your *master* - branch to continue along with this PostgreSQL and TypeORM
- chapter, as well as the rest of the course.

By fracturing these SQL and NoSQL section, you can easily choose and watch
whichever section you need for your project, or code along through both.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 2 == Prerequisite: Instal Docker
[[_prerequisite_instal_docker]]
== Prerequisite: Instal Docker
:fn-docker_compose_install: footnote:[https://docs.docker.com/compose/install/]
:fn-docker_compose_doc: footnote:[https://docs.docker.com/compose/]

[#img-chapter]
[link=./images/chapter-3-3.png]
.Prerequisite
image::./images/chapter-3-3.png[align="center"]

Docker is a platform for developers to: Build, Run, and Share applications that
are within containers. The use of containers to deploy applications is called
*_containerization_*. Containerization has become increasingly popular over
years due to many benefits they bring to the development process.

[#img-chapter]
[link=./images/chapter-3-4.png]
.Benefit Containerization with Docker
image::./images/chapter-3-4.png[align="center"]

Let's go over a few key benefits. Container are:

- *Flexible*,
- *Lightweight*,
- *Portable*, meaning you can build them locally, deploy to the cloud and run
  anywhere.
- *Loosely - Coupled*, this means that containers are highly self-sufficient and
  encapsulated. Allowing them to be replaced or upgraded, without disrupting any
  other containers.

There are many other great benefits to containerization and Docker, but
hopefully you get the idea so far.

*Fundamentally* a container is, just a running process with some added
encapsulation features applied to it. This helps keep the container isolated
from the host and other container.

In this course, we'll be using docker to set up a database locally on your
machine. If you do not have Docker installed already, go ahead and pause in
second and check out installation instructions on the official
https://docker.com[docker - website].

In addition to Docker, we'll be utilizing *_Docker Compose_*. *Docker - Compose*
is, a tool for defining and running *_multiple container_* Docker applications.
With *Docker - Compose*, you can use a YAML - file to configure our
*_application - services_*. If you're not familiar with YAML, don't worry, we'll
briefly cover how we'll be setting up the file, but it's nothing too
intimidating.

Once we have all this things set up, with just single command, we can create and
start all the services from our configuration on any machine. Docker is going to
make working with our application _that much simpler_ in the future, not just
for us, but also for other developers, different machines, and can even help us
quickly set up our application in the cloud.

For Mac and Windows users, *Docker - Compose* is includes out of the box with
Docker. But if you're on Linux, there are a few additional steps you'll need to
do in order to get *Docker - Compose* installed{fn-docker_compose_install}.

Make sure to check the *Docker - Compose _documentation_*{fn-docker_compose_doc}
for more information.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 3 == Running PostgreSQL
[[_running_postgresql]]
== Running PostgreSQL
:fn-psql_feature_filled: footnote:[automatically generate database and allow to work and fill multiple database tables]

[#img-chapter]
[link=./images/chapter-3-5.png]
.Running PostgreSQL
image::./images/chapter-3-5.png[align="center"]

Now, that we have Docker installed, just make sure that's it is running on your
machine and let's see it in action.

Previously in our application, we were using a _Mock data - resource_ in our
`CoffeesServices`. Let's take it up a notch and use a real database so we can
really take our application, to the next level.

We're going to be using PostgreSQL. Because not only is it one of the *_most
performant_*, feature *_filled database management_*{fn-psql_feature_filled}
system out there. But it's also free!.

In the past, we may have gone to the Postgres website, installed the database
locally on our machine. But let's take advantage of Docker, to handle all of
this for us. We're going to be using the _Docker - Compose_ tool, and it's YAML
- configuration to set everything up that our application needs.

To get started, let's create a `docker-compose.yml` file, in the project's root
directory. Next let's define a *_database - container_* in YAML - format. YAML
is an interesting configuration file in that *_spacing - indentation_* and
*_dashes_* all *matter*, and do something. If you want to learn more about YAML,
please check out https://yaml.org/start.html[yaml]. There's a lot going o here,
if you look down below the course - video, you'll be able to copy what you need
for this file.

[source, yaml]
----
version: "3"

services:
  db:
    image: postgres
    restart: always
    ports:
      - "543:543"
    environment:
      POSTGRES_PASSWORD: pass123
----

The most important piece here are, that we have a `*db:*` - service that is
using the Docker `*image:*` of `postgres`.  A Docker - `"image:"` is a *multilayered
- file* that will execute code within a *_docker - container_*, and in this case
it will be creating a PostgreSQL - database.

Next up, we have `*ports:*`. We can see that we'll be using the default ports
for PostgreSQL of `5432` but notice the `*":"*` (colon)m and then the same port,
`5432`, again. This indicates to Docker that internally within the container, it
should have the database set up on Port `5432`, but also have it *accessible
_outside_* of Docker, on the *same port* as well.

This lets us be able to access this database that's inside of the Docker
- container, outside of the container, and on our current machine!.

Lastly, we're *setting up a password* for Postgres, which we've made `pass123`.

I know a lot of this might seem like a lot, but with all that in place. We can
use the Docker - Compose CLI to run the database service effortlessly, with just
one single command.

Let's open new terminal, and let's enter `docker-compose up -d` to bring our
Docker - Container "up".

[source, shell]
----
$ docker-compose up -d
----


The `"-d"` flag means that we want to run our containers in "*detached*' mode.
Meaning that they are going to be running in the "background".

We only have _one service_ listed in our `docker-compose.yml` file, but for
future reference; if you had *_other services_* here and wanted to run
a *SPECIFIC - one*. You can pass the "name" of the service you want to run by
entering the *name* of it.

[source, shell]
----
$ docker-compose up db -d
----

NOTE: Just remember, that when you pass in *nothing* Docker - Compose will spawn
all the services defined.

**⬆xref:_table_of_contents[back to top]**
//}}}

//**⬆xref:_table_of_contents[back to top]**
