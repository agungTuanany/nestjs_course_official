//{{{ ** ASCIIDOC HEADER
:description:   nestjs official course | chapter-3
:url-repo:      https://github.com/agungTuanany/nestjs_course_official
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Thu Mar 25 12:36:52 AM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
//}}}

[[_chapter_3_add_postgresql_with_typeorm]]
= Chapter-3 Add PostgreSQL With TypeORM
:figure-caption!:
:source-highlighter: highlight.js

//{{{== Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_creating_a_basic_controller[Creating a Basic Controller]
| 2.    | xref:_prerequisite_instal_docker[Prerequisite: Instal Docker]
| 3.    | xref:_running_postgresql[Running PostgreSQL]
| 4.    | xref:_introduction_the_typeorm_module[Introduction The TypeORM Module]
| 5.    | xref:_creating_a_typeorm_entity[Creating a TypeORM Entity]
| 6.    | xref:_using_repository_to_access_database[Using Repository To access Database]
| 7.    | xref:_create_a_relation_between_two_entities[Create a Relation Between Two Entities]
| 8.    | xref:_retrieve_entities_with_their_relation[Retrieve Entities With Their Relation]
| 9.    | xref:_using_cascading_inserts_and_updates[Using Cascading Inserts and Updates]
| 10.   | xref:_adding_pagination[Adding Pagination]
|====
//}}}

//{{{ 1 == Before We Get Started
== Before We Get Started
:fn-link_chapter_2: link:../chapter-2-creating-rest-api-application/README.asc
:fn-link_chapter_9: link:../chapter-9-add-mongodb-with-mongoose/README.asc
:fn-link_chapter_9_: footnote:[WIP | Work In Progress]

[#img-chapter]
[link=./images/chapter-3-1.png]
.Before we get started
image::./images/chapter-3-1.png[align="center"]

This chapter is a continuation of {fn-link_chapter_2}[chapter-2: creating a rest
API application] which is part of the *standard path* of this course. There's
also a bonus NoSQL MongoDB chapter{fn-link_chapter_9_} that begins right where
Chapter Two left off as well.

[#img-chapter]
[link=./images/chapter-3-2.png]
.Create backup git - branch
image::./images/chapter-3-2.png[align="center"]

If you want to code along through both of these database chapters. Make sure
you save your progress from this last chapter, into separate branch. This way
you can use it later for the MongoDB bonus chapter. If you using Git, make sure
to create a new Branch to store your current progress, and then head back to
your *master* - branch to continue along with this PostgreSQL and TypeORM
- chapter, as well as the rest of the course.

By fracturing these SQL and NoSQL section, you can easily choose and watch
whichever section you need for your project, or code along through both.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 2 == Prerequisite: Instal Docker
[[_prerequisite_instal_docker]]
== Prerequisite: Instal Docker
:fn-docker_compose_install: footnote:[https://docs.docker.com/compose/install/]
:fn-docker_compose_doc: footnote:[https://docs.docker.com/compose/]

[#img-chapter]
[link=./images/chapter-3-3.png]
.Prerequisite
image::./images/chapter-3-3.png[align="center"]

Docker is a platform for developers to: Build, Run, and Share applications that
are within containers. The use of containers to deploy applications is called
*_containerization_*. Containerization has become increasingly popular over
years due to many benefits they bring to the development process.

[#img-chapter]
[link=./images/chapter-3-4.png]
.Benefit Containerization with Docker
image::./images/chapter-3-4.png[align="center"]

Let's go over a few key benefits. Container are:

- *Flexible*,
- *Lightweight*,
- *Portable*, meaning you can build them locally, deploy to the cloud and run
  anywhere.
- *Loosely - Coupled*, this means that containers are highly self-sufficient and
  encapsulated. Allowing them to be replaced or upgraded, without disrupting any
  other containers.

There are many other great benefits to containerization and Docker, but
hopefully you get the idea so far.

*Fundamentally* a container is, just a running process with some added
encapsulation features applied to it. This helps keep the container isolated
from the host and other container.

In this course, we'll be using docker to set up a database locally on your
machine. If you do not have Docker installed already, go ahead and pause in
second and check out installation instructions on the official
https://docker.com[docker - website].

In addition to Docker, we'll be utilizing *_Docker Compose_*. *Docker - Compose*
is, a tool for defining and running *_multiple container_* Docker applications.
With *Docker - Compose*, you can use a YAML - file to configure our
*_application - services_*. If you're not familiar with YAML, don't worry, we'll
briefly cover how we'll be setting up the file, but it's nothing too
intimidating.

Once we have all this things set up, with just single command, we can create and
start all the services from our configuration on any machine. Docker is going to
make working with our application _that much simpler_ in the future, not just
for us, but also for other developers, different machines, and can even help us
quickly set up our application in the cloud.

For Mac and Windows users, *Docker - Compose* is includes out of the box with
Docker. But if you're on Linux, there are a few additional steps you'll need to
do in order to get *Docker - Compose* installed{fn-docker_compose_install}.

Make sure to check the *Docker - Compose _documentation_*{fn-docker_compose_doc}
for more information.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 3 == Running PostgreSQL
[[_running_postgresql]]
== Running PostgreSQL
:fn-psql_feature_filled: footnote:[automatically generate database and allow to work and fill multiple database tables]

[#img-chapter]
[link=./images/chapter-3-5.png]
.Running PostgreSQL
image::./images/chapter-3-5.png[align="center"]

Now, that we have Docker installed, just make sure that's it is running on your
machine and let's see it in action.

Previously in our application, we were using a _Mock data - resource_ in our
`CoffeesServices`. Let's take it up a notch and use a real database so we can
really take our application, to the next level.

We're going to be using PostgreSQL. Because not only is it one of the *_most
performant_*, feature *_filled database management_*{fn-psql_feature_filled}
system out there. But it's also free!.

In the past, we may have gone to the Postgres website, installed the database
locally on our machine. But let's take advantage of Docker, to handle all of
this for us. We're going to be using the _Docker - Compose_ tool, and it's YAML
- configuration to set everything up that our application needs.

To get started, let's create a `docker-compose.yml` file, in the project's root
directory. Next let's define a *_database - container_* in YAML - format. YAML
is an interesting configuration file in that *_spacing - indentation_* and
*_dashes_* all *matter*, and do something. If you want to learn more about YAML,
please check out https://yaml.org/start.html[yaml]. There's a lot going o here,
if you look down below the course - video, you'll be able to copy what you need
for this file.

//{{{ docker-compose.yml
[source, yaml]
----
// docker-compose.yml
version: "3"

services:
  db:
    image: postgres
    restart: always
    ports:
      - "5432:5432"
    environment:
      POSTGRES_PASSWORD: pass123
----
//}}}

The most important piece here are, that we have a `*db:*` - service that is
using the Docker `*image:*` of `postgres`.  A Docker - `"image:"` is a *multilayered
- file* that will execute code within a *_docker - container_*, and in this case
it will be creating a PostgreSQL - database.

Next up, we have `*ports:*`. We can see that we'll be using the default ports
for PostgreSQL of `5432` but notice the `*":"*` (colon)m and then the same port,
`5432`, again. This indicates to Docker that internally within the container, it
should have the database set up on Port `5432`, but also have it *accessible
_outside_* of Docker, on the *same port* as well.

This lets us be able to access this database that's inside of the Docker
- container, outside of the container, and on our current machine!.

Lastly, we're *setting up a password* for Postgres, which we've made `pass123`.

I know a lot of this might seem like a lot, but with all that in place. We can
use the Docker - Compose CLI to run the database service effortlessly, with just
one single command.

Let's open new terminal, and let's enter `docker-compose up -d` to bring our
Docker - Container "up".

[source, shell]
----
$ docker-compose up -d
----


The `"-d"` flag means that we want to run our containers in "*detached*' mode.
Meaning that they are going to be running in the "background".

We only have _one service_ listed in our `docker-compose.yml` file, but for
future reference; if you had *_other services_* here and wanted to run
a *SPECIFIC - one*. You can pass the "name" of the service you want to run by
entering the *name* of it.

[source, shell]
----
$ docker-compose up db -d
----

NOTE: Just remember, that when you pass in *nothing* Docker - Compose will spawn
all the services defined.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ == 4 Introduction The TypeORM Module
[_introduction_the_typeorm_module]]
== Introduction The TypeORM Module
:fn-orm: footnote:[Object-relational mapping (ORM, O/RM, and O/R mapping tool) in computer science is a programming technique for converting data between incompatible type systems using object-oriented programming languages. This creates, in effect, a "virtual object database" that can be used from within the programming language.  http://en.wikipedia.org/wiki/Object-relational_mapping]
:fn-typeorm: footnote:[https://github.com/typeorm/typeorm]

[#img-chapter]
[link=./images/chapter-3-6.png]
.Introduction The TypeORM Module
image::./images/chapter-3-6.png[align="center"]

Nest itself is database agnostic, allowing you to easily integrate with any SQL
or NoSQL database of your choice. There are a lot of different ways you can
integrate Nest with databases, and they all depend on your personal preference
or project's needs.

For this chapter, we'll be using the popular, mature and fully featured Object
Relational Mapper or ORM{fn-orm} known as TypeORM{fn-typeorm}. TypeORM will let
us interact with *_entities_* in our database in a *Type safe* and incredibly
*simple* manner, letting us get things done faster than ever.

In this course, we'll be setting up TypeORM with Postgres database that we have
up, and running in our Docker - Container. But TypeORM provides support for many
other relational database such as: MySQL, Microsof - SQL Server, SQLite and even
NoSQL databases like MongoDB. So use whatever suits your projects best.

To get strated with TypeORM, let's get the necessary dependencies installed for
our application. We are continuing ahead as we already have these installed. But
if you're following along, just pause in a second, and come back when it's
finished.

NOTE: that the procedures we walk through in this chapter will be the same for
pretty much any database supported by TypeORM.

[source, shell]
----
$ npm i --save @nestjs/typeorm typeorm pg
----

All right, we can see we've installed a `*"@nestjs/typeorm"*` package,
`*"typeorm"*` it self, and also `*"pg"*`, which we need since we'll be using
Postgres in our application.

Once the installation process is complete, let's get TypeORM setup in our
`ilovcoffee` - application. Let's open up our `app.module.ts` file and head over
to the `imports:[]` Array.

//{{{ app.module.ts
[source, typescript]
----
// app.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

import { AppController } from './app.controller';
import { AppService } from './app.service';
import { CoffeesModule } from './coffees/coffees.module';

@Module({
    imports: [
    CoffeesModule,
    TypeOrmModule.forRoot({
        type: 'postgres',
        host: 'localhost',
        port: 5432,
        username: 'postgres',
        password: 'pass123',
        database: 'postgres',
        autoLoadEntities: true,
        synchronize: true
    })
    ],
    controllers: [AppController],
    providers: [AppService],
})
export class AppModule {}
----
//}}}

NestJs comes with a module that helps make the TypeORM integration extremely
simple. To get started with this module, let's import `TypeOrmModule from
`@nestjs/typeorm` and add it into our `imports:[]` Array here.

We need to initialize this module, so let's call the `forRoot()` method on the
`TypeOrmModule` which lets us configure the connection to TypeORM as well as
a few additional tools available to integrate it with Nest.

Let's start out with,
- `*"type:"*` which we've set to `postgres` since we know we're using
  PostgreSQL.

- `*"host:"*` will be `*"localhost"*` since we're developing locally.

- `*"port:"*` is `*"5432"*` which is what we set in our
  `docker-compose.yml`- file.

- `*"username:"*` is a username for accessing our database. We never set one in
  our Docker - Compose file. We're going to use `"*postgress*"`, which is the
  *_default_* for PostgreSQL databases.

- `*"password:"*` we've set to `*"pass123"*`, just like w did in our
  Docker - Compose file again.

- `*"database:"*` here, we'll list the name of our database that our application
  will be using. Let's call it `*"postgress"*`.

- `*"autoLoadEntities:"*`, let's set this to `*"true"*`. This helps load modules
  automatically instead of specifying the entities Array. We'll dive deeper into
  this later in an entity section.

- `*"synchronize:"*`, we set to `*"true"*`. `synchronize` ensures that our
  *TypeORM entities* will be *sync* with the database every time we run our
  application.  This great for development,

CAUTION: a very important tip!, Make sure you DISABLED `*"synchronize: false"*`
when you're in *"Production"*!.

Now, that we have TypeORM configured, let's open up our terminal, and start our
application to make sure everything's working.

//{{{ $: npm run start:dev
[source, shell]
----
$: npm run start:dev
[Nest] 618027  -  [NestFactory] Starting Nest application...
[Nest] 618027  -  [InstanceLoader] TypeOrmModule dependencies initialized +89ms         //<<<
[Nest] 618027  -  [InstanceLoader] AppModule dependencies initialized +1ms
[Nest] 618027  -  [InstanceLoader] CoffeesModule dependencies initialized +0ms
[Nest] 618027  -  [InstanceLoader] TypeOrmCoreModule dependencies initialized +32ms     //<<<
[Nest] 618027  -  [RoutesResolver] AppController {}: +6ms
[Nest] 618027  -  [RouterExplorer] Mapped {, GET} route +3ms
[Nest] 618027  -  [RoutesResolver] CoffeesController {/coffees}: +0ms
[Nest] 618027  -  [RouterExplorer] Mapped {/coffees, GET} route +1ms
[Nest] 618027  -  [RouterExplorer] Mapped {/coffees/:id, GET} route +2ms
[Nest] 618027  -  [RouterExplorer] Mapped {/coffees, POST} route +2ms
[Nest] 618027  -  [RouterExplorer] Mapped {/coffees/:id, PATCH} route +2ms
[Nest] 618027  -  [RouterExplorer] Mapped {/coffees/:id, DELETE} route +1ms
[Nest] 618027  -  [NestApplication] Nest application successfully started +10ms
----
//}}}

We fire up the application in development - mode, again with `npm run
start:dev`. If we look carefully, we should see `TypeOrmModule` dependencies
initialized. Meaning we have successfully established a connection to our Docker
- Postgres database.

If you having any issues setting up TypeORM, make sure that Docker is running
with `docker-compose up -d`. Also make sure `*"password:"*` inside your
`TypeOrmModule.forRoot()` matches what you have in your Docker - Compose file.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 5 == Creating a TypeORM Entity
[[_creating_a_typeorm_entity]]
== Creating a TypeORM Entity

An *"Entity"* represent a *relationship* between a TypeScript class and
a database table. Well, in the case of our Nest applications our *"entities"*
will be *classes - decorator* with the `@Entity()` decorator.

In the previous lesson on TypeORM, we set `*"synchronize:"*` to `true` in our
`TypeOrmModule.forRoot()` configuration method. This synchronize
- configuration, let's TypeORM automatically generate SQL - table from all
classes with the `@Entity()` decorator, and the metadata they contain.

This automatic synchronization saves us a lot of manual - coding that we'd have
to do otherwise while actively developing our applications. REMEMBER!!, this is
designed for *development only*. Make sure to ALWAYS!! *disable* this feature in
*production*!.

So, let's get started and upadte our existing "mock" - Coffee-entity and set it
up with TypeORM. Let's start by opening our Coffee-entity, and adding this new
`@Entity()` decorator on top. Making sure to import it form `typeorm`.

//{{{ coffee.entity.ts
[source, typescript]
----
// coffee.entity.ts
import { Entity } from 'typeorm';

@Entity()   // sql table === "coffee"
export class Coffee {
    id: number;
    name: string;
    brand: string;
    flavors: string[];
}
----
//}}}

As we mention a moment ago, each *Entity - class* represent a *SQL - table*. By
default, TypeORM will *name the SQL - table* based on our *class - name* in
*lowercase*.

So in this example, the SQL - table that will be generated will be "coffee", in
lowercase.

[source, typescript]
----
@Entity('coffees')   // sql table === "coffees"
----

If you want to use a *different table - name* for your Entity, you can specify
inside of the `@Entity()` decorator. Passing the Strig "coffees" into the
decorator will generate a 'coffees" - table instead.

Let's remove the String from `@Entity()` decorator, and just use our class
- name `coffee` as the SQL table for now.

=== Define TypeORM -  Table Column

Now that we have all this in place, we can start defining the *columns* in our
table.

//{{{ coffee.entity.ts
[source, typescript]
----
// coffee.entity.ts
import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';

@Entity()   // sql table === "coffee"
export class Coffee {
    @PrimaryGeneratedColumn()
    id: number;

    @Column()
    name: string;

    @Column()
    brand: string;

    @Column('json', { nullable: true})
    flavors: string[];
}
----
//}}}

Every properties in our class that is annotated with `*@Column()*` decorator,
will be mapped to a *table - column*. Let's build up our *Coffee - Entity* to
see all this in action.

First, almost every table needs a *primary key*, right? Let's use a new
decorator called `@PrimaryGeneratedColumn()` and decorate this `*"id"*` property
with it. This decorator will not define `*"id"*`  here as the *primary
- column*, but also *auto - increment* the value for us.

Next, let's add the `@Column()` decorator to all the rest of our properties
here: `*"name:"*`, `*"brand:"*`, and `*"flavors:"*`.

For `*"flavors:"*` we need to do something a little bit different, since this is
an Array, and we want to make our *flavors optional* as well. Inside
our`@Column()` decorator, let's pass in *two arguments*. One that label this
column as type *"json"*; and the other an Object with `*"nullable: true"*`

With this in place, TypeORM now knows that `*"flavors:"*` should store Arrays'
as JSON; and to make this *column - optional* in our table.

We set this column to JSON here, but this is *just temporary*. Soon we'll show
relationship in a coming chapter.

Note, that each column here is is *"not"* - *"nullable"*, meaning *"REQUIRED by
default"*. So in our Coffee - entity, all the columns besides `*"flavors"*` are
required.

[[_register_entity_in_application]]
=== Register Entity in Application

Now that we have the basics of our entity set up in place, let's register Coffee
- entity in our application.

Now, that our application is a but modularized, and we're dealing with this
entity inside of the `CoffesModule`. We need to make TypeORM aware of the entity
if THIS child - module itself.

Let's open up our `CoffeesModule`,

//{{{ coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { CoffeesController } from './coffees.controller';
import { CoffeesService } from './coffees.service';

@Module({
    imports: [TypeOrmModule.forFeature([Coffee])],
    controllers:[CoffeesController],
    providers: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

First, create an `*"imports:"*` Array inside of the `@Module()` decorator. In
this `*"imports:"*` Array let's add `TypeOrmModule.forFeature()`, passing an
Array with our *Coffee - Entity* inside of it.

The use of `forFeature()` here, register TypeORM in this *child - modules*.
Remember we use `forRoot()`, in our main `AppModule` before, but we only do that
once. Every other module will use `forFeature()` when *registering entities*.

Inside `forFeature()` here, we passed in an Array of Entities, but in our case
we only have one, our *Coffee - Entity*.

If you look at the Coffee - table now in database UI of your choice, it should
look something like this,

[#img-chapter]
[link=./images/chapter-3-7.png]
.Coffee - table
image::./images/chapter-3-7.png[align="center"]

Everything setup just as we created it.

Or, you can  run docker container in a new terminal,

//{{{ $ docker ps
[source, bash]
----
$ docker ps
CONTAINER ID   IMAGE      COMMAND                  CREATED       STATUS       PORTS                    NAMES
0d055840ed23   postgres   "docker-entrypoint.s…"   3 hours ago   Up 3 hours   0.0.0.0:5432->5432/tcp   iluvcoffe_db_1

// docker exec -it [CONTAINER_ID OR NAMES] bash
$ docker exec -it 0d055840ed23 bash
----
//}}}

Once you have successfully login into *docker - machine*, try to login into
*Postgres - database* with these command, and enter the same `*"password"*` as
you type at `TypeOrmModule.forRoot()` in `AppModule`. In this case we use
`*pass123*`

[source, shell]
----
root@0d055840ed23:/# psql -U postgres -W postgres
Password:
----

Once you've login into *Postgres - database*, we can check the tables that
TypeORM just created automatically under the hood.

//{{{ postgres-# \d && postgres-# \d coffee
[source, shell]
----
postgres-# \d
              List of relations
 Schema |     Name      |   Type   |  Owner
--------+---------------+----------+----------
 public | coffee        | table    | postgres
 public | coffee_id_seq | sequence | postgres
(2 rows)

postgres-# \d coffee
                                  Table "public.coffee"
 Column  |       Type        | Collation | Nullable |              Default
---------+-------------------+-----------+----------+------------------------------------
 id      | integer           |           | not null | nextval('coffee_id_seq'::regclass)
 name    | character varying |           | not null |
 brand   | character varying |           | not null |
 flavors | json              |           |          |
Indexes:
    "PK_4d27239ee0b99a491ad806aec46" PRIMARY KEY, btree (id)
----
//}}}

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 6 == Using Repository To access Database
[[_using_repository_to_access_database]]
== Using Repository To access Database
:fn-repository_design_pattern: footnote:[ The Repository pattern is a well-documented way of working with a "data source". For each aggregate or aggregate root, you should create one repository class. In a microservice based on Domain-Driven Design (DDD) patterns, https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design]
:fn-async_await: footnote:[http://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await]

[#img-chapter]
[link=./images/chapter-3-8.png]
.Using Repository To Access Database
image::./images/chapter-3-8.png[align="center"]

TypeORM supports the *repository design pattern*{fn-repository_design_pattern}.
This means that *each - Entity* we create, has it *own - repository*.

[#img-chapter]
[link=./images/chapter-3-9.png]
.Using Repository To Access Database - 2
image::./images/chapter-3-9.png[align="center"]

The *Repository - class* are available from TyeORM. *Acts* as an _abstraction_
over our _data - source_, and expose a variety of useful method to interact with
the *records* stored in our database,

Since we've already registered *Coffee - Entity* in the scope of our
`CoffeesModule`.  We now have the *_ability_* to *inject* the automatically
*_generated - "Repository"_*, into our `CoffeesServices` using the
`*@InjectRepository()*` decorator exported from `@nestjs/typeorm` package.

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
import { Injectable, HttpException, HttpStatus, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";     // <<<
import { Repository } from "typeorm";                   // <<<
import { Coffee } from "./entities/coffee.entity";


@Injectable()
export class CoffeesService {
    private coffees: Coffee[] = [
        {
            id: 1,
            name: "Salemba Roast",
            brand: "Salemba Brand",
            flavors: ["chocolate", "vanilla"],
        },
    ];

    constructor(                                        // <<<
        @injectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>
    ){}

    ...
    ...
}
----
//}}}

Previously in our `CoffeesServices`, we used the `*"coffees: Coffee[]"*` - *Array* as our
*_mock_* in-memory data - source. Since we're using a real database now, we no
longer need this mock implementation. So let's remove it from or code - base.

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
import { Injectable, HttpException, HttpStatus, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";     // <<<
import { Repository } from "typeorm";                   // <<<

import { Coffee } from "./entities/coffee.entity";


@Injectable()
export class CoffeesService {
    constructor(                                        // <<<
        @injectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>
    ){}

    ...
    ...
}
----
//}}}

Now, we have bunch of error. Let's go inside of each method, one by one,
replacing our _mock - data_ interactions and instead use our new
*Coffee - Repository*.

NOTE: Before we dive into everything here, note that we will using a JavaScript
feature called *Async - Await*{fn-async_await}. If you are not familiar with it,
Async - Await makes *Promises* easier to manage and much more readable.

We'll need to update most of our methods here to be Async, in order for this to
work.  Let's start things off by looking at the `*findAll()*` method.

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
import { Injectable, HttpException, HttpStatus, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";

import { Coffee } from "./entities/coffee.entity";


@Injectable()
export class CoffeesService {
    constructor(
        @injectRepository(Coffee)
        private readonly coffeRepository: Repository<Coffee>
    ){}

    findAll() {
        return this.coffeeRepository.find();
    }
    ...
    ...
}
----
//}}}

First we remove the current code inside the method, and try to use our new
*Coffee - Repository*. Let's add return `this.CoffeesServices`, and hit `"*.*"`
period to see what kind of methods are available to us from
*TypeORM - Repository*. As we can see, there is a vast variety of method available
to us to handle almost any interaction with our data.

We need to find all Coffees. So in our case, let's use `find()` method here.

Next, let's update `*findOne()*`,

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
import { Injectable, HttpException, HttpStatus, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";

import { Coffee } from "./entities/coffee.entity";


@Injectable()
export class CoffeesService {
    constructor(
        @injectRepository(Coffee)
        private readonly coffeRepository: Repository<Coffee>
    ){}

    ...
    ...

    async findOne(id: string) {
        // throw "A Random Error";
        const coffee = await this.coffeeRepository.findOne(id).


        if (!coffee) {
            // throw new HttpException(`Coffee #${id} not found`, HttpStatus.NOT_FOUND);
            throw new NotFoundException(`Coffee with 'id: #${id}' not found`);
        }

        return coffee;
        // return this.coffees.find(item => item.id === +id);
    }

    ...
    ...
}
----
//}}}

First, let's add "*async*" before method name. Inside the method, let's replace
the existing mock - code and use the *Repository - method* `findOne()` making
sure to pass in the `*"id"*`.

Since `findOne()` here return a _Promise_. Let's *"await"* the result.

Next, our `*create()*` method.

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
import { Injectable, HttpException, HttpStatus, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";

import { Coffee } from "./entities/coffee.entity";
import { CreateCoffeeDto } from "./dto/create-coffee.dto";


@Injectable()
export class CoffeesService {
    constructor(
        @injectRepository(Coffee)
        private readonly coffeRepository: Repository<Coffee>
    ){}

    ...
    ...

    create(createCoffeeDto: CreateCoffeeDto) {
        const coffee = this.coffeeRepository.create(createCoffeeDto);

        return this.coffeRepository.save(coffee);
    }

    ...
    ...
}
----
//}}}

First, we replace the old code. We need to create a *Coffee - class instance* based
on our partial *DTO* and save it to the variable `*"coffee"*`.

Now that we have an "instance" of "coffee" *created*. All we need to do is
call the `*save()*` method, which return a *Promise*, and our *_new - Entity_*
will be saved to the database.

Also, let's make sure to replace `createCoffeeDto` of Type "*any*" with
appropriate Type `CreateCoffeeDto`. Which will now give us full *Type Safety*
- here as well, which we imported from `create-coffee.dto.ts`.

Now, on to `*update()*`.

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
import { Injectable, HttpException, HttpStatus, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";

import { Coffee } from "./entities/coffee.entity";
import { CreateCoffeeDto } from "./dto/create-coffee.dto";


@Injectable()
export class CoffeesService {
    constructor(
        @injectRepository(Coffee)
        private readonly coffeRepository: Repository<Coffee>
    ){}

    ...
    ...

    async update(id: string, updateCoffeeDto: UpdateCoffeeDto) {

        const coffee = await this.coffeeRepository.preload({
            id: +id,
            ...updateCoffeeDto,
        });

        if (!coffee) {
            throw new NotFoundException(`Coffee #${id} not found`);
        }

        return this.coffeeRepository.save(coffee);
    }

    ...
    ...
}
----
//}}}

First, let's add "*async*", again before the method - name, and let's replace
the existing code, and let's break everything down line by line again, so we
understand everything that's happening here.

First, we're using a new Repository - method called `*preload()*`. This method
creates a *new - Entity* based on the Object passed into it.

`preload()` first look to see if an Entity ALREADY exists in the database, and
if so, retrieves it and everything related to it.

If an Entity - exists already, `preload()` replaces all of the values with the
new ones passed in here in our `UpdateCoffeeDto`. Note that `preload()` method
will return undefined if the "*id*" if the entity passed in was NOT - found in
database.

For these reason, let's make sure we *_always test_* whether the result is
"*undefined*" and if so, you can see we're throwing a `NotFoundExpection` here.

To finish everything off, let's make sure we *save our changes* to the database
by calling the Repository - `save()` method.

Just like we did in our `create()` method a moment ago, we can also replace that
Type "*any*" in to use our `UpdateCoffeeDto` making us fully Type safe here as
well.

That's it for our `update()` method.

Next up, we have the `*remove()*` method,

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
import { Injectable, HttpException, HttpStatus, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";

import { Coffee } from "./entities/coffee.entity";
import { CreateCoffeeDto } from "./dto/create-coffee.dto";


@Injectable()
export class CoffeesService {
    constructor(
        @injectRepository(Coffee)
        private readonly coffeRepository: Repository<Coffee>
    ){}

    ...
    ...

    remove(id: string) {
        const coffee = await this.findOne(id);

        return this.coffeeRepository.remove(coffee);
    }

    ...
    ...
}
----
//}}}

Let's replace the existing code with the following, and break it down. We need
to retrieve the Coffee and if it exists, remove it from the database.

To achieve this, we can call to `findOne()` method that's within THIS service
passing in the `"*id*"`. Once we have the entity, all we need to do is call the
Repository - `*remove()*` method which return a *Promise* and make sure we pass
in the Coffee - Entity we just received.

We don't need to throw any Errors manually if Coffee does NOT exists, because
the `findOne()` method in our service automatically handles that for us.

Just like that, with a few lines of code in our service, we've *set up* an
entire *CRUD workflow* for *Coffee - Entity*!. We've managed to quickly migrate
all of our methods to use our real - database now.

So, let's fire up `insomnia`, and test some of these Routes to make sure
everything works.

Let's start by making a few _POST - requests_ to populate some entries in the
*Coffee - Table*.

//{{{ request [1]: 'POST - http://localhost:3002/coffees'
[source, json]
----
// request [1]: 'POST - http://localhost:3002/coffees'

// Body - raw: JSON
{
    "name": "Salemba Roast#1",
    "brand": "Salemba Brand",
    "flavors": ["chocolate", "vanilla"]
}

// response, 200 - OK
{
    "id": 1,
    "name": "Salemba Roast",
    "brand": "Salemba Brew",
    "flavors": [
        "chocolate",
        "vanilla"
    ]
}

/* -------------------- */

// request [2]: 'POST - http://localhost:3002/coffees'

// Body - raw: JSON
{
    "name": "Salemba Roast#2",
    "brand": "Salemba Brew",
    "flavors": ["cinnamon"]
}

// response, 200 - OK
{
    "id": 2,
    "name": "Salemba Roast#2",
    "brand": "Salemba Brew",
    "flavors": [
        "guava",
    ]
}

/* -------------------- */

// request [3]: 'POST - http://localhost:3002/coffees'

// Body - raw: JSON
{
    "name": "Salemba Roast#3",
    "brand": "Salemba Brew",
    "flavors": ["robusta"]
}

// response, 200 - OK
{
    "id": 2,
    "name": "Salemba Roast#3",
    "brand": "Salemba Brew",
    "flavors": [
        "robusta",
    ]
}
----
//}}}

Now, we have a few entries in our table, we can check to our Postgres - database,

//{{{ postgres=# SELECT * FROM coffee;
[source, mysql]
----
postgres=# SELECT * FROM coffee;
 id |      name       |    brand     |         flavors
----+-----------------+--------------+-------------------------
  2 | Salemba Roast#1 | Salemba Brew | ["chocolate","vanilla"]
  3 | Salemba Roast#2 | Salemba Brew | ["guava"]
  4 | Salemba Roast#3 | Salemba Brew | ["robusta"]
(3 rows)
----

Now, let's make a GET - request to `/coffees` and see if we get data back form
database.

[source, json]
----
// request: 'GET - http://localhost:3002/coffees'

// Body - raw: JSON
{
    "name": "Salemba Roast#1",
    "brand": "Salemba Brand",
    "flavors": ["chocolate", "vanilla"]
}

// response, 200 - OK
[
    {
        "id": 2,
        "name": "Salemba Roast#1",
        "brand": "Salemba Brew",
        "flavors": [
            "chocolate",
            "vanilla"
        ]
    },
    {
        "id": 3,
        "name": "Salemba Roast#2",
        "brand": "Salemba Brew",
        "flavors": [
            "guava"
        ]
    },
    {
        "id": 4,
        "name": "Salemba Roast#3",
        "brand": "Salemba Brew",
        "flavors": [
            "robusta"
        ]
    }
]
----
//}}}

Next, lest test the PATH - endpoint and update the fist coffee with `*"id":
2*`.  Let's change the endpoint we want to hit, to `/coffees/2`, and for our
*Body - payload*, let's pass in an Object with a different name.

In our case we're going to update the `*"name": "Salemba Roast#Update"*`

//{{{ request: 'PATCH - http://localhost:3002/coffees/2'
[source, json]
----
// request: 'PATCH - http://localhost:3002/coffees/2'

// Body - raw: JSON
{
    "name": "Salemba Roast#Update",
}

// response, 200 - OK
{
    "id": 2,
    "name": "Salemba Roast#Update",
    "brand": "Salemba Brew",
    "flavors": [
        "chocolate",
        "vanilla"
    ]
}
----
//}}}

We also check in our Postgres - database,

//{{{ postgres=# SELECT * FROM coffee;
[source, mysql]
----
postgres=# SELECT * FROM coffee;
 id |         name         |    brand     |         flavors
----+----------------------+--------------+-------------------------
  3 | Salemba Roast#2      | Salemba Brew | ["guava"]
  4 | Salemba Roast#3      | Salemba Brew | ["robusta"]
  2 | Salemba Roast#Update | Salemba Brew | ["chocolate","vanilla"] //<<<
(3 rows)
----
//}}}

It's also success to update the table - value for column `*"name"*` with
`*"id": 2*`

Our PATCH - endpoint actually returned the newly updated - Entity back from the
database for us!.

Let's make sure it really did changes by making a GET - request for
`/coffees/2` to double check.

//{{{ request: 'GET - http://localhost:3002/coffees/2'
[source, json]
----
// request: 'GET - http://localhost:3002/coffees/2'

// Body - raw: JSON
{
}

// response: 200 - OK
{
    "id": 2,
    "name": "Salemba Roast#Update",
    "brand": "Salemba Brew",
    "flavors": [
        "chocolate",
        "vanilla"
    ]
}
----
//}}}

Perfect, we can see it really did UPDATE the `*"name":` for that coffee!.

Lastly, let's make sure DELETE works by removing this item form the database.
If we switch `insomnia` to make a DELETE - request for the same `*"id": 2*`

//{{{ request: 'DELETE - http://localhost:3002/coffees/2'
[source, json]
----
// request: 'DELETE - http://localhost:3002/coffees/2'

// Body - raw: JSON
{
}

// response: 200 - OK
{
    "id": 2,
    "name": "Salemba Roast#Update",
    "brand": "Salemba Brew",
    "flavors": [
        "chocolate",
        "vanilla"
    ]
}
----
//}}}

Once we push - send, we should see that everything looks OK, no errors. We also
want to check our Postgres - database,

//{{{ postgres=# SELECT * FROM coffee;
[source, mysql]
----
postgres=# SELECT * FROM coffee;
 id |      name       |    brand     |   flavors
----+-----------------+--------------+-------------
  3 | Salemba Roast#2 | Salemba Brew | ["guava"]
  4 | Salemba Roast#3 | Salemba Brew | ["robusta"]
(2 rows)
----
//}}}

So far, so good. But let's do one more GET - request to make sure that it's
really gone.

//{{{ request: 'GET - http://localhost:3002/coffees/2'
[source, json]
----
// request: 'GET - http://localhost:3002/coffees/2'

// Body - raw: JSON
{
}

// response: 404 - Not Found
{
    "statusCode": 404,
    "message": "Coffee with 'id: #2' not found",
    "error": "Not Found"
}
----
//}}}

If we push - send, we should see a `*404 - NotFound*` - message come back. It
work the item is really gone now!.

So, just like that, we have everything working perfectly. We're using a *real -
database* now and we've managed to hit a lot of *fundamental - aspects* of
TypeORM and integrating with our Nest applications.

Our app is really starting to take shape now!.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 7 == Create a Relation Between Two Entities
[[_create_a_relation_between_two_entities]]
== Create a Relation Between Two Entities

[#img-chapter]
[link=./images/chapter-3-10.png]
.Create a Relation Between Two Entities
image::./images/chapter-3-10.png[align="center"]
:fn-relation: footnote:[https://docs.nestjs.com/techniques/database#relations]

*"Relation"*{fn-relation} are associations between two or more tables based on
common fields from each table, ofthen involving "*primary*" and "*foreign*"
- keys. There are *3 types* of - *Relations*. They are,

=== Type Of Relations

[#img-chapter]
[link=./images/chapter-3-11.png]
.Relation One-to-One
image::./images/chapter-3-11.png[align="center"]
:fn-relation: footnote:[https://docs.nestjs.com/techniques/database#relations]

- *One to One - Relations*.

In these Relations. Every *_row_* in the *primary - table* has *one and only one*
*associated - row* in the *foreign - table*.

In TypeORM, we define these Types - of Relations with the `*@OneToOne()*`
decorator.

[#img-chapter]
[link=./images/chapter-3-12.png]
.Relation One-to-Many
image::./images/chapter-3-12.png[align="center"]
:fn-relation: footnote:[https://docs.nestjs.com/techniques/database#relations]

- *One to Many* or *Many to One* - *Relations*.

For these Relations. Every *_row_* in the *primary - table* has *one or more*
- *related - rows* in the *foreign - table*.

In TypeORM, we define these Types - of Relations with the `*@OneToMany()*` and
`*@ManyToOne()*` decorator.


[#img-chapter]
[link=./images/chapter-3-13.png]
.Relation Many-to-Many
image::./images/chapter-3-13.png[align="center"]
:fn-relation: footnote:[https://docs.nestjs.com/techniques/database#relations]

- *Many to Many - Relations*.

This is when *every row* in the *primary - table* has *many related rows* in
the *foreign - table*, and *every - record* in the *foreign - table*, has *many
related rows* in the *primary - tables*.

In TypeORM, we define these Types - of Relations with the `*@ManyToMany()*`
decorator.

In a previous lesson, we temporarily labeled "*flavors:*" as type "JSON", so we
could store an Array there. Let's fix this now to use Relations and point to
multiple entries in a new "flavor" - table, we'll create in a moment.

To get started, let's create a new Flavor - Entity with Nest - CLI, making sure
we put it witin our Coffees - domain in the `/coffees/entities` folder.

In our terminal root project, let's enter in a command,

//{{{ $ nest g class coffees/entities/flavor-entity --no-spec
[source, shell]
----
$ nest g class coffees/entities/flavor-entity --no-spec
CREATE src/coffees/entities/flavor.entitiy.ts (30 bytes)
----

Just a reminder that we're passing in the `--no-spec` flag again, so that the
CLI doesn't generate a test - file as we won't need them for entities.

Now, let's open up our newly generated file, and define the corresponding - columns.

[source, typescript]
----
export class FlavorEntitiy {}
----
//}}}

Also, and this one is important, Let's make sure that the name of our class is
`*flavor*` without the "*entity*" - "suffix", as we DO NOT want the word
"entity" for our database *table - name*.

So let's replace the existing code with some additional code, and break it down.
So we know what exactly our code doing.

//{{{ flavor.entity.ts
[source, typescript]
----
// flavor.entity.ts
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity()
export class Flavor {
    @PrimaryGeneratedColumn()
    id: number;

    @Column()
    name: string;
}
----
//}}}

For our Flavor - Entity, we want to keep it simple, as we only need two - columns,
`*"id"*`, and `*"name"*`.

With this in place, we can now define our first - Relations.

Let's jump over to our *"Coffee - Entity"*, and update our existing *"flavors:"*
- properties.

//{{{ coffee.entity.ts
[source, typescript]
----
// coffee.entity.ts
import { Entity, PrimaryGeneratedColumn, JoinTable, ManyToMany } from "typeorm";
import { Flavor } from "./flavor.entity";

@Entity() // sql table === "coffee"
export class Coffee {
    @PrimaryGeneratedColumn()
    id: number;

    @Column()
    name: string;

    @Column()
    brand: string;

    @JoinTable()
    @ManyToMany(type => Flavor, (flavor) => flavor.coffees)
    flavors: string[];
}
----
//}}}

First, we removing the `@Column()` decorator and introduce some other decorator,
we'll need to make this a Relation.

Next, let's introduce a new decorator called `*@JoinTable()*` from the `typeorm`
- package, and add it on top of our `*"flavors:"*` - property. This
`@JoinTable()`  decorator, helps specify the OWNER - side of the relationship,
which in this case is the *Coffee - Entity*.

Now that we've *join this table*, let's define the type of relationship that we
want to exists between these entities and use the *corresponding - decorator*.

In this case, we need to define that *"each - Coffees"* can have *"multiple
- flavors"*. So we are going to be using `@ManyToMany()` decorator here for this
kind Relation.

Let's add the `@ManyToMany()` decorator also from the `"typeorm"` package right
below `@JoinTable()` decorator and passed a *few - 'parameters'* to help this
decorator understand and establish this Relation for each side.

For our first - parameter. We want to establish what the "*Type*" for this
*relation is*, by entering `*(type => Flavor)*`. This is just a function that
*return a - reference* to the *related - Entity*, in this case, the *Flavor
- Entity*.

For the next - parameter. Let's pass in an `"=>"` Arrow - function that return
the *related - Entity* and specify what *property* need to be *selected*; that
is the *"inverse - side"* of the relationship. In other words, what is
*"Coffee"* inside of the *Flavor - Entity*?

In our *Flavor - Entity*, we will reference *Coffee* as the *"coffees:"
- properties*.

So we want to select here via: `*"flavor.coffees"*`.

You might see we're getting an errors here as the *"coffees:" - property* does
*not exist* on our Flavor - Entity yet, but we'll fix that in a moment.

Let's jump into our Flavor - Entity and set up the *inverse - side* for our
*"Many to Many" - Relation*.

//{{{ flavor.entity.ts
[source, typescript]
----
// flavor.entity.ts
import { Column, Entity, PrimaryGeneratedColumn, ManytoMay } from "typeorm";
import { Coffee} from "./coffee.entity";

@Entity()   // sql tabel === "flavor"
export class Flavor {
    @PrimaryGeneratedColumn()
    id: number;

    @Column()
    name: string;

    @ManyToMany(type => Coffee, (coffee) => coffee.flavors)
    coffees: Coffee[];
}
----
//}}}

Let's add that missing - property called *"coffees:"* to our *Flavor - Entity*
and give it the Type of `*"Coffee[]"*` - Array.

Our *"Many to Many" - Relation*, was created by the *"owner: Coffee"*. But we
need to make sure TypeORM is aware of the *"inverse - side"* of the relationship
in this *Flavor - Entity* in order for this to be *properly connected*.

Since *Coffee* is the *owner* in this relationship, we don't have to use the
`@JoinTable()` decorator again.

Just as we did a moment ago, let's add the `@ManytoMay()` decorator on top of
the *"coffees:" - property* here, and pass in a *few - 'parameters'*.

For our first - parameter. Let's declare what the *Type* of our *"inverse
- Entity"* - *Relation* is. In this case, it's *"Coffee" - Entity*.

As for the next - parameter. Let's select where *Flavor* is indicated on the
*Coffee - Entity*, which is the *"flavors:" - property*. So let's enter in
`*"coffee.flavors"*` here.

Great!, and just like that, we've created a *"Many to Many" - relationship*
between these *two - entities* (tables).

But we almost forgot one thing!. We need to make sure we *register* our *Flavor
- Entity* with TypeORM.  Let's add "Flavor" to the `*"TypeORM.forFeature[]"*` in
our *CoffeesModule"*.

//{{{ coffees.module.ts
[source, typescript]
----
// coffees.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

import { CoffeesController } from "./coffees.controller";
import { CoffeesService } from "./coffees.service";
import { Coffee } from "./entities/coffee.entity";
import { Flavor } from "./entities/flavor.entity";      // <<<

@Module({
    imports: [ TypeOrmModule.forFeature([Coffee, Flavor])],  // <<<
    controllers: [CoffeesController],
    providers: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

That's it, once we start our application, the following tables will be created
by TypeORM.

[#img-chapter]
[link=./images/chapter-3-14.png]
.Flavor - Table
image::./images/chapter-3-14.png[align="center"]

[#img-chapter]
[link=./images/chapter-3-15.png]
.Coffee - Flavors Table - Relation
image::./images/chapter-3-15.png[align="center"]

NOTE: When we run our application in *development - mode*, TypeORM will
automatically add these tables for us. This due to *"synchronize: true"* being
set, but once again, make sure to *DISABLED* this on *production - mode*.

Let's also check our Postgres - database from Docker - Compose. Like we did in
xref:_register_entity_in_application[previous - chapter]

//{{{ postgres=# \dt
[source, mysql]
----
postgres=# \dt
                 List of relations
 Schema |         Name          | Type  |  Owner
--------+-----------------------+-------+----------
 public | coffee                | table | postgres
 public | coffee_flavors_flavor | table | postgres
 public | flavor                | table | postgres
(3 rows)

postgres-# \d
                  List of relations
 Schema |         Name          |   Type   |  Owner
--------+-----------------------+----------+----------
 public | coffee                | table    | postgres
 public | coffee_flavors_flavor | table    | postgres
 public | coffee_id_seq         | sequence | postgres
 public | flavor                | table    | postgres
 public | flavor_id_seq         | sequence | postgres
(5 rows)

postgres-# \d coffee_flavors_flavor
        Table "public.coffee_flavors_flavor"
  Column  |  Type   | Collation | Nullable | Default
----------+---------+-----------+----------+---------
 coffeeId | integer |           | not null |
 flavorId | integer |           | not null |
Indexes:
    "PK_64cde86968c8b440e3c63626e80" PRIMARY KEY, btree ("coffeeId", "flavorId")
    "IDX_25642975c6f620d570c635f418" btree ("flavorId")
    "IDX_9cb98a3799afc95cf71fdb1c4f" btree ("coffeeId")
Foreign-key constraints:
    "FK_25642975c6f620d570c635f418d" FOREIGN KEY ("flavorId") REFERENCES flavor(id) ON DELETE CASCADE
    "FK_9cb98a3799afc95cf71fdb1c4f9" FOREIGN KEY ("coffeeId") REFERENCES coffee(id) ON DELETE CASCADE

postgres-# \dt coffee_flavors_flavor
                 List of relations
 Schema |         Name          | Type  |  Owner
--------+-----------------------+-------+----------
 public | coffee_flavors_flavor | table | postgres
(1 row)

postgres-# \d flavor
                                 Table "public.flavor"
 Column |       Type        | Collation | Nullable |              Default
--------+-------------------+-----------+----------+------------------------------------
 id     | integer           |           | not null | nextval('flavor_id_seq'::regclass)
 name   | character varying |           | not null |
Indexes:
    "PK_934fe79b3d8131395c29a040ee5" PRIMARY KEY, btree (id)
Referenced by:
    TABLE "coffee_flavors_flavor" CONSTRAINT "FK_25642975c6f620d570c635f418d" FOREIGN KEY ("flavorId") REFERENCES flavor(id) ON DELETE CASCADE

postgres-# \d coffee
                                 Table "public.coffee"
 Column |       Type        | Collation | Nullable |              Default
--------+-------------------+-----------+----------+------------------------------------
 id     | integer           |           | not null | nextval('coffee_id_seq'::regclass)
 name   | character varying |           | not null |
 brand  | character varying |           | not null |
Indexes:
    "PK_4d27239ee0b99a491ad806aec46" PRIMARY KEY, btree (id)
Referenced by:
    TABLE "coffee_flavors_flavor" CONSTRAINT "FK_9cb98a3799afc95cf71fdb1c4f9" FOREIGN KEY ("coffeeId") REFERENCES coffee(id) ON DELETE CASCADE
----
//}}}

Excellent!, we have our tables in places.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 8 == Retrieve Entities With Their Relation
[[_retrieve_entities_with_their_relation]]
== Retrieve Entities With Their Relation
:fn-repository_d_ts: link:../iluvcoffe/node_modules/typeorm/repository/Repository.d.ts
:fn-find_many_options: link:../iluvcoffe/node_modules/typeorm/find-options/FindManyOptions.d.ts
:fn-find_one_options: link:../iluvcoffe/node_modules/typeorm/find-options/FindOneOptions.d.ts

In the previous lesson, we remove the `flavors:` "json" - column, including all
of it's data and created a Relation which now gives us a total of three - tables
in our database.

- "*coffee*" - table. Which represent "Coffees".
- "*flavors*" - table. Which represent "Flavors".
- "*coffee_flavors_flavor*" - table. Which represents the Coffee - Flavors *"Many
  to Many"* - Relation.

Now that we have set up our Relation in the previous - lesson. How can we make
sure our *endpoints retrieve* all of the *associated - data*?

Our GET `/coffees` - endpoint currently returns a *list of entities*, but without
the `*"flavors":*` - relations we've associated with it. Even though we define the
relationship Coffee with Flavors, the `*"flavors":*` - field WON'T automatically
be populated in our response. But Why?

This because Relations are NOT eagerly *loaded by default*. We have to
explicitly specify what Relations we want to be resolved when calling the
`*find()*` method of the Repository.

To fix this, let's open up our *CoffeesServices*, and update our *two - GET
endpoint - handlers* to include this Relation and make sure `*"flavors":*` gets
populated.

We start  with the `*findAll()*` method.

//{{{ coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, HttpException, HttpStatus, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";

import { Coffee } from "./entities/coffee.entity";
import { CreateCoffeeDto } from "./dto/create-coffee.dto";
import { UpdateCoffeeDto } from "./dto/update-coffee.dto";

@Injectable()
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
    ) {}


    findAll() {
        return this.coffeeRepository.find();
    }

    ...
    ...
}
----
//}}}

TypeORM allows us to pass in many different conditions or options to the
*Repository - methods*. If we go to {fn-repository_d_ts}[definition] on the
`find()` for example. You can see,

//{{{ Repository.d.ts
[source, typescript]
----
// iluvcoffe/node_modules/typeorm/repository/Repository.d.ts
...
...

/**
 * Repository is supposed to work with your entity objects. Find entities, insert, update, delete, etc.
 */

...
...


/**
 * Finds entities that match given options.
 */
find(options?: FindManyOptions<Entity>): Promise<Entity[]>;
/**
 * Finds entities that match given conditions.
 */
find(conditions?: FindConditions<Entity>): Promise<Entity[]>;

...
...
----
//}}}

All the different options for every one of the methods available to Repository
(`*"Repository.d.ts"*`). Let's dive in in a little deeper and see what
{fn-find_many_options}[FindManyOptions()] are.

//{{{ FindManyOptions.d.ts
[source, typescript]
----
// iluvcoffe/node_modules/typeorm/find-options/FindManyOptions.d.ts
import { FindOneOptions } from "./FindOneOptions";
/**
 * Defines a special criteria to find specific entities.
 */
export interface FindManyOptions<Entity = any> extends FindOneOptions<Entity> {
    /**
     * Offset (paginated) where from entities should be taken.
     */
    skip?: number;
    /**
     * Limit (paginated) - max number of entities should be taken.
     */
    take?: number;
}
----
//}}}
//
In this *"interface"*, we can see we're able to pass in things like *"skip?:"*
or *"take?:"*, which will be using later on *Pagination*, but it looks like this
*"interface"* is extending another one.

Let's keep digging and see what {fn-find_one_options}[FindOneOptions()] contains.

//{{{ FindOneOptions.d.ts
[source, typescript]
----
// iluvcoffe/node_modules/typeorm/find-options/FindOneOptions.d.ts
import { EntityFieldsNames } from "../common/EntityFieldsNames";
import { JoinOptions } from "./JoinOptions";
import { ObjectLiteral } from "../common/ObjectLiteral";
import { FindConditions } from "./FindConditions";
/**
 * Defines a special criteria to find specific entity.
 */
export interface FindOneOptions<Entity = any> {
    /**
     * Specifies what columns should be retrieved.
     */
    select?: (keyof Entity)[];
    /**
     * Simple condition that should be applied to match entities.
     */
    where?: FindConditions<Entity>[] | FindConditions<Entity> | ObjectLiteral | string;
    /**
     * Indicates what relations of entity should be loaded (simplified left join form).
     */
    relations?: string[];               // XXXX NOTE: this options what we want to use XXXX
    /**
     * Specifies what relations should be loaded.
     */
    join?: JoinOptions;
    /**
     * Order, in which entities should be ordered.
     */
    order?: {
        [P in EntityFieldsNames<Entity>]?: "ASC" | "DESC" | 1 | -1;
    };
    /**
     * Enables or disables query result caching.
     */
    cache?: boolean | number | {
        id: any;
        milliseconds: number;
    };
    /**
     * Indicates what locking mode should be used.
     */
    lock?: {
        mode: "optimistic";
        version: number | Date;
    } | {
        mode: "pessimistic_read" | "pessimistic_write" | "dirty_read" | "pessimistic_partial_write" | "pessimistic_write_or_fail";
    };
    /**
     * Indicates if soft-deleted rows should be included in entity result.
     */
    withDeleted?: boolean;
    /**
     * If sets to true then loads all relation ids of the entity and maps them into relation values (not relation objects).
     * If array of strings is given then loads only relation ids of the given properties.
     */
    loadRelationIds?: boolean | {
        relations?: string[];
        disableMixedMap?: boolean;
    };
    /**
     * Indicates if eager relations should be loaded or not.
     * By default they are loaded when find methods are used.
     */
    loadEagerRelations?: boolean;
    /**
     * If this is set to true, SELECT query in a `find` method will be executed in a transaction.
     */
    transaction?: boolean;
}
----
//}}}

In here, we have a lot of common database operations for things like,
`"join?:"`, `"where?:"`, `"order?:"`, etc. In our case we're looking for
`*"relations?:"*` which we can see as an  Array of Strings (`*"string[]"*`).

NOTE: Now, we know how *"track - the code"* from node_modules. As a *developer*
some times it is important to know how the code is flow.

Perfect. Let's go back to our *CoffeesService* and use it.

//{{{ coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, HttpException, HttpStatus, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";

import { Coffee } from "./entities/coffee.entity";
import { CreateCoffeeDto } from "./dto/create-coffee.dto";
import { UpdateCoffeeDto } from "./dto/update-coffee.dto";

@Injectable()
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
    ) {}

    findAll() {
        return this.coffeeRepository.find({
            relations: ["flavors"]          // <<<
        });
    }

    ...
    ...
}
----
//}}}

Let's pass this *"FindOneOptions" - Object* into our `find()` - method, by
entering in `*"relation:"*` with an Array, with the String `*["flavors"]*`
inside of it.

We're passing in `*["flavors"]*` here since we've *labeled that column* as our
*Relation for Coffee*.

Great!, now let's update our `*"findOne()"*` - GET method to make sure it's using
`*"relations:"*` and populating `*["flavors"]*` as well.

//{{{ coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, HttpException, HttpStatus, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";

import { Coffee } from "./entities/coffee.entity";
import { CreateCoffeeDto } from "./dto/create-coffee.dto";
import { UpdateCoffeeDto } from "./dto/update-coffee.dto";

@Injectable()
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
    ) {}

    findAll() {
        return this.coffeeRepository.find({
            relations: ["flavors"]              // <<<
        });
    }

    async findOne(id: string) {

        // throw "A Random Error";
        const coffee = await this.coffeeRepository.findOne(id, {
            relations: ["flavors"],             // <<<
        });

        if (!coffee) {
            throw new NotFoundException(`Coffee with 'id: #${id}' not found`);
        }

        return coffee;
    }
    ...
    ...
}
----
//}}}

Inside our `findOne()`, let's pass in a second - paramater after `*"id"*`, and
pass in the same thing, and Object with `*"relation:"*`, that's a String of
`*["flavors"]*`

Let's save our changes, head to `insomnia` and call the `*findAll()*` - *GET*
endpoint `*/coffees*` once again and see if it works.

//{{{ request: 'GET - http://localhost:3002/coffees'
[source, json]
----
// request: 'GET - http://localhost:3002/coffees'

// Body - raw: JSON
{
}

// response: 200 - OK
[
    {
        "id": 4,
        "name": "Salemba Roast#3",
        "brand": "Salemba Brew",
        "flavors": []
    },
    {
        "id": 3,
        "name": "Salemba Roast#2",
        "brand": "Salemba Brew",
        "flavors": []
    }
]
----
//}}}

As you can see above, each Object now contains the resolved `"flavors":`
- Relation, Excellent!.

One last thing, let's test to `*findONE()*` - *GET* endpoint by checking
`*"/cofees/3"*`, for example

//{{{ request: 'GET - http://localhost:3002/coffees'
[source, json]
----
// request: 'GET - http://localhost:3002/coffees'

// Body - raw: JSON
{
}

// response: 200 - OK
{
    "id": 3,
    "name": "Salemba Roast#2",
    "brand": "Salemba Brew",
    "flavors": []
}
----
//}}}

Great, it works as well, and just like that, we're all set!.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 9 == Using Cascading Inserts and Updates
[[_using_cascading_inserts_and_updates]]
== Using Cascading Inserts and Updates
:fn-cascade: footnote:[CASCADE. It is used in conjunction with ON DELETE or ON UPDATE. It means that the child data is either deleted or updated when the parent data is deleted or updated. https://findanyanswer.com/what-is-cascade-in-databaser]

Let's imagine a fairly common scenario. Where we want to add a new *"Coffee"*
into our database, but it has *"Flavors"* that are *NOT present* in our
*"Flavors" - table* just yet!. Luckily, we have a few options can do to handle
this properly.

We *could* manually insert all of these new - "Flavors" into a database and
afterwards, create a new "Coffee - Entity", but that's not ideal!. A better
options be for us to do "Cascading - Inserts".

To enable Cascading{fn-cascade} for both INSERT and UPDATES, let's set `"cascade:"`
- property to `"true"` Inside of our Relations, such as the *"Many to Many"
- Relation* we have between "Coffee" and "Flavor".

NOTE: If we want, we can also limit *"cascade:"* to just INSERT OR UPDATE as as well.

Let's open our Coffee - Entity,

//{{{ coffee.entity.ts
[source, typescript]
----
// coffee.entity.ts
import { Entity, PrimaryGeneratedColumn, Column, JoinTable, ManyToMany } from "typeorm";
import { Flavor } from "./flavor.entity";

@Entity() // sql table === "coffee"
export class Coffee {
    @PrimaryGeneratedColumn()
    id: number;

    @Column()
    name: string;

    @Column()
    brand: string;

    @JoinTable()
    @ManyToMany((type) => Flavor, (flavor) => flavor.coffees, {
        cascade: true, //["insert"]         // <<<
    })
    flavors: string[];
}
----
//}}}

Well, with these small addition, "Flavors" that belong to a *newly - created
Coffee* will be automatically inserted  into the database for us.

But to make this work, we still need to perform a few more *updates to our
code*.

If we look back to one of our *DTO's* we've made so far
*"create-coffee.dto.ts"*; they contain a *`"flavors:"` - property*, which is an
Array of String (`*"string[]"*`).

//{{{ create-coffee.dto.ts
[source, typscript]
----
// create-coffee.dto.ts
import { IsString } from "class-validator";

export class CreateCoffeeDto {
    @IsString()
    readonly name: string;

    @IsString()
    readonly brand: string;

    @IsString({ each: true })
    readonly flavors: string[];     // <<<
}
----
//}}}

But we need to make sure we *MAP* these String, which are "names" of "flavors:"
to real Entities, instances of Flavor - Entity.

To do this, we'll first need to *inject* the Flavor - Repository into our
"CoffeesService" - class.

//{{{ coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, HttpException, HttpStatus, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";

import { Coffee } from "./entities/coffee.entity";
import { Flavor } from "./entities/flavor.entity";
import { CreateCoffeeDto } from "./dto/create-coffee.dto";
import { UpdateCoffeeDto } from "./dto/update-coffee.dto";

@Injectable()
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)                               // <<<
        private readonly flavorRepository: Repository<Flavor>,  // <<<
    ) {}

    ...
    ...
}
----
//}}}

With these in place, let's define a *new - private method* and call it
`*"preloadFlavorByName()"*`,

//{{{ coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, HttpException, HttpStatus, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";

import { Coffee } from "./entities/coffee.entity";
import { Flavor } from "./entities/flavor.entity";
import { CreateCoffeeDto } from "./dto/create-coffee.dto";
import { UpdateCoffeeDto } from "./dto/update-coffee.dto";

@Injectable()
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,
    ) {}

    ...
    ...

    private async preloadFlavorByName(name: string): Promise<Flavor> {          // <<<
        const existingFlavor = await this.flavorRepository.findOne({ name });

        if (existingFlavor) {
            return existingFlavor;
        }

        return this.flavorRepository.create({ name });
    }

}
----
//}}}

In this method, we're taking a "Flavor - name" `("name": string)` as an input
argument, and returning a *Promise* that resolve to a real Flavor - Entity.

If a "Flavor" with specified - `"name"` already exists in our database, we want
to return it. Otherwise, this method *creates a new "class - instances"* with
the `"name"` we passed in.

Now, that we have this method, let's put it to good - use in both our `create()`
and `update()` methods.

//{{{ coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, HttpException, HttpStatus, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";

import { Coffee } from "./entities/coffee.entity";
import { Flavor } from "./entities/flavor.entity";
import { CreateCoffeeDto } from "./dto/create-coffee.dto";
import { UpdateCoffeeDto } from "./dto/update-coffee.dto";

@Injectable()
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)                               // <<<
        private readonly flavorRepository: Repository<Flavor>,  // <<<
    ) {}

    ...
    ...

    async create(createCoffeeDto: CreateCoffeeDto) {
        const flavors = await Promise.all(
            createCoffeeDto.flavors.map(name => this.preloadFlavorByName(name)),
        );

        const coffee = this.coffeeRepository.create({...createCoffeeDto, flavors});

        return this.coffeeRepository.save(coffee);
    }

    ...
    ...

}
----
//}}}

First, let's make a few tweaks to the `create()` - method. This method needs
to *"loop"* through all the `"flavors"` in our "CreateCoffeeDto" with the `map()`
- function and call our new - "preloadFlavorByName()" - method to make sure
they're properly populated.

Using `"await"` in *combination* with `"Promise.all()"` it's let us wait the
entire *Array of Promises* finished before executing further code.

Once the code finished executing, we'll have an *"Array of Flavor - Entity"* in
our new "flavors" - variable we just defined here.

Now, all we have to do is, merge `"createCoffeeDto"` with our updated Flavor
- Entities.

We can easily do this by using the `'...'` - *spread operator* to get al the
properties of our `createCoffeeDto` - Object (`...createCoffeeDto`); and then
afterwards overriding the "flavors - properties" with our new populated
"flavors" - variable, of the same name.

You could see we're getting some errors here, as the *`"flavors:"` - type doesn't
match*

//{{{ error TS2769: No overload matches this call.
[source, bash]
----
src/coffees/coffees.service.ts:56:75 - error TS2769: No overload matches this call.
...
...
src/coffees/entities/coffee.entity.ts:19:5
19     flavors: string[];
       ~~~~~~~
The expected type comes from property 'flavors' which is declared here on type 'DeepPartial<Coffee>'
----
//}}}

Let's fix this real quick. If we head over to our "Coffee - Entity",

//{{{ cofee.entity.ts
[source, typescript]
----
// cofee.entity.ts
import { Entity, PrimaryGeneratedColumn, Column, JoinTable, ManyToMany } from "typeorm";
import { Flavor } from "./flavor.entity";

@Entity() // sql table === "coffee"
export class Coffee {
    @PrimaryGeneratedColumn()
    id: number;

    @Column()
    name: string;

    @Column()
    brand: string;

    @JoinTable()
    @ManyToMany((type) => Flavor, (flavor) => flavor.coffees, {
        cascade: true, //["insert"]
    })
    flavors: Flavor[];
    //flavors: string[];
}
----
//}}}

Let's change the Type of the "flavors:" - property to the type Array of "Flavor"
(`"Flavor:[]"`). Which going forward, and it's what we'd always want to do when
creating Entity - Relations.

With this mix in place, we can now go back to our "Coffee" - `"create()"`
method.

Lastly, all we need to do is call the `"save()"` method for our new `"coffee"`,
and that's it.

Likewise, we must follow the same steps in our '*"update()"*` - method below.

//{{{ coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, HttpException, HttpStatus, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";

import { Coffee } from "./entities/coffee.entity";
import { Flavor } from "./entities/flavor.entity";
import { CreateCoffeeDto } from "./dto/create-coffee.dto";
import { UpdateCoffeeDto } from "./dto/update-coffee.dto";

@Injectable()
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,
    ) {}

    ...
    ...

    async update(id: string, updateCoffeeDto: UpdateCoffeeDto) {
        const flavors =
            updateCoffeeDto.flavors &&
            (await Promise.all(updateCoffeeDto.flavors.map((name) => this.preloadFlavorByName(name))));

        const coffee = await this.coffeeRepository.preload({
            id: +id,
            ...updateCoffeeDto,
            flavors,
        });

        if (!coffee) {
            throw new NotFoundException(`Coffee #${id} not found`);
        }

        return this.coffeeRepository.save(coffee);
    }
    ...
    ...

}
----
//}}}

There's one difference here that w should point out. In our *"PATCH
- operation"*, the `"flavors"` - property is *optional*.

Let's make sure we add an *"inline condition"* here, to make sure we actually
*have* "flavors" before we call the "map()" method on each one of them to
preload it.

If we *didn't add this condition*, we'd get an Error if `flavors` was ever
*"undefined"*.

Now, heading back to our "Coffee Entity", since we have `"cascade:"` set to
`"true"` in our Relation, any *new* - `"flavors"` will be automatically added to the
database together along with *any Coffees - created* with everything an their
relationship tied together!.

Let's fire up `insomnia` and test some pf these routes to make sure everything
we did works.

First, let's make a POST - request, making sure we specified a *"flavors: []"
- property* in the *"request - payload"* and hit enter.

//{{{ request: 'POST - http://localhost:3002/coffees/'
[source, json]
----
// request: 'GET - http://localhost:3002/coffees'

// Body - raw: JSON
{
    "name": "Salemba Roast#1",
    "brand": "Salemba Brew",
    "flavors": [
        "robusta",
        "chocolate"
    ]
}

// response: 200 - OK

{
    "name": "Salemba Roast#1",
    "brand": "Salemba Brew",
    "flavors": [
        {
            "id": 1,
            "name": "robusta"
        },
        {
            "id": 2,
            "name": "chocolate"
        }
    ],
    "id": 3
}
----
//}}}

Great, no errors.

Now let's make a GET - request with endpoint "/coffees" to see if new
`*"flavors:[]"*` were properly populated in our database.

//{{{ request: 'GET - http://localhost:3002/coffees/'
[source, json]
----
// request: 'GET - http://localhost:3002/coffees'

// Body - raw: JSON
{
    "name": "Salemba Roast#1",
    "brand": "Salemba Brew",
    "flavors": [
        "robusta",
        "chocolate"
    ]
}

// response: 200 - OK

[
    {
        "id": 3,
        "name": "Salemba Roast#1",
        "brand": "Salemba Brew",
        "flavors": [
            {
                "id": 1,
                "name": "robusta"
            },
            {
                "id": 2,
                "name": "chocolate"
            }
        ]
    }
]
----
//}}}

Great, there we have it, we can see the new flavors were added into the database
and even came back with this response.

=== Cascading - Reference

Here some reference for Cascading in SQL - database

- link:https://docs.oracle.com/cd/E26180_01/Platform.94/RepositoryGuide/html/s0610cascadingdatarelationships01.html[Cascading Data Relationships, window=_blank]
- link:https://docs.oracle.com/cd/E26180_01/Platform.94/RepositoryGuide/html/s0610cascadeinsert01.html[Cascade Insert, window=_blank]
- link:http://stackoverflow.com/questions/59297/when-why-to-use-cascading-in-sql-server[database design - When/Why to use Cascading in SQL Server, window=_blank]
- link:https://www.quora.com/What-is-the-meaning-of-cascade-in-Oracle?share=1[What is the meaning of cascade in Oracle? - Quora, window=_blank]
- link:https://orkhan.gitbook.io/typeorm/docs/relations[TypeORM Document - RELATIONAL, window=_blank]

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 10 == Adding Pagination
[[_adding_pagination]]
== Adding Pagination
:fn-class_transformer: footnote:[Class-transformer allows you to transform plain object to some instance of class and versa. Also it allows to serialize / deserialize object based on criteria. This tool is super useful on both frontend and backend. https://github.com/typestack/class-transformer]
:fn-class_validator: footnote:[install size Allows use of decorator and non-decorator based validation. Internally uses validator.js to perform validation. Class-validator works on both browser and node.js platforms. https://github.com/typestack/class-validator]

In previous lessons, we set up our *GET - endpoints* to take pagination
- parameter. But we didn't actually implement anything, especially within the
context of TypeORM.

Let's take a look at how we can apply *"limit"* and *"offset"* in our
`CoffeesService.findAll()` - method to retrieve the specific amount and specific
selection of "Coffees" from our database.

First, let's generate a class for our `PaginationQueryDto`, which we haven't made
yet, because our pagination - query was just for demonstration purposes so far.

Using the Nest - CLI, let's create this DTO by entering:

//{{{ $ nest g class common/dto/pagination-query.dto --no-spec
[source, shell]
----
$ nest g class common/dto/pagination-query.dto --no-spec
CREATE src/common/dto/pagination-query.dto.ts (35 bytes)
----
//}}}

NOTE: We're generating this class in a new directory named *"/common"*

Going forward, we're going to keep things that *aren't tied to specific domain*
and could be *use by multiple - controllers* in this *"common/"* - folder.

Let's open up this new *"PaginationQueryDto"* and set *two - properties*,
*"limit"* and *"offset"*. Both of which can make Type - "number".

//{{{ pagination-query.dto.ts
[source, typescript]
----
// pagination-query.dto.ts
import { Type } from "class-transformer";
import { IsOptional, IsPostive } from "class-validator";
export class PaginationQueryDto {
    @IsOptional()
    @IsPostive()
    @Type(() => Number)
    limit: number;

    @IsOptional()
    @IsPostive()
    @Type(() => Number)
    offset: number;
}
----
//}}}

Now, let's add a few decorators to both of these properties. The first one being
the `"*@Type()*"` decorator from the *"class-transformer"*{fn-class_transformer}
- package. On this line, we're making sure that the value coming-in is parsed as
a "Number".

You might remember from previous lesson, we said that `"*queryParams*"` are sent
through the network as *String*. With this decorator, helps to solve that
problem, automatically for us.

The next decorator we'll use is called `*"@IsOptional()"*` from
*"class-validator"*{fn-class_validator}.  As the name implies, this decorator
marks this property as "optional", meaning that no Errors will be thrown if it's
"missing" or "undefined".

Lastly, let's add the `*"@IsPostive()*` decorator also from `class-validator`,
which checks, if the value is a positive number, greater than zero.

One thing to remember about `@Type()` decorator we added here is, instead of
*manually doing conversion* here like we did in this file, we could have
alternatively *enabled the implicit type conversion on a global - level* by
adding the `*"transformOptions"*` - Object to our `"ValidationPipe"` with
`*"enableImplicitConversion"*` set to `*"true"*`.

//{{{ main.ts
[source, typescript]
----
// main.ts
import { NestFactory } from "@nestjs/core";
import { ValidationPipe } from "@nestjs/common";
import { AppModule } from "./app.module";

async function bootstrap() {
    const app = await NestFactory.create(AppModule);

    app.useGlobalPipes(
        new ValidationPipe({
            whitelist: true,
            transform: true,
            forbidNonWhitelisted: true,             // <<<
            transformOptions: {                     // <<<
                enableImplicitConversion: true      // <<<
            },
        }),
    );
    await app.listen(3002);

    // console.log("app is run on port: 3002");
}
bootstrap();
----
//}}}

With these options in our `"ValidationPipe"`, we *no longer have to explicitly
specific Types with the `@Type()` decorator*. So, let use this and removes that
`@Types()` decorator from our "pagination - DTO".

//{{{ pagination-query.dto.ts
[source, typescript]
----
import { Type } from "class-transformer";
import { IsOptional, IsPostive } from "class-validator";
export class PaginationQueryDto {
    @IsOptional()
    @IsPostive()
    limit: number;

    @IsOptional()
    @IsPostive()
    offset: number;
}
----
//}}}

Now that we have all of decorators in place, let's navigate to the
`"CoffeesController"` and give that `paginationQuery` - parameter, our new - DTO
Type, `PaginationQueryDto` in the *`findAll()` - method signature*.

//{{{ coffee-controller.dto.ts
[source, typescript]
----
import { Controller, Get, Param, Body, Post, HttpCode, HttpStatus, Res, Patch, Delete, Query } from "@nestjs/common";
import { CoffeesService } from "./coffees.service";
import { CreateCoffeeDto } from "./dto/create-coffee.dto";
import { UpdateCoffeeDto } from "./dto/update-coffee.dto";
import { PaginationQueryDto } from "./common/dto/pagination-query.dto.ts";

@Controller("coffees")
export class CoffeesController {
    constructor(private readonly coffeesService: CoffeesService) {}

    @Get()
    findAll(@Query() paginationQuery: PaginationQueryDto) {     // <<<
        // const { limit, offset } = paginationQuery;
        return this.coffeesService.findAll(paginationQuery);    // <<<
    }

    ...
    ...
}
----
//}}}

Next, let's make sure we're passing this `paginationQuery` - argument, to the
`findAll()` method since we'll need it for TypeORM.

Let's jump into this `findAll()` method in our `CoffeesService` and update the
input arguments there as well.

//{{{ coffee-service.dto.ts
[source, typescript]
----
import { Injectable, HttpException, HttpStatus, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";

import { Coffee } from "./entities/coffee.entity";
import { Flavor } from "./entities/flavor.entity";
import { CreateCoffeeDto } from "./dto/create-coffee.dto";
import { UpdateCoffeeDto } from "./dto/update-coffee.dto";
impoort { PaginationQueryDto } from "./common/dto/pagination-query.dto";

@Injectable()
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,
    ) {}

    findAll(paginationQuery: PaginationQueryDto) {      // <<<
        const { limit, offset } = paginationQuery;
        return this.coffeeRepository.find({
            relations: ["flavors"],
            skip: offset,                               // <<<
            take: limit,                                // <<<
        });
    }
}
----
//}}}

Great, so now we're using real DTO's and we're passing the `"limit"` and
`"offset"` values down.

Next, let's update our TypeORM `Repository.find()` method to utilize everything.
You may remember in previous lessons, we looked inside of the interface for the
Repository - `find()` method and saw all the *condition* or *options* we're able
to pass to TypeORM.

For Pagination. We saw that they are called "skip" and "take". Let's add both of
these inside of our  `FindConditions` - Object, passing `*"offset"*` to
`*"skip:"*` and `*"limit"*` to `*"take:"*`

With this setup, we've set up real Pagination with our database.

So, let's open `insomnia` and test this out and see if it really works.

First, Let's check our "Coffees" - items in our database, by making a  "GET
- request" to `/coffees` - endpoint

//{{{ request: 'GET - http://localhost:3002/coffees'
[source, json]
----
// request: 'GET - http://localhost:3002/coffees'

// Body - raw: JSON
{
}

// response: 200 - OK
[
    {
        "id": 1,
        "name": "Salemba Roast#1",
        "brand": "Salemba Brew",
        "flavors": [
            {
                "id": 1,
                "name": "chocolate"
            },
            {
                "id": 2,
                "name": "vanilla"
            }
        ]
    },
    {
        "id": 2,
        "name": "Salemba Roast#2",
        "brand": "Salemba Brew",
        "flavors": []
    },
    {
        "id": 3,
        "name": "Salemba Roast#3",
        "brand": "Salemba Brew",
        "flavors": []
    }
]
----
//}}}

Excellent. We have three records of "Coffees" we get receive from database.

Next, let's start by calling our `/coffees` GET - endpoint. But this time, let's
make sure we pass in some *Query - Parameters*

First, let's pass in `*"?limit=1"*` in our URL - Query. This should only return ONE
- result if everything goes well. Let's push send and try it out.

//{{{ request: 'GET - http://localhost:3002/coffees?limit=1'
[source, json]
----
// request: 'GET - http://localhost:3002/coffees?limit=1'

// Body - raw: JSON
{
}

// response: 200 - OK
[
    {
        "id": 1,
        "name": "Salemba Roast#1",
        "brand": "Salemba Brew",
        "flavors": [
            {
                "id": 1,
                "name": "chocolate"
            },
            {
                "id": 2,
                "name": "vanilla"
            }
        ]
    }
]
----
//}}}

Great, it worked!. We receive just ONE - Coffee back from our database.

Now, let's remove `limit=1` and try `*"/coffees?offset=1"*`,

//{{{ request: 'GET - http://localhost:3002/coffees?offset=1'
[source, json]
----
// request: 'GET - http://localhost:3002/coffees?offset=1'

// Body - raw: JSON
{
}

// response: 200 - OK
[
    {
        "id": 2,
        "name": "Salemba Roast#2",
        "brand": "Salemba Brew",
        "flavors": []
    },
    {
        "id": 3,
        "name": "Salemba Roast#3",
        "brand": "Salemba Brew",
        "flavors": []
    }
]
----
//}}}

When we push send, We should see now that is *skipped* the "first - Coffee",
and we got back ALL the rest of the result from the database.

**⬆xref:_table_of_contents[back to top]**
//}}}

//**⬆xref:_table_of_contents[back to top]**
