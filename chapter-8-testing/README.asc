//{{{ ** ASCIIDOC HEADER
:description:   nestjs official course | chapter-8
:url-repo:      https://github.com/agungTuanany/nestjs_course_official
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Fri Apr  9 06:54:56 AM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
//}}}

[[_chapter_8_testing]]
= Chapter-8 Testing
:figure-caption!:
:source-highlighter: highlight.js

//{{{== Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_introducing_to_jest[Introducing to JEST]
| 2.    | xref:_getting_started_with_test_suites[Getting Started With Test Suites]
| 3.    | xref:_adding_unit_tests[Adding Unit Tests]
| 4.    | xref:_diving_into_e2e_test[Diving into E2E Test]
|====
//}}}

//{{{ 1 == Introducing to JEST
[[_introducing_to_jest]]
== Introducing to JEST

//{{{ image::./images/chapter-8-1.png
[#img-chapter]
[link=./images/chapter-8-1.png]
.Introducing To JEST
image::./images/chapter-8-1.png[align="center"]
//}}}

Automated testing is considered an essential part of any serious software
development effort.  Automation makes it easier to repeat "individual - tests",
or "test - suites" -quickly during development.

With NestJS we can use any testing framework we prefer. However it can be quite
tedious to set everything up. Luckily for us Nest provides a built-in
integration with the "*Jest*" - testing framework out of the box, so we don't
have to do anything to get started.

//{{{ image::./images/chapter-8-2.png
[#img-chapter]
[link=./images/chapter-8-2.png]
.Introducing To JEST -2
image::./images/chapter-8-2.png[align="center"]
//}}}

"*Jest*" is a delightful JavaScript testing framework with a focus on
simplicity.  It allows you to write test with an approachable, familiar, and
feature rich API that gives you result quickly.

"*Jest*" provides great "Error - messages" and built-in Mocking utilities, to
make testing your applications much simpler. Also it reliably *run test in
"parallel"*.

To make tests run *even faster*, "*Jest*" runs previously failed test first, and
then reorganizes test runs, based on how long "Test - file" take.

//{{{ image::./images/chapter-8-3.png
[#img-chapter]
[link=./images/chapter-8-3.png]
.Introducing To JEST -3
image::./images/chapter-8-3.png[align="center"]
//}}}

In NestJS applications, we use "*Jest*" to run "*unit* - tests" and
"*end-to-end* - tests"

There are several command you can use to run "*specific test*",

- `npm run test`, for unit tests
- `npm run test:cov`, for unit test and collecting testing coverage
- `npm run test:e2e`, for end-to-end tests

With nest. We automatically have all of this power with no additional setup
needed!.

So far in this course we haven't paid too much attention to *"testing"*.  Thus,
some of the existing, or automatically generated tests may *fail*.

In the next few lesson. We'll introduce you to the "*Jest*" framework. Show you
how to use NestJS - "testing - utilities", and fix some of the existing "test
- file" - all step by step.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 2 == Getting Started With Test Suites
[[_getting_started_with_test_suites]]
== Getting Started With Test Suites
:fn-aggregate: footnote:[total, accumulative]

//{{{ image::./images/chapter-8-4.png
[#img-chapter]
[link=./images/chapter-8-4.png]
.Getting Started With Test Suites
image::./images/chapter-8-4.png[align="center"]
//}}}

Testing by itself is quite the endless topic that could be fragmented into many
separate lessons. We can't really cover *every* aspect of testing itself. We'll
be focusing primarily on how testing works within NestJS.

We'll be focusing mainly on tips and tricks, showcasing some best practices, and
go over how you can add manage test in your "Nest - applications".

//{{{ image::./images/chapter-8-5.png
[#img-chapter]
[link=./images/chapter-8-5.png]
.Getting Started With Test Suites
image::./images/chapter-8-5.png[align="center"]
//}}}

For unit tests in NestJS, it's a common practice to keep the `*".spec.ts"*`
- files in the *same folder* as the application source code files that they
test.

Each *"Controller"*, *"Provider"*, *"Service"*, etc should have its *own*
dedicated "test - file".

The test file extension must be `*".spec.ts"*`. This is so that integrated
- "test tooling" can identify it as a "test - file" with "test - suites" or
"end-to-end - test".

//{{{ image::./images/chapter-8-6.png
[#img-chapter]
[link=./images/chapter-8-6.png]
.Getting Started With Test Suites
image::./images/chapter-8-6.png[align="center"]
//}}}

These files are typically located in a dedicated `"/test/"` - directory by
default.

"End-to-end - test" are typically grouped into separate files by the *"feature"*
or *"functionality"* that they test.

For "end-to-end - test". The file extension must be `*".e2e-spec.ts"*`.

While "unit - tests" focus on *individual classes* and *functions*. "End-to-end
- test" are great for *"high level validation"* of the *entire system*.

"End-to-end - testing" covers the interaction "End-to-end - testing" covers the
*interaction* of classes and models at more *"aggregate level{fn-aggregate}"*
closer to the kid of interaction that "end-users" will have with the "production
system".

As application grows, it becomes hard to manually test the "end-to-end
- behavior" of each "API - endpoint".

Automated "end-to-end - test" help us ensure that the "*overall* behavior" of
the system is *correct*, and it meets project requirement.

To better understand how tests look an how they work. Let's open up
"CoffeesService" - `".spec"` - file, we haven't looked at yet and walk through
everything - step by step!.

//{{{  coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
import { Test, TestingModule } from "@nestjs/testing";
import { CoffeesService } from "./coffees.service";

describe("CoffeesService", () => {
    let service: CoffeesService;

    beforeEach(async () => {
        const module: TestingModule = await Test.createTestingModule({
            providers: [CoffeesService],
        }).compile();

        service = module.get<CoffeesService>(CoffeesService);
    });

    it("should be defined", () => {
        expect(service).toBeDefined();
    });
});
----
//}}}

First, we can see that the `*"describe()"*` - function that define a *"block"*
which groups together several related tests.

In this case, the `"describe()"` - block is grouping all the "unit - test" that
concern "CoffeesService" - class.

Inside this block. We can see that `*"beforeEach()"*` - function.

This function passed into the `beforeEach()` - *hook*, will be executed *before*
EVERY test.  This is typically referred to as the *"setup phase"*.

Often while writing tests. We have some "*setup work*" that needs to happen
BEFORE *each* test runs; and sometimes you need to do something "after" EACH
test runs.

"Jest" provides several other "*helper*" - functions to handle situations like
this.

We know `beforeEach()` now, but the other available options are:
`*"beforeAll()"*`, `*"afterEach()"*`, and `*"afterAll()"*`.

So looking at this test file. Let's dive into the `beforeEach()` - function call
here, to see what it's doing.

//{{{  coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
    ...
    ...
    beforeEach(async () => {
        const module: TestingModule = await Test.createTestingModule({
            providers: [CoffeesService],
        }).compile();

        service = module.get<CoffeesService>(CoffeesService);
        // service = wait module.resolve(CoffeesService)
        //                       ~~~~~~~
    });
    ...
    ...
----
//}}}

At a very high level. We can see that we're instantiating some pf Module by
compiling a "Test - Module", and then utilizing this module to get a hold of the
"CoffeesService".

Then it looks like we're *storing* it in the `"service"` - variable, we use
within our "individual - tests" inside of *this* `describe()` - block.

Let's start by analyzing everything that's happening here.

The `*"Test"*` - Class is, useful for providing an application
*"ExecutionContext"* that essentially Mocks the full Nest *"runtime"*. But gives
you *"hooks"* that make it easy to manage "Class - instances", and do anything
like Mocking and "overriding aspects" of your application.

The `*"Test"*` - Class, has a `*"createTestingModule({})"*` - method that takes
a 'Module - Metadata" - Object as its argument the same object we pass into our
`@Module({ /* this object */ })` - decorators.

One important thing to note here is, the `*".compile()"*` - method.

This method bootstrapped the Module with its dependencies, similar to the way we
bootstrap our application in our `main.ts` - file: with
`"NestFactory.create(/*AppModule*/)"`.

The `.compile()` - method return a `"TestingModule"` - instance which in turn
gives us access to a few helpful methods!.

Once our "TestingModule" is compiled. We can retrieve *any static instance*
declared within the Module by using the `".get()"` - method we see being used
here!.

As we can see, we're calling the `get()` - method here to retrieve our
"CoffeesService" from within our compiled "TestingModule", and then *storing it*
in the `"service"` - variable defined within our `describe()` - block.

This is *standard practice* for testing, that allows us to "*_store_*" and
"*_use_*" *this* Service, within ALL of our tests that are a part of THIS
`describe()` - block!.

NOTE: Just as a side note for future reference. If you need to retrieve
*"request-scoped"* or *"transient-scoped"* - Providers. Use the `*".resolve()"*`
method here instead of `"get()"`.

The next big area in our "test - file" is the `*"it()"*` - function.

//{{{  coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
    ...
    ...
    it("should be defined", () => {
        expect(service).toBeDefined();
    });
    ...
    ...
----
//}}}

An `"it()"` - function represents an *"individual - test"*.

In this automatically generated test. There isn't much going on.  The test is
currently just checking whether the `"service"` - variable is defined or not. If
the `service` is *not* defined, the test fails.

All right. So let's run this particular "test file", and see if our *1* (one)
- test passes or fails.

Let's open up the terminal and run the following command:

//{{{ $ npm run test:watch -- coffees.service
[source, shell]
----
$ npm run test:watch -- coffees.service
----
//}}}

The `"test:watch"` - script will run our "unit - tests" in "watch" mode,
automatically re-running test on *any file change*.

We're passing in "coffees.service" here for example sake, just to indicate that
we want to *-only-* run test for *this* specific file. Typically we won't need
to do this.

After running the script in our terminal, it looks like the "TestingModule"
couldn't bootstrap properly.

//{{{ $ npm run test:watch -- coffees.service
[source, shell]
----
$ npm run test:watch -- coffees.service
 FAIL  src/coffees/coffees.service.spec.ts
  CoffeesService
    ✕ should be defined (16 ms)

  ● CoffeesService › should be defined

    Nest can't resolve dependencies of the CoffeesService (?, FlavorRepository, Connection, ConfigService, CONFIGURATION(coffees)).
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Please make sure that the argument CoffeeRepository at index [0] is available in the RootTestModule context.

    Potential solutions:
    - If CoffeeRepository is a provider, is it part of the current RootTestModule?
    - If CoffeeRepository is exported from a separate @Module, is that module imported within RootTestModule?
      @Module({
        imports: [ /* the Module containing CoffeeRepository */ ]
      })
      ...
      ...

  ● CoffeesService › should be defined

    expect(received).toBeDefined()

    Received: undefined

      14 |
      15 |     it("should be defined", () => {
    > 16 |         expect(service).toBeDefined();
         |                         ^
      17 |     });
      18 | });
      19 |

      at Object.<anonymous> (coffees/coffees.service.spec.ts:16:25)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        2.468 s, estimated 8 s
Ran all test suites matching /coffees.service/i.

Active Filters: filename /coffees.service/
 › Press c to clear filters.

Watch Usage
 › Press a to run all tests.
 › Press f to quit "only failed tests" mode.
 › Press o to only run tests related to changed files.
 › Press p to filter by a filename regex pattern.
 › Press t to filter by a test name regex pattern.
 › Press q to quit watch mode.
 › Press Enter to trigger a test run.
----
//}}}

After running the script in our terminal, it looks like the "TestingModule"
couldn't bootstrap properly and it's throwing some Errors, but what happened?

Since the "CoffeesService" - class depends on many other database related
providers like "Connection" or "Entity - Repositories" that are *NOT* registered
in the "TestingModule". Nest throw the "Nest can't resolve dependencies error of
..".

So how can we fix this?

Let's had back to our testing - file and look at the "Modules - Metadata".

//{{{  coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
import { Test, TestingModule } from "@nestjs/testing";
import { CoffeesService } from "./coffees.service";

describe("CoffeesService", () => {
    let service: CoffeesService;

    beforeEach(async () => {
        const module: TestingModule = await Test.createTestingModule({
            providers: [CoffeesService],
                    // ~~~~~~~~~~~~~~~~
        }).compile();

        service = module.get<CoffeesService>(CoffeesService);
    });

    it("should be defined", () => {
        expect(service).toBeDefined();
    });
});
----
//}}}

Our "TestingModule" consist of only *1* - Provider which is "CoffeesService".
In theory, to fix the error we *could* just add the required providers here into
`"providers:[]"` Array. However this would  "*against best practice*" and the
general philosophy behind the "unit - test!".

"Unit - test" should be performed in *"-isolation-"* but that doesn't
necessarily mean *"complete isolation"*. By *isolation* we mean that a test
shouldn't rely on *"external - dependencies"*.

One philosophy for "unit - testing" is, to *Mock everything in situations like
this*. But that often lead to "*fragile* - test" that are hard to maintain, and
don't bring any significant value.

Our "CoffeesService" depends on "database" related providers, but the last thing
we want to do is, to instantiate a Connection to a "*real - database*", just to
perform "unit - tests".

So what other options do we have?

Without needing to create *complicated* Mocks or connecting to a real database.
All we really need to do is make sure that all "requested - providers" are
available to the "TestingModule".

As a *"temporary solution"*. Let's provide all the "classes" our "CoffeesService"
depends on, using the "custom providers" - *syntax*.

//{{{  coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
import { Test, TestingModule } from "@nestjs/testing";
import { CoffeesService } from "./coffees.service";

describe("CoffeesService", () => {
    let service: CoffeesService;

    beforeEach(async () => {
        const module: TestingModule = await Test.createTestingModule({
            providers: [
                CoffeesService,
                { provide: Connection, useValue: {} },                  // <<<
                { provide: getRepositoryToken(Coffee), useValue: {} },  // <<<
                { provide: getRepositoryToken(Flavor), useValue: {} },  // <<<
            ],
        }).compile();

        service = module.get<CoffeesService>(CoffeesService);
    });

    it("should be defined", () => {
        expect(service).toBeDefined();
    });
});
----
//}}}

We need to provide "`Connection`", and our two Entities using the
`*"getRepositoryToken()"*` - function, making sure to import it from
`@nestjs/typeorm` - package.

`*"getRepositoryToken()"*` accepts an Entity. In our case `"Flavor"` and
`"Coffee"` as an argument, and returns an `*"InjectionToken"*`.

For now, let's just give all of these Providers and *"empty - Object"* `"{}"`
for value.

Once we start testing - *"specific - methods"*. We will replace these "empty
- Objects" with *"Mocks"*.

Now, we get back to our "CoffeesService" - file, and make some *temporary*
- changes to PASS the "suites - test"

//{{{  coffees.service.ts
[source, typescript]
----
// coffees.service.ts
...
...

@Injectable({ scope: Scope.DEFAULT })
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,
        private readonly connection: Connection,
        // XXX NOTE: unused variable make Jest - 'suite - test' fail XXX
        // private readonly configService: ConfigService,
        // @Inject(coffeesConfig.KEY)
        // private readonly coffeesConfiguration: ConfigType<typeof coffeesConfig>,
    ) {
        console.log("[!!] CoffeesService - instantiated");
    }
}
----
//}}}

We put some comment into `"ConfigService"` and `"coffeesConfiguration"` since
these two variable is unused or never called by the "CoffeesService"
- "signature - methods", for testing purpose.

Let's save everything, and open up the terminal again to see if these changes
worked.

//{{{ $ npm run test:watch -- coffees.service
[source, shell]
----
$ npm run test:watch -- coffees.service
 PASS  src/coffees/coffees.service.spec.ts
  CoffeesService
    ✓ should be defined (43 ms)

  console.log
    [!!] CoffeesService - instantiated

      at new CoffeesService (coffees/coffees.service.ts:28:17)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        2.488 s
Ran all test suites matching /coffees.service/i.

Watch Usage: Press w to show more.
----
//}}}

As we can see, the "TestingModule" was properly bootstrapped now and our basic
generated test doesn't fail anymore.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 3 == Adding Unit Tests
[[_adding_unit_tests]]
== Adding Unit Tests
:fn-stub: footnote:[piece, snippet]

There are many different strategies on how we can structure our "test - suites".
When testing "services" or similar Classes that contain business logic. We
prefer *"grouping"* the related tests by *"methods"*. Using *"method names"* as
our `"describes()"`- blocks.

In this lesson, let's figure out how we can test the `findOne()` - method.

//{{{  coffees.service.ts
[source, typescript]
----
// coffees.service.ts
...
...

@Injectable({ scope: Scope.DEFAULT })
export class CoffeesService {
    constructor(
        ...
        ...
    ) {
        console.log("[!!] CoffeesService - instantiated");
    }
    ...
    ...
    async findOne(id: string) {
        // throw "A Random Error";
        const coffee = await this.coffeeRepository.findOne(id, {
            //                    ~~~~~~~~~~~~~~~~~~~~~~~~
            relations: ["flavors"],
        });

        if (!coffee) {
            throw new NotFoundException(`Coffee with 'id: #${id}' not found`);
        }

        return coffee;
    }
    ...
    ...
}
----
//}}}

One problem we'll notice is, that the `findOne()` - method use
`"CoffeeRepository.findOne()` inside of the it. We'll have to make sure to
*"mock"* this "Repository - method" for our tests to run properly!.

Looking at the code above. It seems depending on whether a Coffee *"exists"*.
There are *two* different scenarios we must cover with a "unit - test".

Let's head back to the `.spec.ts` - file and start by defining a new
`"describe()"` - block.

//{{{  coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
import { Test, TestingModule } from "@nestjs/testing";
import { CoffeesService } from "./coffees.service";

describe("CoffeesService", () => {
    let service: CoffeesService;

    beforeEach(async () => {
        const module: TestingModule = await Test.createTestingModule({
            ....
            ....
        }).compile();

        service = module.get<CoffeesService>(CoffeesService);
    });

    it("should be defined", () => {
        expect(service).toBeDefined();
    });

    describe("findOne", () => {
        describe("when Coffee with ID exists", () => {
            it("should return the Coffee - Object", async () => {
                // ...
                // ...
            });
        });

        describe("otherwise", () => {
            it("should throw 'NotFoundException'", async () => {
                //...
                //...
            });
        });
    });

});
----
//}}}

Inside this block. Let's first define the *"success"* - path. This part is
pretty self-explanatory, but we want to name our `describe()` and `it()`
- functions with *actions*.

As you can see we have `describe: "when coffee with ID exists"`, and `it:"should
return the Coffee - Object"`.  These are very descriptive, easy to read, and it
gets right to the point of what exactly this test is covering.

All of these names get output into the terminal when our tests run. So it's
always helpful to make these names and descriptions very specific.

But back to our test at hand, in our `findOne()` - method. When a "coffee" with
a specific "ID" exists we want to test if the method return the "Coffee
- Object", or in our case the "Coffee - Entity".

Let's leave the implementation blank for now.

Next let's define a test for the *"failure"* path here.  We're describing a test
for when a "Coffee *doesn't* exist". Explaining in `"it()"` - function, that we
    expect to `findOne()` - method to throw an Exception.

All right, with this in place, we can now start writing the test logic itself.

Inside our *"success"* - path test. Let's add the following code.

//{{{  coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
import { Test, TestingModule } from "@nestjs/testing";
import { CoffeesService } from "./coffees.service";

describe("CoffeesService", () => {
    ...
    ...

    describe("findOne", () => {
        describe("when Coffee with ID exists", () => {
            it("should return the Coffee - Object", async () => {
                const coffeeId = "1";
                const expectedCoffee = {};

                const coffee = await service.findOne(coffeeId);
                expect(coffee).toEqual(expectedCoffee);
            });
        });

        describe("otherwise", () => {
            it("should throw 'NotFoundException'", async () => {
                //...
                //...
            });
        });
    });

});
----
//}}}

In this test, we're hard-coding a random `"id"`, and calling to `findOne()`
- method of our "CoffeesService" with this `"id"` passed in as an *argument*.

The important part here is, the actual test itself, which is that we
`*expect(coffee).toEqual(expectedCoffee)*`.  There are many many different ways
to assert these tests. After you declare your `expect()`, pusth dot `" . "`, and
check your intellisence, to see all of the other great options for test
assertions.

All right. So let's save our change so far, open up our terminal, and see what
"Jest" shows us now.

//{{{ $ npm run test:watch -- coffees.service
[source, shell]
----
$ npm run test:watch -- coffees.service
 FAIL  src/coffees/coffees.service.spec.ts (6.495 s)
  CoffeesService
    ✓ should be defined (43 ms)
    findOne
      when Coffee with ID exists
        ✕ should return the Coffee - Object (14 ms)
      otherwise
        ✓ should throw 'NotFoundException' (5 ms)

  ● CoffeesService › findOne › when Coffee with ID exists › should return the Coffee - Object

    TypeError: this.coffeeRepository.findOne is not a function

      40 |         // throw "A Random Error";
    > 41 |         const coffee = await this.coffeeRepository.findOne(id, {
         |                                                    ^
      42 |             relations: ["flavors"],
      43 |         });
      44 |

      at CoffeesService.findOne (coffees/coffees.service.ts:41:52)
      at Object.<anonymous> (coffees/coffees.service.spec.ts:35:46)

  console.log
    [!!] CoffeesService - instantiated

      at new CoffeesService (coffees/coffees.service.ts:24:17)

  console.log
    [!!] CoffeesService - instantiated

      at new CoffeesService (coffees/coffees.service.ts:24:17)

  console.log
    [!!] CoffeesService - instantiated

      at new CoffeesService (coffees/coffees.service.ts:24:17)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 2 passed, 3 total
Snapshots:   0 total
Time:        6.942 s
Ran all test suites matching /coffees.service/i.
----
//}}}

It's look like we're getting the Type - error:
`"this.coffeeRepository.findOne()` is not a function" Error.

In the previous lesson we used empty JavaScript - Object `"{}"` as our "Entity
- Repositories".

//{{{ coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
...
...
    { provide: Connection, useValue: {} },
    { provide: getRepositoryToken(Coffee), useValue: {} },
    { provide: getRepositoryToken(Flavor), useValue: {} },
...
...
----
//}}}

Obviously these JavaScript - Objects don't have any methods defined, so it makes
sense were seeing

So how can we fix it?

There are many different ways of how we can *"Mock - Repositories"* or any other
Classes we need to Mock.  For example, we could use the `"Object.create()"`
- function and pass in the Repositories - "class prototype" to initialize the"
Repository - Object" without any dependencies.

But in the long run, this isn't the best idea.

In this case "TypeORM"  plans to remove the "Repository - Class" entirely at
some point in the future. They might use "literal - objects" instead one day.

Although that is specific to this situation. It shows that we need to be careful
with" 3rd-party libraries" and potential changes they make, and how those changes
can even impact our tests!.

Another way would be, to create a *"generic function"* that simply returns
a "Mocked - Object `"{}"` " with all of the same methods that repository class
provided.

And then "stub{fn-stub}" on these methods to manipulate their behavior based on
certain conditions.  It could potentially look something like above code.

NOTE: this "generic - function" in Mock just for illustration purposes. There
are many other methods that we didn't cover here in this Mock.


//{{{ coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
import { Connection, Repository } from "typeorm";
...

type MockRepository<T = any> = Partial<Record<keyof Repository<T>, jest.Mock>>;
const createMockRepository = <T = any>(): MockRepository<T> => ({
    findOne: jest.fn(),
    create: jest.fn(),
})

describe("CoffeesService", () => {
    ...
    ...
})
----
//}}}

So let's analyze this code real quick.

First, we have a new `"MockRepository"` - Type, which represents on object that
consist of some of the properties that the Repository - Type" contains as well.

However all of these "values" are of Type `*"jest.Mock"*` which is a "mock
- function" provided by "Jest".

Then we have a `"createMockRepository()"`- *generic function* that returns newly
defined `"MockRepository"` - Class. When the Type argument is *not* provided it
falls back to `"any"`.

NOTE: Just keep in mind, that we're not implementing every method for
Repository. We could obviously add more here if we needed them for out tests.

//{{{ coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
import { Connection, Repository } from "typeorm";
...
...

describe("CoffeesService", () => {
    let service: CoffeesService;
    let coffeeRepository: MockRepository;   // [2] <<<

    beforeEach(async () => {
        const module: TestingModule = await Test.createTestingModule({
            providers: [
                CoffeesService,
                { provide: Connection, useValue: {} },
                { provide: getRepositoryToken(Coffee), useValue: createMockRepository() },  // [1] <<<
                { provide: getRepositoryToken(Flavor), useValue: createMockRepository() },  // [1] <<<
            ],
        }).compile();

        service = module.get<CoffeesService>(CoffeesService);
        CoffeeRepository = module.get<MockRepository>(getRepositoryToken(Coffee));  // [2] <<<
    });
    ...
    ...
})
----
//}}}

All right, with our Mock function created. Let's replace those previously used
"empty - Objects" with this `"createMockRepository()"` function call.

Great, now for the second step, we need to make the `"coffeeRepository"`
- variable available in our test functions.

To do this, let's define a new variable under where we have `"service:
CoffeesService", and name it `*"CoffeeRepository: MockRepository"*`.

Now in our `"beforeEach()"` - hook, let's retrieve the "value" and set it to
`"MockRepository"` variable.

Now, we can move onto our test again and Mock the `findOne()`- method.

//{{{  coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
import { Test, TestingModule } from "@nestjs/testing";
import { CoffeesService } from "./coffees.service";
...
...

describe("CoffeesService", () => {
    ...
    ...

    describe("findOne", () => {
        describe("when Coffee with ID exists", () => {
            it("should return the Coffee - Object", async () => {
                const coffeeId = "1";
                const expectedCoffee = {};

                coffeeRepository.findOne.mockReturnValue(expectedCoffee);   // <<<
                const coffee = await service.findOne(coffeeId);
                expect(coffee).toEqual(expectedCoffee);
            });
        });

        describe("otherwise", () => {
            it("should throw 'NotFoundException'", async () => {
                //...
                //...
            });
        });
    });

});
----
//}}}

If you type `"coffeeRepository.findOne()"` and type dot `(.)` after, you'll see
various method available to us now, thanks to "Jest!".

Since we simply want to mock that this `findOne()` - method return back our
expected value variable.  Let's just use: `*"mockReturnValue()"*` - method and
return `*"expectedCoffee"*`.

Let's save our changes and open up terminal again.

//{{{ $ npm run test:watch -- coffees.service
[source, shell]
----
$ npm run test:watch -- coffees.service
 PASS  src/coffees/coffees.service.spec.ts (6.459 s)
  CoffeesService
    ✓ should be defined (42 ms)
    findOne
      when Coffee with ID exists
        ✓ should return the Coffee - Object (6 ms)
      otherwise
        ✓ should throw 'NotFoundException' (4 ms)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        6.884 s
Ran all test suites matching /coffees.service/i.

Watch Usage: Press w to show more.
----
//}}}

As we can see our test succeeds now!. Great!.

Lastly, we need to finish the test logic for the *"failure"* path.

Let's head over to our "text - editor" again and add the logic in the `"it()"`
- block.

//{{{  coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
import { Test, TestingModule } from "@nestjs/testing";
import { CoffeesService } from "./coffees.service";
...
...

describe("CoffeesService", () => {
    ...
    ...

    describe("findOne", () => {
        describe("when Coffee with ID exists", () => {
	...
	...
        });

        describe("otherwise", () => {
            it("should throw 'NotFoundException'", async () => {
                const coffeeId = "1";
                coffeeRepository.findOne.mockReturnValue(undefined);

                try {
                    await service.findOne(coffeeId);
                } catch (err) {
                    expect(err).toBeInstanceOf(NotFoundException);
                    expect(err.message).toEqual(`Coffee with 'id: #${coffeeId}' not found`);
                }
            });
        });
    });

});
----
//}}}

In this code, we can see that we're also using `"mockReturnValue()"`, but
passing in `"undefined"` this time.

This mimics is a Response that our Entity does *not* exist in the database.  If
everything works as it should here, the `"service"` should throw
a `"NotFoundException"` with expected error message which is `*"Coffee with 'id:
#${coffeeId}' not found"*`.

We're wrapping all the code here in "try-catch" - block, just to make sure we
capture any exceptions that that will obviously occur here, since we Mocked the
`"findOne()"` return value to be `"undefined"`.

Let's once again save our changes, open up the terminal again, and see if
everything works properly.

//{{{ $ npm run test:watch -- coffees.service
[source, shell]
----
$ npm run test:watch -- coffees.service
 PASS  src/coffees/coffees.service.spec.ts (6.459 s)
  CoffeesService
    ✓ should be defined (42 ms)
    findOne
      when Coffee with ID exists
        ✓ should return the Coffee - Object (6 ms)
      otherwise
        ✓ should throw 'NotFoundException' (4 ms)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        6.884 s
Ran all test suites matching /coffees.service/i.

Watch Usage: Press w to show more.
----
//}}}

Perfect!. As we can see all of our tests passed!.

We could see how nicely structured "Jest" outputs everything is well.

All of our `describe()"` - blocks, "*nested* - `describe()` " - blocks, and
`"it()"` - functions are all nicely indented here with their *descriptions* all
output for us, and extremely easy to read!.

Although we just scratched the surface of "unit - testing" in general, the
principles and concepts we learned here, can be applied to almost any situation
you may run into, while applying "unit - tests" to your NestJS - applications.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 4 == Diving into E2E Test
[[_diving_into_e2e_test]]
== Diving into E2E Test

"End-to-end - testing" covers the interaction of *Classes* and *Modules* at
a more aggregate level. Closer to the kind of the interaction that our end-user
will have with the production team.

In previous lessons, we learned how to manage "unit - tests" in our previous
lesson.  Now let's shift our focus to how we can create and structure
"end-to-end - testing" for our system.

Let's start by opening up the existing app. `"e2e-spec.ts"` - file located in
`/test/` - directory, to better understand how we can create our own
"end-to-end - testing" in the future.

//{{{  e2e-spec.ts
[source, typescript]
----
// e2e-spec.ts
import { Test, TestingModule } from "@nestjs/testing";
import { INestApplication } from "@nestjs/common";
import * as request from "supertest";
import { AppModule } from "./../src/app.module";

describe("AppController (e2e)", () => {
    let app: INestApplication;

    beforeEach(async () => {
        const moduleFixture: TestingModule = await Test.createTestingModule({
            imports: [AppModule],
        }).compile();

        app = moduleFixture.createNestApplication();
        await app.init();
    });

    it("/ (GET)", () => {
        return request(app.getHttpServer()).get("/").expect(200).expect("Hello World!");
    });
});
----
//}}}

As we can see, "end-to-end" configuration here looks very similar to what we saw
in our "unit - test suites". However there are a few key differences that we
should pay attention to here.

We're using the `*".compile()"*` - method again, we used in our "unit - tests",
but for "end-to-end - tests" we need to use the `*"createNestApplication()"*`
- method to instantiate an actual Nest - "runtime environment".

Instead of saving a reference to a `"service"` like we did in our "unit -tests".
Here in "end-to-end - test"`. We're saving a *reference* to the *"running
application"* in the `"app"` - variable, so we can use it to simulate "HTTP
- Requests".

Lastly, we need to manually called the `*"app.int()"*` - method to initialize
our application, which will *mount* all of our "Routes", *trigger* "lifecycle
- hooks", etc..

So that's it for the initial setup!. Let's look at how an "end-to-end
- testing" is actually structured.

If we look at `*"it()"*` - block here, we can see that we're simulating an `HTTP
- Request" with help from the library `*"supertest"*`, and calling the
`*"request()"*` - function provided by it.

`"supertest"` is an "npm" - package that provides a *high-level abstraction*,
for *testing* "HTTP - applications". We need these "HTTP - Request" to *route*
    to our running Nest application.

This is why the `request()` - method needs to be passed a reference to the HTTP
a *listener*, our "Nest - app" is running on - which maybe ExpressJS or Fastify
- depending on how we set up our app. This is what `*"app.getHttpServer()"*` is
  trying to do.

The call to `request()` now hands us a wrapped "HTTP - server", connected to our
Nest application!.  We now have the ability to "*chain* methods" here to
simulate an actual "HTTP - Request".

In the example shown here, we're using `"request.get()"` with the string `" / "`
inside of it.  This will initiate a Request to our Nest app that is identical to
an *actual* "HTTP - Request" coming in over the network.

Since we still have that demo "AppController" on the root-level of our
application, which in turn replies with the "Hello world!" message. This test
should succeed!.

To test it real quick. Let's open up our terminal and enter in:

//{{{ $ npm run test:e2e
[source, shell]
----
$ npm run test:e2e
FAIL  test/app.e2e-spec.ts
  AppController (e2e)
    ✕ / (GET) (435 ms)

  ● AppController (e2e) › / (GET)

    expected 200 "OK", got 403 "Forbidden"

      17 |
      18 |     it("/ (GET)", () => {
    > 19 |         return request(app.getHttpServer()).get("/").expect(200).expect("Hello World!");
         |                                                      ^
      20 |     });
      21 | });
      22 |

      at Object.<anonymous> (app.e2e-spec.ts:19:54)
      ----
      at Test.Object.<anonymous>.Test._assertStatus (../node_modules/supertest/lib/test.js:296:12)
      at ../node_modules/supertest/lib/test.js:80:15
      at Test.Object.<anonymous>.Test._assertFunction (../node_modules/supertest/lib/test.js:311:11)
      at Test.Object.<anonymous>.Test.assert (../node_modules/supertest/lib/test.js:201:21)
      at Server.localAssert (../node_modules/supertest/lib/test.js:159:12)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        3.132 s, estimated 9 s
Ran all test suites.
  console.log
    [!!] Hi from Middleware!

      at LoggingMiddleware.use (../src/common/middleware/logging.middleware.ts:7:17)

  console.time
    [!!] Request-response time: 6 ms

      at ServerResponse.<anonymous> (../src/common/middleware/logging.middleware.ts:9:40)

Jest did not exit one second after the test run has completed.

This usually means that there are asynchronous operations that weren't stopped in your tests.
Consider running Jest with `--detectOpenHandles` to troubleshoot this issue.

----
//}}}

As we can see the test is actually failing, and the error messages "*expected
200 'OK', got 403 'Forbidden'*".  This is caused by our "APIKeyGuard" - mounted
globally that we created in a previous lesson, on "Other building blocks by
example".

NOTE: Just to remind ourselves the "APIKeyGuard" requires us to pass
a hard-coded `"API_KEY"` within a *"header"*.

Since the "root - Route" we're trying to hit here is *not* decorated with the
`"@Public()"` - decorators we've previously setup. We *NEED* to pass this
"header" in the "request", for the test to pass.

We can fix this real quick by opening up the text-editor again and *chaining* a
`".set()"` - method to our "HTTP - Request"

//{{{  e2e-spec.ts
[source, typescript]
----
// e2e-spec.ts
import { Test, TestingModule } from "@nestjs/testing";
import { INestApplication } from "@nestjs/common";
import * as request from "supertest";
import { AppModule } from "./../src/app.module";

describe("AppController (e2e)", () => {
    let app: INestApplication;

    beforeEach(async () => {
        const moduleFixture: TestingModule = await Test.createTestingModule({
            imports: [AppModule],
        }).compile();

        app = moduleFixture.createNestApplication();
        await app.init();
    });

    it("/ (GET)", () => {
        return request(app.getHttpServer())
        .get("/")
        .set("Authorization:, process.env.API_KEY)
    //  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        .expect(200)
        .expect("Hello World!");
    });
});
----
//}}}

This `".set()"` - method lets us *set* any "headers" we might need.

Though here, we're just going to pass in that `"Authorization"` and *"key"* we
previously set in our `".env"` - file.

Let's save our changes, open up the terminal, and see what "Jest" gives us now.

//{{{ $ npm run test:e2e
[source, shell]
----
 PASS  src/coffees/coffees.service.spec.ts (7.303 s)
  CoffeesService
    ✓ should be defined (17 ms)
    findOne
      when Coffee with ID exists
        ✓ should return the Coffee - Object (5 ms)
      otherwise
        ✓ should throw 'NotFoundException' (5 ms)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        7.647 s
Ran all test suites matching /coffees.service/i.

Watch Usage: Press w to show more.
[daun@arch-daun iluvcoffe]$ npm run test:e2e

> iluvcoffe@0.0.1 test:e2e
> jest --config ./test/jest-e2e.json

  console.log
    [!] DatabaseModule - instantiated

      at Function.register (../src/database/database.module.ts:30:17)

  console.log
    [!!] CoffeesModule - instantiated

      at new CoffeesModule (../src/coffees/coffees.module.ts:20:17)
          at async Promise.all (index 0)

 PASS  test/app.e2e-spec.ts
  AppController (e2e)
    ✓ / (GET) (465 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        3.216 s, estimated 11 s
Ran all test suites.
  console.log
    [!!] Hi from Middleware!

      at LoggingMiddleware.use (../src/common/middleware/logging.middleware.ts:7:17)

  console.time
    [!!] Request-response time: 6 ms

      at ServerResponse.<anonymous> (../src/common/middleware/logging.middleware.ts:9:40)

Jest did not exit one second after the test run has completed.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This usually means that there are asynchronous operations that weren't stopped in your tests.
 Consider running Jest with `--detectOpenHandles` to troubleshoot this issue.
----
//}}}

Perfect. It seems that our "end-to-end - test" succeeded now!.

However, we can also see that we got a *"-warning-"* - *"Jest did not exit one
second after the test run has completed"*.

This warning means, that there are some "*asynchronous* - operations" that
*weren't* terminated in our tests. In this particular case, it's an "*open
database connection*".

Back to our text-editor again. Let's add the `"afterAll()` - hook below all of
our tests.

//{{{  e2e-spec.ts
[source, typescript]
----
// e2e-spec.ts
...
...

describe("AppController (e2e)", () => {
    let app: INestApplication;

    beforeEach(async () => {
        const moduleFixture: TestingModule = await Test.createTestingModule({
            imports: [AppModule],
        }).compile();
        ...
        ...
    });

    it("/ (GET)", () => {
        ...
        ...
    });

    afterAll(async () => {  // <<<
        await app.close();
    });
});
----
//}}}

This `"afterAll()"` - hook will be called by the "Jest" - framework after ALL
tests are *completed*.

Here we called `"app.close()"` which lets Nest know that it should trigger the
`"OnModuleDestroy"` and `"OnApplicationShutdowm"` - "lifecycle hooks" which will
terminate "*all* - connections" in our application.

For the sake of consistency. Let's also change our `"beforeEach()"` - here, to
`"beforeAll()"`.

//{{{  e2e-spec.ts
[source, typescript]
----
// e2e-spec.ts
...
...

describe("AppController (e2e)", () => {
    let app: INestApplication;

    beforeAll(async () => {     // <<<
        const moduleFixture: TestingModule = await Test.createTestingModule({
            imports: [AppModule],
        }).compile();
        ...
        ...
    });

    it("/ (GET)", () => {
        ...
        ...
    });

    afterAll(async () => {
        await app.close();
    });
});
----
//}}}

Since typically we don't want to recreate the application for each "end-to-end
- test".

Just to make sure that everything's working as expected. Let's open up the
terminal again and run:

//{{{ $ npm run test:e2e
[source, shell]
----
 PASS  src/coffees/coffees.service.spec.ts (7.303 s)
  CoffeesService
    ✓ should be defined (17 ms)
    findOne
      when Coffee with ID exists
        ✓ should return the Coffee - Object (5 ms)
      otherwise
        ✓ should throw 'NotFoundException' (5 ms)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        7.647 s
Ran all test suites matching /coffees.service/i.

Watch Usage: Press w to show more.
[daun@arch-daun iluvcoffe]$ npm run test:e2e

> iluvcoffe@0.0.1 test:e2e
> jest --config ./test/jest-e2e.json

  console.log
    [!] DatabaseModule - instantiated

      at Function.register (../src/database/database.module.ts:30:17)

  console.log
    [!!] CoffeesModule - instantiated

      at new CoffeesModule (../src/coffees/coffees.module.ts:20:17)
          at async Promise.all (index 0)

 PASS  test/app.e2e-spec.ts
  AppController (e2e)
    ✓ / (GET) (465 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        3.216 s, estimated 11 s
Ran all test suites.
  console.log
    [!!] Hi from Middleware!

      at LoggingMiddleware.use (../src/common/middleware/logging.middleware.ts:7:17)

  console.time
    [!!] Request-response time: 6 ms

      at ServerResponse.<anonymous> (../src/common/middleware/logging.middleware.ts:9:40)
----
//}}}

Great as we can see, everything's passed, and we have no more "errors" or
"warnings".

Although we fixed this end-to-end test and it's working properly now, it's still
far from perfect.

We importing the "AppModule" here, which means that in fact we're instantiating
the *entire applications* "-*including-*" all Controllers, Providers, Enhancers,
Configurations, "establishing Database - Connection", and so on and so forth..

"Nest - Modules" typically represent features. So ideally we should be able to
test these features in "*isolation independently*".

In the next lesson. We'll look at how we can "test Modules" in *isolation*
without worrying about other Modules that might have been imported into the
applications.

**⬆xref:_table_of_contents[back to top]**
//}}}

