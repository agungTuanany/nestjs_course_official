//{{{ ** ASCIIDOC HEADER
:description:   nestjs official course | chapter-8
:url-repo:      https://github.com/agungTuanany/nestjs_course_official
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Fri Apr  9 06:54:56 AM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
//}}}

[[_chapter_8_testing]]
= Chapter-8 Testing
:figure-caption!:
:source-highlighter: highlight.js

//{{{== Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_introducing_to_jest[Introducing to JEST]
| 2.    | xref:_getting_started_with_test_suites[Getting Started With Test Suites]
|====
//}}}

//{{{ 1 == Introducing to JEST
[[_introducing_to_jest]]
== Introducing to JEST

//{{{ image::./images/chapter-8-1.png
[#img-chapter]
[link=./images/chapter-8-1.png]
.Introducing To JEST
image::./images/chapter-8-1.png[align="center"]
//}}}

Automated testing is considered an essential part of any serious software
development effort.  Automation makes it easier to repeat "individual - tests",
or "test - suites" -quickly during development.

With NestJS we can use any testing framework we prefer. However it can be quite
tedious to set everything up. Luckily for us Nest provides a built-in
integration with the "*Jest*" - testing framework out of the box, so we don't
have to do anything to get started.

//{{{ image::./images/chapter-8-2.png
[#img-chapter]
[link=./images/chapter-8-2.png]
.Introducing To JEST -2
image::./images/chapter-8-2.png[align="center"]
//}}}

"*Jest*" is a delightful JavaScript testing framework with a focus on
simplicity.  It allows you to write test with an approachable, familiar, and
feature rich API that gives you result quickly.

"*Jest*" provides great "Error - messages" and built-in Mocking utilities, to
make testing your applications much simpler. Also it reliably *run test in
"parallel"*.

To make tests run *even faster*, "*Jest*" runs previously failed test first, and
then reorganizes test runs, based on how long "Test - file" take.

//{{{ image::./images/chapter-8-3.png
[#img-chapter]
[link=./images/chapter-8-3.png]
.Introducing To JEST -3
image::./images/chapter-8-3.png[align="center"]
//}}}

In NestJS applications, we use "*Jest*" to run "*unit* - tests" and
"*end-to-end* - tests"

There are several command you can use to run "*specific test*",

- `npm run test`, for unit tests
- `npm run test:cov`, for unit test and collecting testing coverage
- `npm run test:e2e`, for end-to-end tests

With nest. We automatically have all of this power with no additional setup
needed!.

So far in this course we haven't paid too much attention to *"testing"*.  Thus,
some of the existing, or automatically generated tests may *fail*.

In the next few lesson. We'll introduce you to the "*Jest*" framework. Show you
how to use NestJS - "testing - utilities", and fix some of the existing "test
- file" - all step by step.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 2 == Getting Started With Test Suites
[[_getting_started_with_test_suites]]
== Getting Started With Test Suites
:fn-aggregate: footnote:[total, accumulative]

//{{{ image::./images/chapter-8-4.png
[#img-chapter]
[link=./images/chapter-8-4.png]
.Getting Started With Test Suites
image::./images/chapter-8-4.png[align="center"]
//}}}

Testing by itself is quite the endless topic that could be fragmented into many
separate lessons. We can't really cover *every* aspect of testing itself. We'll
be focusing primarily on how testing works within NestJS.

We'll be focusing mainly on tips and tricks, showcasing some best practices, and
go over how you can add manage test in your "Nest - applications".

//{{{ image::./images/chapter-8-5.png
[#img-chapter]
[link=./images/chapter-8-5.png]
.Getting Started With Test Suites
image::./images/chapter-8-5.png[align="center"]
//}}}

For unit tests in NestJS, it's a common practice to keep the `*".spec.ts"*`
- files in the *same folder* as the application source code files that they
test.

Each *"Controller"*, *"Provider"*, *"Service"*, etc should have its *own*
dedicated "test - file".

The test file extension must be `*".spec.ts"*`. This is so that integrated
- "test tooling" can identify it as a "test - file" with "test - suites" or
"end-to-end - test".

//{{{ image::./images/chapter-8-6.png
[#img-chapter]
[link=./images/chapter-8-6.png]
.Getting Started With Test Suites
image::./images/chapter-8-6.png[align="center"]
//}}}

These files are typically located in a dedicated `"/test/"` - directory by
default.

"End-to-end - test" are typically grouped into separate files by the *"feature"*
or *"functionality"* that they test.

For "end-to-end - test". The file extension must be `*".e2e-spec.ts"*`.

While "unit - tests" focus on *individual classes* and *functions*. "End-to-end
- test" are great for *"high level validation"* of the *entire system*.

"End-to-end - testing" covers the interaction "End-to-end - testing" covers the
*interaction* of classes and models at more *"aggregate level{fn-aggregate}"*
closer to the kid of interaction that "end-users" will have with the "production
system".

As application grows, it becomes hard to manually test the "end-to-end
- behavior" of each "API - endpoint".

Automated "end-to-end - test" help us ensure that the "*overall* behavior" of
the system is *correct*, and it meets project requirement.

To better understand how tests look an how they work. Let's open up
"CoffeesService" - `".spec"` - file, we haven't looked at yet and walk through
everything - step by step!.

//{{{  coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
import { Test, TestingModule } from "@nestjs/testing";
import { CoffeesService } from "./coffees.service";

describe("CoffeesService", () => {
    let service: CoffeesService;

    beforeEach(async () => {
        const module: TestingModule = await Test.createTestingModule({
            providers: [CoffeesService],
        }).compile();

        service = module.get<CoffeesService>(CoffeesService);
    });

    it("should be defined", () => {
        expect(service).toBeDefined();
    });
});
----
//}}}

First, we can see that the `*"describe()"*` - function that define a *"block"*
which groups together several related tests.

In this case, the `"describe()"` - block is grouping all the "unit - test" that
concern "CoffeesService" - class.

Inside this block. We can see that `*"beforeEach()"*` - function.

This function passed into the `beforeEach()` - *hook*, will be executed *before*
EVERY test.  This is typically referred to as the *"setup phase"*.

Often while writing tests. We have some "*setup work*" that needs to happen
BEFORE *each* test runs; and sometimes you need to do something "after" EACH
test runs.

"Jest" provides several other "*helper*" - functions to handle situations like
this.

We know `beforeEach()` now, but the other available options are:
`*"beforeAll()"*`, `*"afterEach()"*`, and `*"afterAll()"*`.

So looking at this test file. Let's dive into the `beforeEach()` - function call
here, to see what it's doing.

//{{{  coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
    ...
    ...
    beforeEach(async () => {
        const module: TestingModule = await Test.createTestingModule({
            providers: [CoffeesService],
        }).compile();

        service = module.get<CoffeesService>(CoffeesService);
        // service = wait module.resolve(CoffeesService)
        //                       ~~~~~~~
    });
    ...
    ...
----
//}}}

At a very high level. We can see that we're instantiating some pf Module by
compiling a "Test - Module", and then utilizing this module to get a hold of the
"CoffeesService".

Then it looks like we're *storing* it in the `"service"` - variable, we use
within our "individual - tests" inside of *this* `describe()` - block.

Let's start by analyzing everything that's happening here.

The `*"Test"*` - Class is, useful for providing an application
*"ExecutionContext"* that essentially Mocks the full Nest *"runtime"*. But gives
you *"hooks"* that make it easy to manage "Class - instances", and do anything
like Mocking and "overriding aspects" of your application.

The `*"Test"*` - Class, has a `*"createTestingModule({})"*` - method that takes
a 'Module - Metadata" - Object as its argument the same object we pass into our
`@Module({ /* this object */ })` - decorators.

One important thing to note here is, the `*".compile()"*` - method.

This method bootstrapped the Module with its dependencies, similar to the way we
bootstrap our application in our `main.ts` - file: with
`"NestFactory.create(/*AppModule*/)"`.

The `.compile()` - method return a `"TestingModule"` - instance which in turn
gives us access to a few helpful methods!.

Once our "TestingModule" is compiled. We can retrieve *any static instance*
declared within the Module by using the `".get()"` - method we see being used
here!.

As we can see, we're calling the `get()` - method here to retrieve our
"CoffeesService" from within our compiled "TestingModule", and then *storing it*
in the `"service"` - variable defined within our `describe()` - block.

This is *standard practice* for testing, that allows us to "*_store_*" and
"*_use_*" *this* Service, within ALL of our tests that are a part of THIS
`describe()` - block!.

NOTE: Just as a side note for future reference. If you need to retrieve
*"request-scoped"* or *"transient-scoped"* - Providers. Use the `*".resolve()"*`
method here instead of `"get()"`.

The next big area in our "test - file" is the `*"it()"*` - function.

//{{{  coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
    ...
    ...
    it("should be defined", () => {
        expect(service).toBeDefined();
    });
    ...
    ...
----
//}}}

An `"it()"` - function represents an *"individual - test"*.

In this automatically generated test. There isn't much going on.  The test is
currently just checking whether the `"service"` - variable is defined or not. If
the `service` is *not* defined, the test fails.

All right. So let's run this particular "test file", and see if our *1* (one)
- test passes or fails.

Let's open up the terminal and run the following command:

//{{{ $ npm run test:watch -- coffees.service
[source, shell]
----
$ npm run test:watch -- coffees.service
----
//}}}

The `"test:watch"` - script will run our "unit - tests" in "watch" mode,
automatically re-running test on *any file change*.

We're passing in "coffees.service" here for example sake, just to indicate that
we want to *-only-* run test for *this* specific file. Typically we won't need
to do this.

After running the script in our terminal, it looks like the "TestingModule"
couldn't bootstrap properly.

//{{{ $ npm run test:watch -- coffees.service
[source, shell]
----
$ npm run test:watch -- coffees.service
 FAIL  src/coffees/coffees.service.spec.ts
  CoffeesService
    ✕ should be defined (16 ms)

  ● CoffeesService › should be defined

    Nest can't resolve dependencies of the CoffeesService (?, FlavorRepository, Connection, ConfigService, CONFIGURATION(coffees)).
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Please make sure that the argument CoffeeRepository at index [0] is available in the RootTestModule context.

    Potential solutions:
    - If CoffeeRepository is a provider, is it part of the current RootTestModule?
    - If CoffeeRepository is exported from a separate @Module, is that module imported within RootTestModule?
      @Module({
        imports: [ /* the Module containing CoffeeRepository */ ]
      })
      ...
      ...

  ● CoffeesService › should be defined

    expect(received).toBeDefined()

    Received: undefined

      14 |
      15 |     it("should be defined", () => {
    > 16 |         expect(service).toBeDefined();
         |                         ^
      17 |     });
      18 | });
      19 |

      at Object.<anonymous> (coffees/coffees.service.spec.ts:16:25)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        2.468 s, estimated 8 s
Ran all test suites matching /coffees.service/i.

Active Filters: filename /coffees.service/
 › Press c to clear filters.

Watch Usage
 › Press a to run all tests.
 › Press f to quit "only failed tests" mode.
 › Press o to only run tests related to changed files.
 › Press p to filter by a filename regex pattern.
 › Press t to filter by a test name regex pattern.
 › Press q to quit watch mode.
 › Press Enter to trigger a test run.
----
//}}}

After running the script in our terminal, it looks like the "TestingModule"
couldn't bootstrap properly and it's throwing some Errors, but what happened?

Since the "CoffeesService" - class depends on many other database related
providers like "Connection" or "Entity - Repositories" that are *NOT* registered
in the "TestingModule". Nest throw the "Nest can't resolve dependencies error of
..".

So how can we fix this?

Let's had back to our testing - file and look at the "Modules - Metadata".

//{{{  coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
import { Test, TestingModule } from "@nestjs/testing";
import { CoffeesService } from "./coffees.service";

describe("CoffeesService", () => {
    let service: CoffeesService;

    beforeEach(async () => {
        const module: TestingModule = await Test.createTestingModule({
            providers: [CoffeesService],
                    // ~~~~~~~~~~~~~~~~
        }).compile();

        service = module.get<CoffeesService>(CoffeesService);
    });

    it("should be defined", () => {
        expect(service).toBeDefined();
    });
});
----
//}}}

Our "TestingModule" consist of only *1* - Provider which is "CoffeesService".
In theory, to fix the error we *could* just add the required providers here into
`"providers:[]"` Array. However this would  "*against best practice*" and the
general philosophy behind the "unit - test!".

"Unit - test" should be performed in *"-isolation-"* but that doesn't
necessarily mean *"complete isolation"*. By *isolation* we mean that a test
shouldn't rely on *"external - dependencies"*.

One philosophy for "unit - testing" is, to *Mock everything in situations like
this*. But that often lead to "*fragile* - test" that are hard to maintain, and
don't bring any significant value.

Our "CoffeesService" depends on "database" related providers, but the last thing
we want to do is, to instantiate a Connection to a "*real - database*", just to
perform "unit - tests".

So what other options do we have?

Without needing to create *complicated* Mocks or connecting to a real database.
All we really need to do is make sure that all "requested - providers" are
available to the "TestingModule".

As a *"temporary solution"*. Let's provide all the "classes" our "CoffeesService"
depends on, using the "custom providers" - *syntax*.

//{{{  coffees.service.spec.ts
[source, typescript]
----
// coffees.service.spec.ts
import { Test, TestingModule } from "@nestjs/testing";
import { CoffeesService } from "./coffees.service";

describe("CoffeesService", () => {
    let service: CoffeesService;

    beforeEach(async () => {
        const module: TestingModule = await Test.createTestingModule({
            providers: [
                CoffeesService,
                { provide: Connection, useValue: {} },                  // <<<
                { provide: getRepositoryToken(Coffee), useValue: {} },  // <<<
                { provide: getRepositoryToken(Flavor), useValue: {} },  // <<<
            ],
        }).compile();

        service = module.get<CoffeesService>(CoffeesService);
    });

    it("should be defined", () => {
        expect(service).toBeDefined();
    });
});
----
//}}}

We need to provide "`Connection`", and our two Entities using the
`*"getRepositoryToken()"*` - function, making sure to import it from
`@nestjs/typeorm` - package.

`*"getRepositoryToken()"*` accepts an Entity. In our case `"Flavor"` and
`"Coffee"` as an argument, and returns an `*"InjectionToken"*`

For now, let's just give all of these Providers and empty Object `"{}"` for
value.

Once we start testing - *"specific - methods"*. We will replace these "empty
- Objects" wit *"Mocks"*.

Now, we get back to our "CoffeesService" - file, and make some *temporary*
- changes PASS the "suites - test"

//{{{  coffees.service.ts
[source, typescript]
----
// coffees.service.ts
...
...

@Injectable({ scope: Scope.DEFAULT })
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,
        private readonly connection: Connection,
        // XXX NOTE: unused variable make Jest - 'suit - test' fail XXX
        // private readonly configService: ConfigService,
        // @Inject(coffeesConfig.KEY)
        // private readonly coffeesConfiguration: ConfigType<typeof coffeesConfig>,
    ) {
        console.log("[!!] CoffeesService - instantiated");
    }
}
----
//}}}

We put some comment into `"ConfigService"` and `"coffeesConfiguration"` since
these two variable is unused or never called by the "CoffeesService"
- "signature - methods", for testing purpose.

Let's save everything, and open up the terminal again to see if these changes
worked.

//{{{ $ npm run test:watch -- coffees.service
[source, shell]
----
$ npm run test:watch -- coffees.service
 PASS  src/coffees/coffees.service.spec.ts
  CoffeesService
    ✓ should be defined (43 ms)

  console.log
    [!!] CoffeesService - instantiated

      at new CoffeesService (coffees/coffees.service.ts:28:17)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        2.488 s
Ran all test suites matching /coffees.service/i.

Watch Usage: Press w to show more.
----
//}}}

**⬆xref:_table_of_contents[back to top]**
//}}}


