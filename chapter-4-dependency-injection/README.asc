//{{{ ** ASCIIDOC HEADER
:description:   nestjs official course | chapter-4
:url-repo:      https://github.com/agungTuanany/nestjs_course_official
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Mon Mar 29 11:39:39 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
//}}}

[[_chapter_4_dependency_injection]]
= Chapter-4 Dependency Injection
:figure-caption!:
:source-highlighter: highlight.js

//{{{== Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_understanding_dependency_injection[Understanding Dependency Injection]
| 2.    | xref:_control_nest_module_encapsulation[Control Nest Module Encapsulation]
| 3.    | xref:diving_into_custom_providers[Diving Into Custom Providers]
| 4.    | xref:_value_based_providers[Value Based Providers]
| 5.    | xref:_non_class_based_provider_tokens[Non Class Based Provider Tokens]
| 6.    | xref:_class_based_providers[Class Based Providers]
| 7.    | xref:_factory_based_providers[Factory Based Providers]
| 8.    | xref:_leverage_async_providers[Leverage Async Providers]
| 9.    | xref:create_a_dynamic_module[Create a Dynamic Module]
| 10.   | xref:control_providers_scope[Control Providers Scope]
| 11.   | xref:_diving_deeper_into_request_scope_providers[Diving Deeper into Request - Scope Providers]
|====
//}}}

//{{{ 1 == Understanding Dependency Injection
[[_understanding_dependency_injection]]
== Understanding Dependency Injection
:fn-transitive_dependencies: footnote:[When an indirect relationship causes functional dependency is called "Transitive - Dependencies"]
:fn-dependencies_graph: footnote:[In mathematics, computer science and digital electronics, a dependency graph is a directed graph representing dependencies of several objects towards each other. It is possible to derive an evaluation order or the absence of an evaluation order that respects the given dependencies from the dependency graph. https://en.wikipedia.org/wiki/Dependency_graph]

//{{{ image::./images/chapter-4-1.png
[#img-chapter]
[link=./images/chapter-4-1.png]
.Before we get started
image::./images/chapter-4-1.png[align="center"]
//}}}

Dependency Injection is a technique where we delegated instantiation of
dependencies, to an *"inversion of control"* (IoC) - container. In our case this
"*IoC*" - container is the NestJS runtime system itself.

//{{{ image::./images/chapter-4-2.png
[#img-chapter]
[link=./images/chapter-4-2.png]
.How Dependencies Injection works.
image::./images/chapter-4-2.png[align="center"]
//}}}

NestJS handles all the heavy lifting here, instead of trying to achieve
Dependency Injection ourselves.  Essentially when we *"ask"* for a dependency in
a *class - "constructor"*. NestJS handles and retrieves the Object - BACK to us,
along with any dependencies it might require, and so on and so on...


Let's take a look an example in our own code, and dive into how it all works.

//{{{ coffee.controller.ts
[source, typescript]
----
// coffee.controller.ts
@Controller("coffees")
export class CoffeesController {
    constructor(private readonly coffeesService: CoffeesService) {}     //<<<

    ...
    ...
}
----
//}}}

In our "CoffeeController" When we are using "CoffeesService" and injecting it
here in our `"constructor()"`; What is exactly is happening in NestJS under the
hood, to make all of this work?.

Well, there are "3" - keys steps in the Dependency Injection process - that make
it hall happen.

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
@Injectable() // <<<
export class CoffeesService {
    ...
    ...
}
----
//}}}

- *First*, in our "CoffeesService" - the `@Injectable()" decorator declares
  a "class" that can be managed by the Nest "container". This decorator marks
  the "CoffeesService" - class as a *"Provider"*.

//{{{ coffee.controller.ts
[source, typescript]
----
// coffee.controller.ts
@Controller("coffees")
export class CoffeesController {
    constructor(private readonly coffeesService: CoffeesService) {}
    //                                  ^^           ^^
    ...
    ...
}
----
//}}}

- *Second*, if we jump to our "CoffeeController". We can see we are requesting
  the "CoffeesService" in our "constructor". This (`"coffeesService:
  CoffeesService"`) request tells Nest to "inject" the *"Provide"* into our
  "controller()" - class, so that we may able to utilize it.

//{{{ coffee.module.ts
[source, typescript]
----
// coffee.module.ts
@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],       // <<<
    providers: [CoffeesService],            // <<<
})
export class CoffeesModule {}
----
//}}}

- *Lastly*, Nest is aware that this class ("CoffeeController") also
  a "Provider", because we've include here in our "CoffeesModule", which
  registers this "Provider" with Nest - "Inversion of Control" - container.

That's how it al works in our code itself. But now let's dive even deeper to see
what Nest does.

//{{{ image::./images/chapter-4-3.png
[#img-chapter]
[link=./images/chapter-4-3.png]
.Dive deep into Dependency Injection
image::./images/chapter-4-3.png[align="center"]
//}}}

When the Nest - container *instantiates* the "CoffeesController". It first looks
to see if there are-any-dependencies *"needed"*. In our case, there is one, the
"CoffeesService".

When the Nest - *container* finds the "CoffeesService" - dependencies, it performs
a *"lookup"* on the *"CoffeesService" - token*, which return the
"CoffeesService" - class.

Assuming this "Provider" has a "singleton" - scope, which is the default
behavior of "Injectable - Providers".  Nest will either *create an instance* of
"CoffeesService", *"cache it"* and *"return it"* or if one is-already - cached,
it will return *that* existing - instance.

We are simplifying everything a bit, but hopefully this all helps illustrate the
point.

Analyzing our codebase  for dependencies: is *quite the complex task*, that Nest
handles for us, and it "ALL" happens during "Application Bootstrapping".

This "dependencies - analysis" for creating the "Dependency Graph" is
*transitive*{fn-transitive_dependencies}.

In this example, if the "CoffeesService" itself has dependencies (which is does).
*Those* dependencies *_need_* to be resolved as well.

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
@Injectable() // <<<
export class CoffeesService {

    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,      // It's need to be resolved
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,      // It's need to be resolved
        private readonly connection: Connection,                    // It's need to be resolved
    ) {}
}
----
//}}}

The "Dependencies - Graph{fn-dependencies_graph}" ensures that Dependencies are
resolved in the CORRECT ORDER, or essentially that they are resolved from the
"bottom - up (^)".

This mechanism relieves the developer from having to manage such "complex
- Dependency Graph".

All right, enough theory for now!.

Let's take a closer look at the `@Module()` - decorator.

//{{{ coffee.module.ts
[source, typescript]
----
// coffee.module.ts
@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],       // <<<
    providers: [CoffeesService],            // <<<
})
export class CoffeesModule {}
----
//}}}

In our "CoffeesModule" we declared "[CoffeesService]" in our `"providers[]"`
Array.  So far we've supplied all of our "Providers" by a list of "class
- name".  But in fact!, these syntax is actually a shorthand - version of the
more complex syntax.

//{{{ coffee.module.ts
[source, typescript]
----
// coffee.module.ts
@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    providers: [                        // <<<
        {
            provide: CoffeeService,             // <<<
            useClass: CoffeeService.            // <<<
        },
    ],
})
export class CoffeesModule {}
----
//}}}

Now that we see this explicit construction. We can start to understand the
"Dependencies - Registration process".

With this complete syntax. We can see that we are clearly associating the TOKEN,
"CoffeesService" with the class "CoffeesService". The shorthand notation is
merely a convenience to simplify the most common use-case, where the TOKEN used
to "request an instance of a class", *comes by the same name".

Later on in this chapter, we'll be looking at other useful ways to provide
*"alternative values"* and other Dependency Injection *"tips"* and *"tricks"*.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 2 == Control Nest Module Encapsulation
[[_control_nest_module_encapsulation]]
== Control Nest Module Encapsulation

//{{{ image::./images/chapter-4-5.png
[#img-chapter]
[link=./images/chapter-4-5.png]
.Control Nest Module Encapsulation
image::./images/chapter-4-5.png[align="center"]
//}}}

By default, NestJS modules "encapsulate" their "Providers". This Encapsulation
makes it impossible to inject Providers that are not either *"directly* part of
the current module" or *"exported* from a module being used"

//{{{ image::./images/chapter-4-6.png
[#img-chapter]
[link=./images/chapter-4-6.png]
.Control Nest Module Encapsulation
image::./images/chapter-4-6.png[align="center"]
//}}}

You can think of "exported providers", being your modules "public - interfaces"
or API.

Let's look at an example of how this "encapsulation - works", and how we can use
it in our applications.

Let's start off by defining a brand new *"CoffeeRatingModule"*. To generate
*"new module"* with NestJS - CLI, let's enter in

//{{{ $ nest g mo coffee-rating
[source, shell]
----
$ nest g mo coffee-rating
CREATE src/coffee-rating/coffee-rating.module.ts (89 bytes)
UPDATE app.module.ts (871 bytes)
----
//}}}

We are using the Nest - CLI shorthand syntax here, instead of the more verbose
"$ nest generate module".

Now, let's create a "new - Provider" called "CoffeeRatingService" and
encapsulate it within our new "CoffeeRatingModule"

//{{{ $ nest g mo coffee-rating
[source, shell]
----
$ nest g s coffee-rating
CREATE src/coffee-rating/coffee-rating.service.spec.ts (503 bytes)
CREATE src/coffee-rating/coffee-rating.service.ts (96 bytes)
UPDATE src/coffee-rating/coffee-rating.module.ts (188 bytes)
----
//}}}

To help us understand encapsulation better. Let's say our new
"CoffeeRatingService" depends on "CoffeesService" to *fetch* Coffee's from the
database.

We know that "CoffeesService" belongs to a "*different* - module", so let's make
sure we import the "CoffeesModule" here in our "CoffeeRatingModule".

//{{{ coffee-rating.module.ts
[source, typescript]
----
// coffee-rating.module.ts
import { Module } from '@nestjs/common';
import { CoffeesModule } from "../coffees/coffees.module";
import { CoffeeRatingService } from './coffee-rating.service';

@Module({
    imports: [CoffeesModule],            // <<<
    providers: [CoffeeRatingService]
})
export class CoffeeRatingModule {}
----
//}}}

Switch over to "CoffeeRatingService", and use the "constructor based injection"
to add the "CoffeesService".

//{{{ coffee-rating.service.ts
[source, typescript]
----
// coffee-rating.service.ts
import { Injectable } from "@nestjs/common";
import { CoffeesService } from "../coffees/coffees.service";

@Injectable()
export class CoffeeRatingService {
    constructor(private readonly coffeesService: CoffeesService) {}     // <<<
}
----
//}}}

If we switch to our terminal and try to run our application with,

//{{{ npm run start:dev
[source, shell]
----
$ nest run start:dev
[Nest] 3363695   - 03/30/2021, 7:41:33 AM   [NestFactory] Starting Nest application...
[Nest] 3363695   - 03/30/2021, 7:41:33 AM   [InstanceLoader] TypeOrmModule dependencies initialized +77ms
[Nest] 3363695   - 03/30/2021, 7:41:33 AM   [ExceptionHandler] Nest can't resolve dependencies of the CoffeeRatingService (?). Please make sure that the argument CoffeesService at index [0] is available in the CoffeeRatingModule context.
...
...
----
//}}}

We will notice, that Nest won't be able to bootstrap properly and error message
will be thrown, that says:

----
"Nest can't resolve dependencies of the CoffeeRatingService (?). Please make sure that the argument CoffeesService at index [0] is available in the CoffeeRatingModule context."
----

So, what did we miss? Well, as we said a moment ago, All Modules encapsulate
their Providers by default. That means, that if you want to use them in
"another" - module, we Must explicitly define them as *"exported"*. Making them
a part of the *"Public API"* of that module.

All right. So this sounds like an easy fix!. Let's open up the "CoffeesModule"
and add on *"exports: []"* to the `@Module()` definition, making sure we put
"CoffeesService" inside of it!.

//{{{ coffees.module.ts
[source, typescript]
----
// coffees.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

import { CoffeesController } from "./coffees.controller";
import { CoffeesService } from "./coffees.service";
import { Coffee } from "./entities/coffee.entity";
import { Flavor } from "./entities/flavor.entity";
import { Event } from "../events/entities/event.entity";

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    providers: [CoffeesService],
    exports: [CoffeesService]                   // <<<
})
export class CoffeesModule {}
----
//}}}

If we save our changes, and head back to our terminal, we'll see our Nest
application was able to bootstrap successfully, and we no longer see any
errors!.

That's encapsulation in a nutsheell!.

Now we are able to use "CoffeesService" anywhere in our "CoffeeRatingModule".

//{{{ npm run start:dev
[source, shell]
----
$ nest run start:dev
[Nest] 3388048   - 03/30/2021, 7:58:52 AM   [NestFactory] Starting Nest application...
[Nest] 3388048   - 03/30/2021, 7:58:52 AM   [InstanceLoader] TypeOrmModule dependencies initialized +72ms
[Nest] 3388048   - 03/30/2021, 7:58:52 AM   [InstanceLoader] AppModule dependencies initialized +1ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [InstanceLoader] TypeOrmCoreModule dependencies initialized +126ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [InstanceLoader] TypeOrmModule dependencies initialized +1ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [InstanceLoader] CoffeesModule dependencies initialized +1ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [InstanceLoader] CoffeeRatingModule dependencies initialized +0ms   // <<<<
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [RoutesResolver] AppController {}: +11ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [RouterExplorer] Mapped {, GET} route +5ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [RoutesResolver] CoffeesController {/coffees}: +1ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [RouterExplorer] Mapped {/coffees, GET} route +1ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [RouterExplorer] Mapped {/coffees/:id, GET} route +2ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [RouterExplorer] Mapped {/coffees, POST} route +1ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [RouterExplorer] Mapped {/coffees/:id, PATCH} route +1ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [RouterExplorer] Mapped {/coffees/:id, DELETE} route +1ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [NestApplication] Nest application successfully started +5ms
----
//}}}

As we can see, this encapsulation really gives us full control over what is
*"public"* and *"privately"* available within our Modules and other Module's
that depend on them.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 3 == Diving Into Custom Providers
[[diving_into_custom_providers]]
== Diving Into Custom Providers

//{{{ image::./images/chapter-4-7.png
[#img-chapter]
[link=./images/chapter-4-7.png]
.Diving Into Custom Providers
image::./images/chapter-4-7.png[align="center"]
//}}}

What happens when our application's requirements go above and beyond what we've
seen available with injecting and creating "Providers" so far.

Let's take a look at some example use cases where we might need something a bit
more sophisticated.

. Let's say we create a custom instance of our "Provider" instead of
having Nest Instantiate that class for us.

. Or let's say we want to *"reuse an existing class"* in a second
dependency.

. How about if we want to overwrite a class with a mock version of
testing.

. Lastly, what if we want to use a *"Strategy Pattern"* in which we can provide
an "abstract - class" and interchange the real implementation (or actual class
that is to be used) based on different conditions.

Well, luckily Nest allows us to define "Custom - Providers" to handle use case
such as above, and many others.

//{{{ image::./images/gif/chapter-4-1.gif
[#img-chapter]
[link=./images/gif/chapter-4-1.gif]
.Diving Into Custom Providers
image::./images/gif/chapter-4-1.gif[align="center"]
//}}}

We saw in a previous lesson, that when we add "Providers" to "Nest - Modules"
- `"providers: []"` Array. It's really just a shorthand of providing the TOKEN
and providing "what is to be injected" in that TOKEN"s place.

Nest provides several ways of defining these "Custom - Providers". So let's walk
through a few of them, so we gain a deeper understanding of how we can utilize
each one - in our own applications!.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 4 == Value Based Providers
[[_value_based_providers]]
== Value Based Providers

The first "Custom  - Provider" we'll look at is, their `"useValue"` - syntax.
The `"useValue"` - syntax is useful for Injecting a "*constant - value*".

Let's say we wanted to *"add an external library"* into the Nest - container, or
maybe we are "*replacing"* a real implementation of a Service with `"*Mock{}"*`
- Object.  You can imagine for *"testing - purpose"*. This would be ideal.

Using our application as an example, let's say we would like to force Nest to
use a `*"MockCoffeesService"*` for illustration purposes. Let's add our "Mock
- Service" - implementation here that we'll use in this demo.

//{{{  coffee.module.ts
[source, typescript]
----
// coffee.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

import { CoffeesController } from "./coffees.controller";
import { CoffeesService } from "./coffees.service";
import { Coffee } from "./entities/coffee.entity";
import { Flavor } from "./entities/flavor.entity";
import { Event } from "../events/entities/event.entity";

class MockCoffeesService {}

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    providers: [{ provide: CoffeesService, useValue: new MockCoffeesService() }],
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

Now, let's replace our "CoffeesService" in the `*"providers:[]"*` Array to our
"Custom - Provider"  and use the `"useValue:"` - syntax.

With what we just did. Now whenever the "CoffeesService" TOKEN is "resolved", it
will point to the new "MockCoffeesService", *any time* we inject "CoffeesService"
in our application!.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 5 == Non Class Based Provider Tokens
[[_non_class_based_provider_tokens]]
== Non Class Based Provider Tokens

So far in this course, we've used "class - name" as our "Provider TOKENS".
Remember that "Provider TOKENS" are whatever we pass into the `"provide:"`
- property.  Sometimes we may want the flexibility to use String's or Symbol's
as the "Dependency - Injection" - TOKEN.

//{{{  coffee.module.ts
[source, typescript]
----
// coffee.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

import { CoffeesController } from "./coffees.controller";
import { CoffeesService } from "./coffees.service";
import { Coffee } from "./entities/coffee.entity";
import { Flavor } from "./entities/flavor.entity";
import { Event } from "../events/entities/event.entity";

class MockCoffeesService {}

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    // providers: [{ provide: CoffeesService, useValue: new MockCoffeesService() }],
    providers: [
        CoffeesService,
        { provide: "COFFEE_BRANDS", useValue: ["Salemba brew", "nescafe"] },
    ],
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

Let's say we `"provide: 'COFFEE_BRANDS'"` - "String - value TOKEN", with
"useValue: []" that we learned about in previous lesson, and set the "*value*" to
an *Array of String's*.  How could we use this "Provider" in our application
now?

So far we've mostly seen how to "Inject a Provider" using the "standard
constructor based *injection pattern*", like the one below,

//{{{  coffee.service.ts
[source, typescript]
----
// coffee.service.ts
...
...

@Injectable()
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,
        private readonly connection: Connection,
        @Inject("COFFEE_BRANDS") coffeeBrands: string[],    // <<<
    ) {}

    ...
    ...
}
----
//}}}

But, for us to be able to use the standard pattern it's required that the
dependencies is declared with a "Class - name". Because that is how Nest does
a "look up" for the dependency in the Inversion of Control (IoC) - container.

Our "COFFEE_BRANDS" - "custom Provider", uses a String value - TOKEN. So how can
we *inject* it?

With these types of providers. We can simply use the `@Inject()` decorator,
which takes a "single argument" being the "TOKEN" that needs to be looked up.

Now we are able to use "COFFEE_BRANDS" and access that Array of values we passed
into this Provider.

It's important to point out here, that while we directly the String
"COFFEE_BRANDS" inside to `@Inject()` decorator, it is a best practice to
"*define Tokens* in a *separate file*", that can be used throughout the
application.  That way we could simply "import" it here in "CoffeesService", and
avoiding costly mistakes such as typos or issues when we need to make changes or
refactor our application in the future.

So let's make a nwe file named `*"coffees.constants.ts"*` in our "/coffee/"
- directory.

In our new file, let's add,

//{{{ coffees.constant.ts
----
export const COFFEE_BRANDS = "COFFEE_BRANDS";
----
//}}}

Now, we can head into both "CoffeesService" and "CoffeesModule" and replace the String we are using,
and import this "COFFEE_BRANDS" - constant instead.

//{{{  coffee.service.ts
[source, typescript]
----
// coffee.service.ts

import { COFFEE_BRANDS } from "./coffees.constants";        // <<<
...
...

@Injectable()
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,
        private readonly connection: Connection,
        @Inject(COFFEE_BRANDS) coffeeBrands: string[],    // <<<
    ) {}

    ...
    ...
}
----
//}}}

//{{{  coffee.module.ts
[source, typescript]
----
// coffee.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

...
...
import { COFFEE_BRANDS } from "./coffees.constants";                        // <<<

class MockCoffeesService {}

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    // providers: [{ provide: CoffeesService, useValue: new MockCoffeesService() }],
    providers: [
        CoffeesService,
        { provide: COFFEE_BRANDS, useValue: ["Salemba brew", "nescafe"] }, // <<<
    ],
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

As you can see, we want to treat these "String Tokens" as you typically would any other "Symbols", "Enums", etc;
and define them in their "OWN - Files", so you can import them wherever they might be needed.

For testing purposes. Let's add a little `*"console.log"*` in our "CoffeesService" - `constructor()`, so we can make sure
it's working properly.

//{{{  coffee.service.ts
[source, typescript]
----
// coffee.service.ts

import { COFFEE_BRANDS } from "./coffees.constants";
...
...

@Injectable()
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,
        private readonly connection: Connection,
        @Inject(COFFEE_BRANDS) coffeeBrands: string[],
    ) {
        console.log(coffeeBrands);          // <<<
    }

    ...
    ...
}
----
//}}}

Let's open up our terminal, and start up our application and when it's finished building we should see
our "Array of String" show up.

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
[Nest] 297374   - 03/30/2021, 6:09:50 PM   [NestFactory] Starting Nest application...
[Nest] 297374   - 03/30/2021, 6:09:50 PM   [InstanceLoader] TypeOrmModule dependencies initialized +72ms
[Nest] 297374   - 03/30/2021, 6:09:50 PM   [InstanceLoader] AppModule dependencies initialized +0ms
[Nest] 297374   - 03/30/2021, 6:09:50 PM   [InstanceLoader] TypeOrmCoreModule dependencies initialized +91ms
[Nest] 297374   - 03/30/2021, 6:09:50 PM   [InstanceLoader] TypeOrmModule dependencies initialized +0ms
[ 'Salemba brew', 'nestcafe' ] 		// <<<
...
...
----
//}}}

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 6 == Class Based Providers
[[_class_based_providers]]
== Class Based Providers

Another custom "Provider Pattern" is the `"useClass"` - syntax. `"useClass"`
allows us to dynamically determine a Class that a Token should resolve to.

Let's take for example, that we have an *_abstract_* or default "ConfigService"
- Class, and depending on the "current - environment", we need Nest to provide
a different implementation of that "configuration - Service" for each one.

Just like before, we'll provide our "ConfigService" for the "Provider - Token".
But for the value, we'll use the new "useClass" - syntax.

Let's open our "CoffeesModule" file, and make some changes to the code,

//{{{  coffee.module.ts
[source, typescript]
----
// coffee.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

...
...
import { COFFEE_BRANDS } from "./coffees.constants";

class ConfigService {} 			// <<<
class DevelopmentConfigService {} 	// <<<
class ProductionConfigService {} 	// <<<
// class MockCoffeesService {} 		// <<<

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    providers: [
        CoffeesService,
        {
            provide: ConfigService,
            useClass: process.env.NODE_ENV === "development" ? DevelopmentConfigService : ProductionConfigService,
        },
        {
            provide: COFFEE_BRANDS, useValue: ["Salemba brew", "nestcafe"]
        }
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

First, let's define some - "classes" that we can use for illustration purpose.

Since we want our "ConfigService" to be different depending on the
"environment", we are going to look an example use-case, where we check the
process `*"env"*` - variable (`"NODE_ENV"`, in this demonstration) to decide
which *Class to "implement"*.

Now depending on what our `"NODE_ENV"` is, "ConfigService" will resolve to
either "DevelopmentConfigService" or "ProductionConfigService".

=== Reference
- link:https://docs.nestjs.com/fundamentals/custom-providers#class-providers-useclass[Custom Providers: class providers - 'useClass']

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 7 == Factory Based Providers
[[_factory_based_providers]]
== Factory Based Providers

Our next "Custom Provider" - pattern is `"useFactory"`. Which is a very common
and helpful pattern you will surely use many times in your application.

The `"useFactory"` - syntax allows us to create "Providers - *dynamically*",
which can be extremely useful if you need to base the "Provider's - value" on
various other "dependencies", "value", etc..

The "value" *returned* from the "factory - function" is, what will be used by
the "Provider Token". What makes these "factory - function" so special, is that
they themselves can "*inject OTHER - providers*" needed to compute the returning
result.

Let's look at the "COFFEE_BRANDS" - Provider we used in the previous lesson, and
convert it to `"useFactory"`.

//{{{  coffee.module.ts
[source, typescript]
----
// coffee.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

...
...
import { COFFEE_BRANDS } from "./coffees.constants";

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    providers: [
        CoffeesService,
        {
            provide: COFFEE_BRANDS, useFactory: () => ["Salemba brew", "nestcafe"]    // <<<
        }
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

Let's star out by making a function that simply returns the Array of String's
we previously had.

For testing purposes, let's make sure we still have that `console.log()` in our
"CoffeesService" here, so we can it's working properly.

Let's open up our terminal with our application running, and we should see our
Array of String still show up.

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
[Nest] 562972   - 03/30/2021, 9:18:41 PM   [NestFactory] Starting Nest application...
[Nest] 562972   - 03/30/2021, 9:18:41 PM   [InstanceLoader] TypeOrmModule dependencies initialized +74ms
[Nest] 562972   - 03/30/2021, 9:18:41 PM   [InstanceLoader] AppModule dependencies initialized +0ms
[Nest] 562972   - 03/30/2021, 9:18:41 PM   [InstanceLoader] TypeOrmCoreModule dependencies initialized +112ms
[Nest] 562972   - 03/30/2021, 9:18:41 PM   [InstanceLoader] TypeOrmModule dependencies initialized +1ms
[ 'Salemba brew', 'nestcafe' ]

...
...
----
//}}}

Pretty straightforward, but we *haven't taken full advantage* of "Factory
- Providers" yet.

Let's look at more realistic example, and inject some "providers" into it.

First, let's define a "random - Providers" for illustration purposes and make
sure to register it as "Providers".

//{{{  coffee.module.ts
[source, typescript]
----
// coffee.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

...
...
import { COFFEE_BRANDS } from "./coffees.constants";

@Injectable()
export class CoffeeBrandsFactory {
    create() {
        /* -- do something here --*/

        return ["Salemba nrew", "nestcafe"];
    }
}

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    providers: [
        CoffeesService,
        CoffeeBrandsFactory,
        {
            provide: COFFEE_BRANDS,
            useFactory: (brandsFactory: CoffeeBrandsFactory) => brandsFactory.create(),
            inject: [CoffeeBrandsFactory],
        }
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

Now, let's update our existing "COFFEE_BRANDS" - Provider to use the "CoffeeBrandsFactory".

[source, typescript]
----
inject: [CoffeeBrandsFactory],
----

In this code, we can see that we are using a new property for our `"providers:[]"`
called `*"inject"*`. `*"inject"*` takes in an Array of Providers itself. These providers
get passed into our `"useFactory"` - function, and we can use them however we would like.

[source, typescript]
----
useFactory: (brandsFactory: CoffeeBrandsFactory) => brandsFactory.create(),
----

This is just demonstration code of course, but you can see we have a "CoffeeBrandsFactory" that
we are injecting into our "useFactory" - function and calling a method on it.

Although this is all pseudo code. What's important here is, just knowing that you can use
your Dependencies here. Doing whatever type of "business - logic" you need, and
letting you return whatever value you want, for this providers.

=== Reference

- link:https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory[Custom Providers: factory providers - 'usefactory']

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 8 == Leverage Async Providers
[[_leverage_async_providers]]
== Leverage Async Providers

Sometimes when our applications Bootstrap, we need to *delay* the entire process
until one or more "Asynchronous - Task" have completed.

Let's imagine a "realistic - scenario' where we do *not* want to *start*
- "accepting request" until the connection with our database has been
  established. This is exactly where "Asynchronous - Providers" come in.

To achieve this. All we need is to use `"async/await"` in combination with the
`"useFactory"` - syntax, we just saw in the last lesson.

The "factory - function" we passed to Nest can return a "Promise" allowing it to
"await" any Asynchronous tasks.  Nest will await resolution of the Promise,
before instantiating any Class that depends on "*THIS* - Provider".

Using our "COFFEE_BRANDS" - Provider again. Let's say that this "provider's
- data" has to be Asynchronously queried from database, before it can be used
anywhere.

Let's go ahead and define our "Asynchronous - providers" by firstly adding the
`"aysnc"` - keyword, before our "Factory" - function.

//{{{  coffee.module.ts
[source, typescript]
----
// coffee.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

...
...
import { COFFEE_BRANDS } from "./coffees.constants";

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    providers: [
        CoffeesService,
        CoffeeBrandsFactory,
        {
            provide: COFFEE_BRANDS,
            useFactory: async () => ["Salemba brew", "nestcafe"]    // <<<
        }
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

Just for illustration purpose, we will add in some "Mock demo code" next.

//{{{  coffee.module.ts
[source, typescript]
----
// coffee.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import { Connection } from "typeorm";

...
...
import { COFFEE_BRANDS } from "./coffees.constants";

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    providers: [
        CoffeesService,
        CoffeeBrandsFactory,
        {
            provide: COFFEE_BRANDS,
            useFactory: async (connection: Connection): Promise<string[]> => {
                // const coffeeBrands = await connection.query(`SELECT * ...`);
                const coffeeBrands = await Promise.resolve(["Salemba brew", "nestcafe"]);

                console.log("[!] async factory");
                return coffeeBrands;
            },
            inject: [Connection],
        },
    ],
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

Let's imagine we are "injecting" some sort of "database  - connection" and then
"querying" the database to get all of the "Coffee - Brands".  But, we are just
going to just resolve a "Mock - Promise" with our "Array of Brands", pretending
that's our database - connection *inquiry*, and return it back to the "factory".

For testing - purposes. Let's make sure that we have that `console.log()` in our
"CoffeesService". So we can make sure it's working properly.

Now, if we add `console.log()` in our "factory" - function, and save our changes
and open up the terminal,

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev

[Nest] 872871   - 03/31/2021, 12:59:59 AM   [NestFactory] Starting Nest application...
[Nest] 872871   - 03/31/2021, 12:59:59 AM   [InstanceLoader] TypeOrmModule dependencies initialized +72ms
[Nest] 872871   - 03/31/2021, 12:59:59 AM   [InstanceLoader] AppModule dependencies initialized +0ms
[!] async factory 			// <<<
[Nest] 872871   - 03/31/2021, 12:59:59 AM   [InstanceLoader] TypeOrmCoreModule dependencies initialized +83ms
[Nest] 872871   - 03/31/2021, 12:59:59 AM   [InstanceLoader] TypeOrmModule dependencies initialized +1ms
[ 'Salemba brew', 'nestcafe' ] 		// <<<
...
...
----
//}}}

We see that our "CoffeesService" - class is *instantiated* AFTER "COFFEE_BRANDS"
are returned from the database.

"Asynchronous Providers" make complex situation such as these - that much
easier. We no longer need to worry about *"race - condition"* and many other
common application startup needs.

=== Reference

- link:https://docs.nestjs.com/fundamentals/async-providers#asynchronous-providers[Async Providers]

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 9 == Create a Dynamic Module
[[create_a_dynamic_module]]
== Create a Dynamic Module

So far, every "Nest - Module" we've seen has been a *"Static - Module"*.
Sometimes we need more *flexibility* when using a Module. For example. "Static
- Module" *can't* have their "Providers" be *_configured_* by a Module that is
*"consuming - it"*.

So why does it matter? Well, let's consider a "use-case" where we have
a *"general purpose - Module"* that needs to behave differently in different
circumstances. Think of this concepts almost like a *"Plugin - System"*. Our
"Dynamic - Module" require configuration BEFORE they can be used by
a *"consumer"*.

To help us understand how "Dynamic Modules" work, let's create
a *"DatabaseModule"*, that can be *passed* "configuration - settings", before it
instantiates.

This is just for demonstration purposes of course. Since we have "TypeOrmModule"
already creating a connection to our database.

First, let's generate this new `@Module()` and all it "DatabaseModule" by
entering,

//{{{ $ nest g mo databse
[source, shell]
----
$ nest g mo database
CREATE src/database/database.module.ts (85 bytes)
UPDATE src/app.module.ts (951 bytes)
----
//}}}

Now, let's open it up and head over to the `*"providers:[]"` Array and define
a "connection - Provider".

//{{{ database.module.ts
[source, typescript]
----
// database.module.ts
import { Module } from '@nestjs/common';
import { createConnection } from "typeorm";

/*-- static module --*/
@Module({
    providers: [
        {
            provide: "CONNECTION",
            useValue: createConnection({
                type: "postgres",
                host: "localhost",
                port: 5432,
            }),
        },
    ],
})
export class DatabaseModule {}
----
//}}}

Let's utilize the `*"useValue"*` - Providers syntax we've learned and called
that `"createConnection()` - method from `"TypeORM"` , passing in some
"arbitrary - values" to set up our "Database - Connection".

Since our "DatabaseModule" hard codes these "connection - options", we can *NOT*
easily "share this module" among different applications, can we? This is
because our "DatabaseModule" is statically configure and can't be customized.

What if another application wants to use this Module, but it needs to use
a "different - *port*"? Well, luckily for us, using Nest's `"DynamicModule"`
- features, we can let *"consuming - modules"* use an API to *control* how this
"DatabaseModule" is customized when it imported.

To achieve this type customization that other Modules can control, let's define
a *"static"* - method named `"register()"` on our "DatabaseModule" like so.

//{{{ database.module.ts
[source, typescript]
----
// database.module.ts
import { DynamicModule, Module } from '@nestjs/common';
import { createConnection, ConnectionOptions } from "typeorm";

/*-- dynamic module --*/
@Module({})
export class DatabaseModule {
    static register(options: ConnectionOptions): DyanamicModule {
        return {
            module; DatabaseModule,
            providers: [
                {
                    provide; "CONNECTION",
                    useValue: createConnection(options),
                },
            ],
        },
    },
}
----
//}}}

Now, let's steps through the code we just added, one section at a time.

First, we can see that our `"register()"` - method accepts `*"options:"*` that
*"consuming - modules"* can pass in to it. We've made our `"options:"` take on
the *interface* of `*"ConnectionOptions"*` from "typeorm" - package in this
case, which helps *"strongly - type"* everything we are allowing other Modules
to pass in, that is: *the database* - "type", "host", "password", etc.

Next, we can see that our `"register()"` - method return to Type of
"DynamicModule" which has essentially the same interface of our typical
`@Modules()` but requires that a `*"module:"*` - property be passed, which we
can see is just our current module - the "DatabaseModule" itself.

Aside from that, we are utilizing that `"providers:[]"` Array here to create
a "connection - Provider".  But now we are able to pass down ALL the
*"options"* we received when this `"register()"` - method was *invoked*.

Let's make sure we *delete* the previous "static - implementation" of connection
above.

Just like that, We've created the ability for our "*consuming* - Modules" to
pass in exactly the "*connection* - options" they need!.

With this in place, we can import our "DatabaseModule" in other modules just
like this,

//{{{ coffee-rating.module.ts
[source, typescript]
----
// coffee-rating.module.ts
import { Module } from "@nestjs/common";
import { CoffeesModule } from "../coffees/coffees.module";
import { CoffeeRatingService } from "./coffee-rating.service";
import { DatabaseModule } from "../database/database.module";

@Module({
    imports: [
        DatabaseModule.register({
            type: "postgres",
            host: "localhost",
            port: 5432,
            username: "postgres",
            password: "pass123",
            // database: "postgres1",
            // autoLoadEntities: true,
            // synchronize: true, // COMMENT THIS in production - mode
        }),
        CoffeesModule
    ],
    providers: [CoffeeRatingService],
})
export class CoffeeRatingModule {}
----
//}}}

Since we have an *interface* for our `*"options:"*`. We know every "possible
- option" we can pass down their "required - type".

This is an "extremely *important pattern* to understand". As in most advanced Nest
- applications it is *used - "very often"*, as many applications require this
type of *flexibility*.

=== Reference
- link:https://docs.nestjs.com/fundamentals/dynamic-modules#dynamic-modules[Nest Dynamic Modules, window=_blank]

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 10 == Control Providers Scope
[[control_providers_scope]]
== Control Providers Scope

//{{{ image::./images/chapter-4-8.png
[#img-chapter]
[link=./images/chapter-4-8.png]
.Control Providers Scope
image::./images/chapter-4-8.png[align="center"]
//}}}

For those of you coming from different programming language backgrounds. It
might be unexpected to learn that in Nest, almost everything is "*shared* across
incoming - request"

//{{{ image::./images/chapter-4-9.png
[#img-chapter]
[link=./images/chapter-4-9.png]
.Control Providers Scope - multi-thread - pattern
image::./images/chapter-4-9.png[align="center"]
//}}}

Remember that NodeJS does *NOT* follow the "*request/response* multi-threaded
- stateless model", in which every request is processed by a separate Thread.
Because of this, using "Singleton - instances" is fully safe for our
applications.

//{{{ image::./images/chapter-4-10.png
[#img-chapter]
[link=./images/chapter-4-10.png]
.Control Providers Scope - Singleton instances - pattern
image::./images/chapter-4-10.png[align="center"]
//}}}

However, there are edge cases where you may need a "Provider" to have a "request
based - lifetime"  for a certain desired behavior.

Take for example applications that require "instance request - *tracking*" or
"multi tenant - applications".

`@Injection()'s`  - "scope" mechanism allow us to obtain the desired provider
lifetime behavior you need.  By *default*, every *Provider* in NestJS is
a *"Singleton."*

So an example, when we use `@Injectable()` in our "CoffeesService", it is really
a shorthand implementation for passing it on Object with `"scope:
Scope.DEFAULT"`. The DEFAULT being Singleton as the value.

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
    ...
    ...

@Injectable({ scope: Scope.DEFAULT })
export class CoffeesService {
    ...
    ...
}
----
//}}}

The "instance - lifetime" of a *Provider* is tied directly to or "application's
- life cycle" Once our application has bootstrapped, all the "Singleton
- Providers" have been instantiated.

As the best practice, using "Singleton - scope" is RECOMMENDED for most
use-cases. Most notably for "performance" reason.

All right. So now that we've seen the default - behavior. Let's dive into *two*
other lifetimes available for `@Injectable()` - providers.

- "TRANSIENT - Scoped" - lifetime.
- "REQUEST - Scoped" - lifetime.

"TRANSIENT" - provider are *"NOT shared"* - *across consumers*. Each consumers
that injects a "TRANSIENT" - provider will receive a NEW DEDICATED INSTANCE of
*that* provider. Let's say we change our "CoffeesService" to be
`*"Scope.TRANSIENT"*`.

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
    ...
    ...

@Injectable({ scope: Scope.TRANSIENT })
export class CoffeesService {
    constructor(
        ...
        ...
    ) {
        console.log("[!!] CoffeesService instantiated");
    }

}
----
//}}}

Let's update the `console.log()` here inside our "CoffeesService" - constructor
to say, `"[!!] CoffeesService instantiated"`.  Just so we can test and make sure
this instantiated more than once in our application.

Let's make note of the fact, that our "CoffeesService" is being used in *TWO
spots*: in "CoffeesController" and "CoffeeBrandsFactory".

Now let's head to the terminal, and start up the application.

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
[Nest] 1914536   - 03/31/2021, 1:20:10 PM   [NestFactory] Starting Nest application...
[Nest] 1914536   - 03/31/2021, 1:20:10 PM   [InstanceLoader] TypeOrmModule dependencies initialized +46ms
[Nest] 1914536   - 03/31/2021, 1:20:10 PM   [InstanceLoader] DatabaseModule dependencies initialized +0ms
[Nest] 1914536   - 03/31/2021, 1:20:10 PM   [InstanceLoader] DatabaseModule dependencies initialized +1ms
[Nest] 1914536   - 03/31/2021, 1:20:10 PM   [InstanceLoader] AppModule dependencies initialized +0ms
[Nest] 1914536   - 03/31/2021, 1:20:10 PM   [InstanceLoader] TypeOrmCoreModule dependencies initialized +126ms
[Nest] 1914536   - 03/31/2021, 1:20:10 PM   [InstanceLoader] TypeOrmModule dependencies initialized +1ms
[!!] CoffeesService instantiated 	// <<<
[!!] CoffeesService instantiated 	// <<<
[Nest] 1914536   - 03/31/2021, 1:20:10 PM   [InstanceLoader] CoffeeRatingModule dependencies initialized +10ms
[Nest] 1914536   - 03/31/2021, 1:20:10 PM   [InstanceLoader] CoffeesModule dependencies initialized +1ms
[Nest] 1914536   - 03/31/2021, 1:20:10 PM   [RoutesResolver] AppController {}: +14ms
...
...
----
//}}}

Once it's finished building, we can see that when our application "started up",
"[!!] CoffeesService - instantiated" shows up twice.

If you remove this "Scope.TRANSIENT" linet from our `@Injectable()" and head
back to the terminal.  We'll see "CoffeeService" instantiated only happing once
now.

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev

[Nest] 1956518   - 03/31/2021, 1:49:14 PM   [NestFactory] Starting Nest application...
[Nest] 1956518   - 03/31/2021, 1:49:14 PM   [InstanceLoader] TypeOrmModule dependencies initialized +45ms
[Nest] 1956518   - 03/31/2021, 1:49:14 PM   [InstanceLoader] DatabaseModule dependencies initialized +1ms
[Nest] 1956518   - 03/31/2021, 1:49:14 PM   [InstanceLoader] DatabaseModule dependencies initialized +0ms
[Nest] 1956518   - 03/31/2021, 1:49:14 PM   [InstanceLoader] AppModule dependencies initialized +0ms
[Nest] 1956518   - 03/31/2021, 1:49:14 PM   [InstanceLoader] TypeOrmCoreModule dependencies initialized +134ms
[Nest] 1956518   - 03/31/2021, 1:49:14 PM   [InstanceLoader] TypeOrmModule dependencies initialized +1ms
[!!] CoffeesService instantiated
[Nest] 1956518   - 03/31/2021, 1:49:14 PM   [InstanceLoader] CoffeesModule dependencies initialized +7ms
[Nest] 1956518   - 03/31/2021, 1:49:14 PM   [InstanceLoader] CoffeeRatingModule dependencies initialized +1ms
...
...
----
//}}}

This is because our Service is back to being a "Singleton - scope" again!.

To specify the "Scope" of our "custom - Provider". Add an extra property named
`"scope:"`.  Let's use our "COFFEE_BRANDS" example from our previous lesson.

//{{{ coffees.module.ts
[source, typescript]
----
// coffees.module.ts
import { Injectable, Module, Scope } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

import { CoffeesController } from "./coffees.controller";
import { CoffeesService } from "./coffees.service";
import { Coffee } from "./entities/coffee.entity";
import { Flavor } from "./entities/flavor.entity";
import { Event } from "../events/entities/event.entity";
import { COFFEE_BRANDS } from "./coffees.constants";

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    providers: [
        CoffeesService,
        {
            provide: COFFEE_BRANDS,
            useFactory: async () => ["Salemba brew", "nestcafe"],
            scope: Scope.TRANSIENT,         // <<<
        },
    ],
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

Let's use our "COFFEE_BRANDS" example from a previous lesson.  If we add
`"scope: Scope.TRANSIENT"` here. Then we are all set and it will work exactly
like in our previous example.

Our last "Scope" - lifetime option is know as "*REQUEST* - Scoped".

"*REQUEST* - Scope* provides a "new instance of the Provider" exclusively for
EACH *incoming - request*.

NOTE: that the *instance* from "*REQUEST - Scope*" is also automatically
"garbage - collected" after the request has completed processing.

To mark the "Provider" as a "REQUEST - Scope". Simply pass in `"scope:
Scope.REQUEST"` into your `"@Injectable()"`.

Let's try again on our "CoffeesService" making sure we still hae our
`console.log()` in the constructor.

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
    ...
    ...

@Injectable({ scope: Scope.REQUEST })   // <<<
export class CoffeesService {
    constructor(
        ...
        ...
    ) {
        console.log("[!!] CoffeesService instantiated");
    }

}
----
//}}}

With just like that, the "CoffeesService" will be instantiated on EVERY REQUEST.

In the next lesson. We'll dive even deeper into "REQUEST - Scope", see you
there!.

=== Reference

- link:https://docs.nestjs.com/fundamentals/injection-scopes#provider-scope[Provider Scope, window=_blank]

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 11 == Diving Deeper into Request - Scope Providers
[[_diving_deeper_into_request_scope_providers]]
== Diving Deeper into Request - Scope Providers

We left off the last lesson discussing "REQUEST - Scopes", and how a "new
instance" of the *Provider* is *created exclusively* for each - "incoming
- request* and "garbage - collected" after the request has completed.

To better understand "REQUEST - Scope" - Providers. Let's look at our
"CoffeeService" again, and make sure it's still "REQUEST" - Scoped.

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
    ...
    ...

@Injectable({ scope: Scope.REQUEST })   // <<<
export class CoffeesService {
    constructor(
        ...
        ...
    ) {
        console.log("[!!] CoffeesService instantiated");
    }

}
----
//}}}

Let's double check that we still have that `"console.log()"` in our
"CoffeesService" - "constructor()", so we know each timing has been created.

With all of this in place, and our application running in the background, if it
not, you can run `"npm run start:dev"`.

We can see that even after our application bootstrapped, we didn't see any
"logs" that our "CoffeesService" was instantiated - which is exactly what we
should expect!. Since we haven't requested any API - endpoints that use this
"Service" yet.

Let's open `insomnia` and execute "3" - HTTP GET - request to our `"/coffee"`
- endpoint. Now get back to our terminal again, we can see that there are "3"
messages logged saying, "[!!] CoffeeService instantiated".

//{{{  $ npm run start:dev
[source, bash]
----
$ npm run start:dev
...
...
[Nest] 2178928   - 03/31/2021, 4:25:32 PM   [NestApplication] Nest application successfully started +6ms
[!!] CoffeesService instantiated
[!!] CoffeesService instantiated
[!!] CoffeesService instantiated
----
//}}}

This means that, this Service was exclusively created for us each request.
Perfect.  But wait a second, *how is it even possible* that "CoffeesService" was
created "three - times", although our "CoffeeController" which handles these
endpoint requests is a *Singleton*, since we never change anything in
a `@Controller()` - decorator for it?

Well in Nest, these Scopes actually bubble UP the "Injection - Chain".  This
means that if the "CoffeesController" depends on the "CoffeesService" which is
a "REQUEST - Scoped" it implicitly becomes "REQUEST - Scoped" as well!.

To test this behavior. Let's add a single `console.log()` to our
"CoffeesController" - constructor to have a "verbose - log"  in the terminal
every time an "instance of the 'CoffeesController' - class is created".

//{{{ coffee.controller.ts
[source, typescript]
----
// coffee.controller.ts
    ...
    ...
@Controller("coffees")
export class CoffeesController {
    constructor(private readonly coffeesService: CoffeesService) {
        console.log("[!!] CoffeesController created");
    }
}
----
//}}}

Let's save our changes. Head back to `insomnia` and executue those "3" GET -
request again for the "/coffees" - endpoint.

//{{{  $ npm run start:dev
[source, bash]
----
$ npm run start:dev
...
...
[Nest] 2376781   - 03/31/2021, 6:46:03 PM   [NestApplication] Nest application successfully started +5ms
[!!] CoffeesService instantiated
[!!] CoffeesController created
[!!] CoffeesService instantiated
[!!] CoffeesController created
[!!] CoffeesService instantiated
[!!] CoffeesController created

----
//}}}

Now we can see that there are *6" - messages in our terminal. "*3* from the
*Service*", "*3* from the *Controller*". Which means that both were exclusively
created for each - request. Great!.

There is actually one more extra capability of "REQUEST - Scope" - providers.
"REQUEST - Scope" - providers can inject the `"original"` - "Request -
Object".  This is useful if you need access to *"request specific
information"*, such as "headers", "cookies", "IP - addresses", etc.

//{{{ coffee.controller.ts
[source, typescript]
----
// coffee.controller.ts
import { Controller, Get, Param, Body, Post, Patch, Delete, Query, Inject } from "@nestjs/common";
import { REQUEST } from "@nestjs/core";
import { Request } from "express";
...
...

@Controller("coffees")
export class CoffeesController {
    constructor(
	private readonly coffeesService: CoffeesService
	@Inject(REQUEST) private readonly request: Request,
	) {
        console.log("[!!] CoffeesController created");
    }
}
----
//}}}

Note, that with this "great - power" comes "great - responsibility". Using
"REQUEST - Scope" - Providers may have an impact on your "applications
- performance".

While Nest tries to cache as much metadata as possible. It will still have to
create an instance of your class for each request. This might slightly slow down
your "average - response time", and overall "benchmarking result". Unless
a Provider *must* be "REQUEST - Scope" it is always RECOMMENDED that you use the
*default* - "Singleton - Scope" whenever possible.

=== Reference

- link:https://docs.nestjs.com/fundamentals/injection-scopes#scope-hierarchy[Injection Chain in Scope Hierarchy]

**⬆xref:_table_of_contents[back to top]**
//}}}
