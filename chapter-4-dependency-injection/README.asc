//{{{ ** ASCIIDOC HEADER
:description:   nestjs official course | chapter-4
:url-repo:      https://github.com/agungTuanany/nestjs_course_official
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Mon Mar 29 11:39:39 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
//}}}

[[_chapter_4_dependency_injection]]
= Chapter-4 Dependency Injection
:figure-caption!:
:source-highlighter: highlight.js

//{{{== Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_understanding_dependency_injection[Understanding Dependency Injection]
| 2.    | xref:_control_nest_module_encapsulation[Control Nest Module Encapsulation]
| 3.    | xref:diving_into_custom_providers[Diving Into Custom Providers]
| 4.    | xref:_value_based_providers[Value Based Providers]
| 5.    | xref:_non_class_based_provider_tokens[Non Class Based Provider Tokens]
| 6.    | xref:_class_based_provider[Class Based Provider]
| 6.    | xref:_factory_based_provider[Factory Based Provider]
|====
//}}}

//{{{ 1 == Understanding Dependency Injection
[[_understanding_dependency_injection]]
== Understanding Dependency Injection
:fn-transitive_dependencies: footnote:[When an indirect relationship causes functional dependency is called "Transitive - Dependencies"]
:fn-dependencies_graph: footnote:[In mathematics, computer science and digital electronics, a dependency graph is a directed graph representing dependencies of several objects towards each other. It is possible to derive an evaluation order or the absence of an evaluation order that respects the given dependencies from the dependency graph. https://en.wikipedia.org/wiki/Dependency_graph]

//{{{ image::./images/chapter-4-1.png
[#img-chapter]
[link=./images/chapter-4-1.png]
.Before we get started
image::./images/chapter-4-1.png[align="center"]
//}}}

Dependency Injection is a technique where we delegated instantiation of
dependencies, to an *"inversion of control"* (IoC) - container. In our case this
"*IoC*" - container is the NestJS runtime system itself.

//{{{ image::./images/chapter-4-2.png
[#img-chapter]
[link=./images/chapter-4-2.png]
.How Dependencies Injection works.
image::./images/chapter-4-2.png[align="center"]
//}}}

NestJS handles all the heavy lifting here, instead of trying to achieve
Dependency Injection ourselves.  Essentially when we *"ask"* for a dependency in
a *class - "constructor"*. NestJS handles and retrieves the Object - BACK to us,
along with any dependencies it might require, and so on and so on...


Let's take a look an example in our own code, and dive into how it all works.

//{{{ coffee.controller.ts
[source, typescript]
----
// coffee.controller.ts
@Controller("coffees")
export class CoffeesController {
    constructor(private readonly coffeesService: CoffeesService) {}     //<<<

    ...
    ...
}
----
//}}}

In our "CoffeeController" When we are using "CoffeesService" and injecting it here
in our `"constructor()"`; What is exactly is happening in NestJS under the hoood,
to make all of this work?.

Well, there are "3" - keys steps in the Dependency Injection process - that make it hall happen.

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
@Injectable() // <<<
export class CoffeesService {
    ...
    ...
}
----
//}}}

- *First*, in our "CoffeesService" - the `@Injectable()" decorator declares
  a "class" that can be managed by the Nest "container". This decorator marks
  the "CoffeesService" - class as a *"Provider"*.

//{{{ coffee.controller.ts
[source, typescript]
----
// coffee.controller.ts
@Controller("coffees")
export class CoffeesController {
    constructor(private readonly coffeesService: CoffeesService) {}
    //                                  ^^           ^^
    ...
    ...
}
----
//}}}

- *Second*, if we jump to our "CoffeeController". We can see we are requesting the
  "CoffeesService" in our "constructor". This (`"coffeesService: CoffeesService"`) request
  tells Nest to "inject" the *"Provide"* into our "controller()" - class, so that
  we may able to utilize it.

//{{{ coffee.module.ts
[source, typescript]
----
// coffee.module.ts
@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],       // <<<
    providers: [CoffeesService],            // <<<
})
export class CoffeesModule {}
----
//}}}

- *Lastly*, Nest is aware that this class ("CoffeeController") also
  a "Provider", because we've include here in our "CoffeesModule", which
  registers this "Provider" with Nest - "Inversion of Control" - container.

That's how it al works in our code itself. But now let's dive even deeper to see
what Nest does.

//{{{ image::./images/chapter-4-3.png
[#img-chapter]
[link=./images/chapter-4-3.png]
.Dive deep into Dependency Injection
image::./images/chapter-4-3.png[align="center"]
//}}}

When the Nest - container instantiates the "CoffeesController". It first looks
to see if there are-any-dependencies *"needed"*. In our case, there is one, the
"CoffeesService".

When the Nest - container finds the "CoffeesService" - dependencies, it performs
a *"lookup"* on the *"CoffeesService" - token*, which return the
"CoffeesService" - class.

Assuming this "Provider" has a "singleton" - scope, which is the default
behavior of "Injectable - Providers".  Nest will either *create an instance* of
"CoffeesService", *"cache it"* and *"return it"* or if one is-already - cached,
it will return *that* existing - instance.

We are simplifying everything a bit, but hopefully this all helps illustrate the
point.

Analyzing our codebase  for dependencies: is *quite the complex task*, that Nest
handles for us, and it "ALL" happens during "Application Bootstrapping".

This "dependencies - analysis" for creating the "Dependency Graph" is
transitive{fn-transitive_dependencies}.

In this example, if the "CoffeesService" itself has dependencies (which is does).
*Those* dependencies *_need_* to be resolved as well.

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
@Injectable() // <<<
export class CoffeesService {

    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,      // It's need to be resolved
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,      // It's need to be resolved
        private readonly connection: Connection,                    // It's need to be resolved
    ) {}
}
----
//}}}

The "Dependencies - Graph{fn-dependencies_graph}" ensures that Dependencies are
resolved in the CORRECT ORDER, or essentially that they are resolved from the
"bottom - up (^)".

This mechanism relieves the developer from having to manage such "complex
- Dependency Graph".

All right, enough theory for now!.

Let's take a closer look at the `@Module()` - decorator.

//{{{ coffee.module.ts
[source, typescript]
----
// coffee.module.ts
@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],       // <<<
    providers: [CoffeesService],            // <<<
})
export class CoffeesModule {}
----
//}}}

In our "CoffeesModule" we declared "[CoffeesService]" in our `"provides[]"`
Array.  So far we've supplied all of our "Providers" by a list of "class
- name".  But in fact!, these syntax is actually a shorthand - version of the
more complex syntax.

//{{{ coffee.module.ts
[source, typescript]
----
// coffee.module.ts
@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    providers: [                        // <<<
        {
            provide: CoffeeService,             // <<<
            useClass: CoffeeService.            // <<<
        },
    ],
})
export class CoffeesModule {}
----
//}}}

Now that we see this explicit construction. We can start to understand the
"Dependencies - Registration process".

With this complete syntax. We can see that we are clearly associating the TOKEN,
"CoffeesService" with the class "CoffeesService". The shorthand notation is
merely a convenience to simplify the most common use-case, where the TOEKN used
to "request an instance of a class", *comes by the same name".

Later on in this chapter, we'll be looking at other useful ways to provide
*"alternative values"* and other Dependency Injection *"tips"* and *"tricks"*.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 2 == Control Nest Module Encapsulation
[[_control_nest_module_encapsulation]]
== Control Nest Module Encapsulation

//{{{ image::./images/chapter-4-5.png
[#img-chapter]
[link=./images/chapter-4-5.png]
.Control Nest Module Encapsulation
image::./images/chapter-4-5.png[align="center"]
//}}}

By default, NestJS modules "encapsulate" their "Providers". This Encapsulation
makes it impossible to inject Providers that are not either *"directly* part of
the current module" or *"exported* from a module being used"

//{{{ image::./images/chapter-4-6.png
[#img-chapter]
[link=./images/chapter-4-6.png]
.Control Nest Module Encapsulation
image::./images/chapter-4-6.png[align="center"]
//}}}

You can think of "exported providers", being your modules "public - interfaces"
or API.

Let's look at an example of how this "encapsulation - works", and how we can use
it in our applications.

Let's start off by defining a brand new *"CoffeeRatingModule"*. To generate
*"new module"* with NestJS - CLI, let's enter in

//{{{ $ nest g mo coffee-rating
[source, shell]
----
$ nest g mo coffee-rating
CREATE src/coffee-rating/coffee-rating.module.ts (89 bytes)
UPDATE app.module.ts (871 bytes)
----
//}}}

We are using the Nest - CLI shorthand syntax here, instead of the more verbose
"$ nest generate module".

Now, let's create a "new - Provider" called "CoffeeRatingService" and
encapsulate it within our new "CoffeeRatingModule"

//{{{ $ nest g mo coffee-rating
[source, shell]
----
$ nest g s coffee-rating
CREATE src/coffee-rating/coffee-rating.service.spec.ts (503 bytes)
CREATE src/coffee-rating/coffee-rating.service.ts (96 bytes)
UPDATE src/coffee-rating/coffee-rating.module.ts (188 bytes)
----
//}}}

To help us understand encapsulation better. Let's say our new
"CoffeeRatingService" depends on "CoffeesService" to *fetch* Coffee's from the
database.

We know that "CoffeesService" belongs to a "*different* - module", so let's make
sure we import the "CoffeesModule" here in our "CoffeeRatingModule".

//{{{ coffee-rating.module.ts
[source, typescript]
----
// coffee-rating.module.ts
import { Module } from '@nestjs/common';
import { CoffeesModule } from "../coffees/coffees.module";
import { CoffeeRatingService } from './coffee-rating.service';

@Module({
    imports: [CoffeesModule],            // <<<
    providers: [CoffeeRatingService]
})
export class CoffeeRatingModule {}
----
//}}}

Switch over to "CoffeeRatingService", and use the "constructor based injection"
to add the "CoffeesService".

//{{{ coffee-rating.service.ts
[source, typescript]
----
// coffee-rating.service.ts
import { Injectable } from "@nestjs/common";
import { CoffeesService } from "../coffees/coffees.service";

@Injectable()
export class CoffeeRatingService {
    constructor(private readonly coffeesService: CoffeesService) {}     // <<<
}
----
//}}}

If we switch to our terminal and try to run our application with,

//{{{ npm run start:dev
[source, shell]
----
$ nest run start:dev
[Nest] 3363695   - 03/30/2021, 7:41:33 AM   [NestFactory] Starting Nest application...
[Nest] 3363695   - 03/30/2021, 7:41:33 AM   [InstanceLoader] TypeOrmModule dependencies initialized +77ms
[Nest] 3363695   - 03/30/2021, 7:41:33 AM   [ExceptionHandler] Nest can't resolve dependencies of the CoffeeRatingService (?). Please make sure that the argument CoffeesService at index [0] is available in the CoffeeRatingModule context.
...
...
----
//}}}

We will notice, that Nest won't be able to bootstrap properly and error message
will be thrown, that says:

----
"Nest can't resolve dependencies of the CoffeeRatingService (?). Please make sure that the argument CoffeesService at index [0] is available in the CoffeeRatingModule context."
----

So, what did we miss? Well, as we said a moment ago, All Modules encapsulate
their Providers by default. That means, that if you want to use them in
"another" - module, we Must explicitly define them as *"exported"*. Making them
a part of the *"Public API"* of that module.

All right. So this sounds like an easy fix!. Let's open up the "CoffeesModule"
and add on *"exports: []"* to the `@Module()` definition, making sure we put
"CoffeesService" inside of it!.

//{{{ coffees.module.ts
[source, typescript]
----
// coffees.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

import { CoffeesController } from "./coffees.controller";
import { CoffeesService } from "./coffees.service";
import { Coffee } from "./entities/coffee.entity";
import { Flavor } from "./entities/flavor.entity";
import { Event } from "../events/entities/event.entity";

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    providers: [CoffeesService],
    exports: [CoffeesService]                   // <<<
})
export class CoffeesModule {}
----
//}}}

If we save our changes, and head back to our terminal, we'll see our Nest
application was able to bootstrap successfully, and we no longer see any
errors!.

That's encapsulation in a nutsheell!.

Now we are able to use "CoffeesService" anywhere in our "CoffeeRatingModule".

//{{{ npm run start:dev
[source, shell]
----
$ nest run start:dev
[Nest] 3388048   - 03/30/2021, 7:58:52 AM   [NestFactory] Starting Nest application...
[Nest] 3388048   - 03/30/2021, 7:58:52 AM   [InstanceLoader] TypeOrmModule dependencies initialized +72ms
[Nest] 3388048   - 03/30/2021, 7:58:52 AM   [InstanceLoader] AppModule dependencies initialized +1ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [InstanceLoader] TypeOrmCoreModule dependencies initialized +126ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [InstanceLoader] TypeOrmModule dependencies initialized +1ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [InstanceLoader] CoffeesModule dependencies initialized +1ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [InstanceLoader] CoffeeRatingModule dependencies initialized +0ms   // <<<<
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [RoutesResolver] AppController {}: +11ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [RouterExplorer] Mapped {, GET} route +5ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [RoutesResolver] CoffeesController {/coffees}: +1ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [RouterExplorer] Mapped {/coffees, GET} route +1ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [RouterExplorer] Mapped {/coffees/:id, GET} route +2ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [RouterExplorer] Mapped {/coffees, POST} route +1ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [RouterExplorer] Mapped {/coffees/:id, PATCH} route +1ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [RouterExplorer] Mapped {/coffees/:id, DELETE} route +1ms
[Nest] 3388048   - 03/30/2021, 7:58:53 AM   [NestApplication] Nest application successfully started +5ms
----
//}}}

As we can see, this encapsulation really gives us full control over what is
*"public"* and *"privately"* available within our Modules and other Module's
that depend on them.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 3 == Diving Into Custom Providers
[[diving_into_custom_providers]]
== Diving Into Custom Providers

//{{{ image::./images/chapter-4-7.png
[#img-chapter]
[link=./images/chapter-4-7.png]
.Diving Into Custom Providers
image::./images/chapter-4-7.png[align="center"]
//}}}

What happens when our application's requirements go above and beyond what we've
seen available with injecting and creating "Providers" so far.

Let's take a look at some example use cases where we might need something a bit
more sophisticated.

. Let's say we create a custom instance of our "Provider" instead of
having Nest Instantiate that class for us.

. Or let's say we want to *"reuse an existing class"* in a second
dependency.

. How about if we want to overwrite a class with a mock version of
testing.

. Lastly, what if we want to use a *"Strategy Pattern"* in which we can provide
an "abstract - class" and interchange the real implementation (or actual class
that is to be used) based on different conditions.

Well, luckily Nest allows us to define "Custom - Providers" to handle use case
such as above, and many others.

//{{{ image::./images/gif/chapter-4-1.gif
[#img-chapter]
[link=./images/gif/chapter-4-1.gif]
.Diving Into Custom Providers
image::./images/gif/chapter-4-1.gif[align="center"]
//}}}

We saw in a previous lesson, that when we add "Providers" to "Nest - Modules"
- `"providers: []"` Array. It's really just a shorthand of providing the TOKEN
and providing "what is to be injected" in that TOKEN"s place.

Nest provides several ways of defining these "Custom - Providers". So let's walk
through a few of them, so we gain a deeper understanding of how we can utilize
each one - in our own applications!.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 4 == Value Based Providers
[[_value_based_providers]]
== Value Based Providers

The first "Custom  - Provider" we'll look at is, their *"useValue"* - syntax.
The *"useValue"* - syntax is useful for Injecting a "*constant* - value".

Let's say we wanted to *"add an external library"* into the Nest - container, or
maybe we are "*replacing"* a real implementation of a Service with `"*Mock{}"*`
- Object.  You can imagine for *"testing - purpose"*. This would be ideal.

Using our application as an example, let's say we would like to force Nest to
use a `*"MockCoffeesService"*` for illustration purposes. Let's add our "Mock
- Service" - implementation here that we'll use in this demo.

//{{{  coffee.module.ts
[source, typescript]
----
// coffee.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

import { CoffeesController } from "./coffees.controller";
import { CoffeesService } from "./coffees.service";
import { Coffee } from "./entities/coffee.entity";
import { Flavor } from "./entities/flavor.entity";
import { Event } from "../events/entities/event.entity";

class MockCoffeesService {}

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    providers: [{ provide: CoffeesService, useValue: new MockCoffeesService() }],
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

Now, let's replace our "CoffeesService" in the `*"providers:[]"*` Array to our
"Custom - Provider"  and use the `"useValue:"` - syntax.

With what we just did. Now whenever the "CoffeesService" TOKEN is "resolved", it
will point to the new "MockCoffeesService", *any time* we inject "CoffeesService"
in our application!.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 5 == Non Class Based Provider Tokens
[[_non_class_based_provider_tokens]]
== Non Class Based Provider Tokens

So far in this course, we've used "class - name" as our "Provider TOKENS".
Remember that "Provider TOKENS" are whatever we pass into the `"provide:"`
- property.  Sometimes we may want the flexibility to use String's or Symbol's
as the "Dependency - Injection" - TOKEN.

//{{{  coffee.module.ts
[source, typescript]
----
// coffee.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

import { CoffeesController } from "./coffees.controller";
import { CoffeesService } from "./coffees.service";
import { Coffee } from "./entities/coffee.entity";
import { Flavor } from "./entities/flavor.entity";
import { Event } from "../events/entities/event.entity";

class MockCoffeesService {}

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    // providers: [{ provide: CoffeesService, useValue: new MockCoffeesService() }],
    providers: [
        CoffeesService,
        { provide: "COFFEE_BRANDS", useValue: ["Salemba brew", "nescafe"] },
    ],
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

Let's say we `"provide: 'COFFEE_BRANDS'"` "String - value token", with
"useValue:[]" that we learned about in previous lesson, and set the *value* to
an *_Array of String's_*.  How could we use this "Provider" in our application
now?

So far we've mostly seen how to "Inject a Provider" using the "standard
constructor based *injection pattern*", like the one below,

//{{{  coffee.service.ts
[source, typescript]
----
// coffee.service.ts
...
...

@Injectable()
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,
        private readonly connection: Connection,
        @Inject("COFFEE_BRANDS") coffeeBrands: string[],    // <<<
    ) {}

    ...
    ...
}
----
//}}}

But, for us to be able to use the standard pattern it's required that the
dependencies is declared with a "Class - name". Because that is how Nest does
a "look up" for the dependency in the Inversion of Control (IoC) - container.

Our "COFFEE_BRANDS" - "custom provider", uses a String value - TOKEN. So how can
inject it?

With these types of providers. We can simply use the `@Inject()` decorator,
which takes a "single argument" being the "TOKEN" that needs to be looked up.

Now we are able to use "COFFEE_BRANDS" and access that Array of values we passed
into this Provider.

It's important to point out here, that while we directly the String
"COFFEE_BRANDS" inside to `@Inject()` decorator, it is a best practice to
"*define Tokens* in a *separate file*", that can be used throughout the
application.  That way we could simply "import" it here in "CoffeesService", and
avoiding costly mistakes such as typos or issues when we need to make changes or
refactor our application in the future.

So let's make a nwe file named `*"coffees.constants.ts"*` in our "/coffee/"
- directory.

In our new file, let's add,

//{{{ coffees.constant.ts
----
export const COFFEE_BRANDS = "COFFEE_BRANDS";
----
//}}}

Now, we can head into both "CoffeesService" and "CoffeesModule" and replace the String we are using,
and import this "COFFEE_BRANDS" - constant instead.

//{{{  coffee.service.ts
[source, typescript]
----
// coffee.service.ts

import { COFFEE_BRANDS } from "./coffees.constants";        // <<<
...
...

@Injectable()
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,
        private readonly connection: Connection,
        @Inject(COFFEE_BRANDS) coffeeBrands: string[],    // <<<
    ) {}

    ...
    ...
}
----
//}}}

//{{{  coffee.module.ts
[source, typescript]
----
// coffee.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

...
...
import { COFFEE_BRANDS } from "./coffees.constants";                        // <<<

class MockCoffeesService {}

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    // providers: [{ provide: CoffeesService, useValue: new MockCoffeesService() }],
    providers: [
        CoffeesService,
        { provide: COFFEE_BRANDS, useValue: ["Salemba brew", "nescafe"] }, // <<<
    ],
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

As you can see, we want to treat these "String Tokens" as you typically would any other "Symbols", "Enums", etc;
and define them in their "OWN - Files", so you can import them wherever they might be needed.

For testing purposes. Let's add a little `*"console.log"*` in our "CoffeesService" - `constructor()`, so we can make sure
it's working properly.

//{{{  coffee.service.ts
[source, typescript]
----
// coffee.service.ts

import { COFFEE_BRANDS } from "./coffees.constants";
...
...

@Injectable()
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,
        private readonly connection: Connection,
        @Inject(COFFEE_BRANDS) coffeeBrands: string[],
    ) {
        console.log(coffeeBrands);          // <<<
    }

    ...
    ...
}
----
//}}}

Let's open up our terminal, and start up our application and when it's finished building we should see
our "Array of String" show up.

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
[Nest] 297374   - 03/30/2021, 6:09:50 PM   [NestFactory] Starting Nest application...
[Nest] 297374   - 03/30/2021, 6:09:50 PM   [InstanceLoader] TypeOrmModule dependencies initialized +72ms
[Nest] 297374   - 03/30/2021, 6:09:50 PM   [InstanceLoader] AppModule dependencies initialized +0ms
[Nest] 297374   - 03/30/2021, 6:09:50 PM   [InstanceLoader] TypeOrmCoreModule dependencies initialized +91ms
[Nest] 297374   - 03/30/2021, 6:09:50 PM   [InstanceLoader] TypeOrmModule dependencies initialized +0ms
[ 'Salemba brew', 'nestcafe' ] 		// <<<
...
...
----
//}}}

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 6 == Class Based Provider
[[_class_based_provider]]
== Class Based Provider

Another custom "Provider Pattern" is the `"useClass"` - syntax. `"useClass"`
allows us to dynamically determine a Class that a Token should resolve to.

Let's take for example, that we have an *_abstract_* or default "ConfigService"
- Class, and depending on the "current - environment", we need Nest to provide
a different implementation of that "configuration - Service" for each one.

Just like before, we'll provide our "ConfigService" for the "Provider - Token".
But for the value, we'll use the new "useClass" - syntax.

Let's open our "CoffeesModule" file, and make some changes to the code,

//{{{  coffee.module.ts
[source, typescript]
----
// coffee.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

...
...
import { COFFEE_BRANDS } from "./coffees.constants";

class ConfigService {} 			// <<<
class DevelopmentConfigService {} 	// <<<
class ProductionConfigService {} 	// <<<
// class MockCoffeesService {} 		// <<<

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    providers: [
        CoffeesService,
        {
            provide: ConfigService,
            useClass: process.env.NODE_ENV === "development" ? DevelopmentConfigService : ProductionConfigService,
        },
        {
            provide: COFFEE_BRANDS, useValue: ["Salemba brew", "nestcafe"]
        }
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

First, let's define some - "classes" that we can use for illustration purpose.

Since we want our "ConfigService" to be different depending on the
"environment", we are going to look an example use-case, where we check the
process `*"env"*` - variable (`"NODE_ENV"`, in this demonstration) to decide
which Class to implement.

Now depending on what our `"NODE_ENV"` is, "ConfigService" will resolve to
either "DevelopmentConfigService" or "ProductionConfigService".

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 6 == Factory Based Provider
[[_factory_based_provider]]
== Factory Based Provider

Our next "Custom Provider" - pattern is `"useFactory"`. Which is a very common
and helpful pattern you will surely use many times in your application.

The `"useFactory"` - syntax allows us to create "Providers - *dynamically*", which can
be extremely useful if you need to base the "Provider's - value" on various other
"dependencies", "value", etc..

The "value" *returned* from the "factory - function" is, what will be used by
the "Provider Token". What makes these "factory - function" so special, is that they
themselves can "*inject OTHER - providers*" needed to compute the returning result.

Let's look at the "COFFEE_BRANDS" - Provider we used in the previous lesson, and
convert it to `"useFactory"`.

//{{{  coffee.module.ts
[source, typescript]
----
// coffee.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

...
...
import { COFFEE_BRANDS } from "./coffees.constants";

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    providers: [
        CoffeesService,
        {
            provide: COFFEE_BRANDS, useFactory: () => ["Salemba brew", "nestcafe"]    // <<<
        }
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

Let's star out by making it a function that simply returns the Array of String's
we previously had.

For testing purposes, let's make sure we still have that `console.log()` in our "CoffeesService" here,
so we can it's working properly.

Let's open up our terminal with our application running, and we should see our Array of String still show up.

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
[Nest] 562972   - 03/30/2021, 9:18:41 PM   [NestFactory] Starting Nest application...
[Nest] 562972   - 03/30/2021, 9:18:41 PM   [InstanceLoader] TypeOrmModule dependencies initialized +74ms
[Nest] 562972   - 03/30/2021, 9:18:41 PM   [InstanceLoader] AppModule dependencies initialized +0ms
[Nest] 562972   - 03/30/2021, 9:18:41 PM   [InstanceLoader] TypeOrmCoreModule dependencies initialized +112ms
[Nest] 562972   - 03/30/2021, 9:18:41 PM   [InstanceLoader] TypeOrmModule dependencies initialized +1ms
[ 'Salemba brew', 'nestcafe' ]

...
...
----
//}}}

Pretty straightforward, but we haven't taken full advantage of "Factory - Providers" yet.

Let's look at more realistic example, and inject some "providers" into it.

First, let's define a "random - Providers" for illustration purposes and make sure
to register it as "Providers".

//{{{  coffee.module.ts
[source, typescript]
----
// coffee.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

...
...
import { COFFEE_BRANDS } from "./coffees.constants";

@Injectable()
export class CoffeeBrandsFactory {
    create() {
        /* -- do something here --*/

        return ["Salemba nrew", "nestcafe"];
    }
}

@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    providers: [
        CoffeesService,
        CoffeeBrandsFactory,
        {
            provide: COFFEE_BRANDS,
            useFactory: (brandsFactory: CoffeeBrandsFactory) => brandsFactory.create(),
            inject: [CoffeeBrandsFactory],
        }
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

Now, let's update our existing "COFFEE_BRANDS" - Provider to use the "CoffeeBrandsFactory".

[source, typescript]
----
inject: [CoffeeBrandsFactory],
----

In this code, we can see that we are using a new property for our `"providers:[]"`
called `*"inject"*`. `*"inject"*` takes in an Array of Providers itself. These providers
get passed into our `"useFactory"` - function, and we can use them however we would like.

[source, typescript]
----
useFactory: (brandsFactory: CoffeeBrandsFactory) => ["Salemba brew", "nestcafe"]
----

This is just demonstration code of course, but you can see we have a "CoffeeBrandsFactory" that
we are injecting into our "useFactory" - function and calling a method on it.

Although this is all pseudo code. What's important here is, just knowing that you can use
your Dependencies here. Doing whatever type of "business - logic" you need, and
letting you return whatever value you want, for this providers.

//}}}


//**⬆xref:_table_of_contents[back to top]**
