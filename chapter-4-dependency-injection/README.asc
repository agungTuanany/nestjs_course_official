//{{{ ** ASCIIDOC HEADER
:description:   nestjs official course | chapter-4
:url-repo:      https://github.com/agungTuanany/nestjs_course_official
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Mon Mar 29 11:39:39 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
//}}}

[[_chapter_4_dependency_injection]]
= Chapter-4 Dependency Injection
:figure-caption!:
:source-highlighter: highlight.js

//{{{== Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_understanding_dependency_injection[Understanding Dependency Injection]
|====
//}}}

//{{{ 1 == Understanding Dependency Injection
[[_understanding_dependency_injection]]
== Understanding Dependency Injection
:fn-transitive_dependencies: footnote:[When an indirect relationship causes functional dependency is called "Transitive - Dependencies"]
:fn-dependencies_graph: footnote:[In mathematics, computer science and digital electronics, a dependency graph is a directed graph representing dependencies of several objects towards each other. It is possible to derive an evaluation order or the absence of an evaluation order that respects the given dependencies from the dependency graph. https://en.wikipedia.org/wiki/Dependency_graph]



//{{{ image::./images/chapter-4-1.png
[#img-chapter]
[link=./images/chapter-4-1.png]
.Before we get started
image::./images/chapter-4-1.png[align="center"]
//}}}

Dependency Injection is a technique where we delegated instantiation of
dependencies, to an *"inversion of control"* (IoC) - container. In our case this
"*IoC*" - container is the NestJS runtime system itself.

//{{{ image::./images/chapter-4-2.png
[#img-chapter]
[link=./images/chapter-4-2.png]
.How Dependencies Injection works.
image::./images/chapter-4-2.png[align="center"]
//}}}

NestJS handles all the heavy lifting here, instead of trying to achieve
Dependency Injection ourselves.  Essentially when we *"ask"* for a dependency in
a *class - "constructor"*. NestJS handles and retrieves the Object - BACK to us,
along with any dependencies it might require, and so on and so on...


Let's take a look an example in our own code, and dive into how it all works.

//{{{ coffee.controller.ts
[source, typescript]
----
// coffee.controller.ts
@Controller("coffees")
export class CoffeesController {
    constructor(private readonly coffeesService: CoffeesService) {}     //<<<

    ...
    ...
}
----
//}}}

In our "CoffeeController" When we are using "CoffeesService" and injecting it here
in our `"constructor()"`; What is exactly is happening in NestJS under the hoood,
to make all of this work?.

Well, there are "3" - keys steps in the Dependency Injection process - that make it hall happen.

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
@Injectable() // <<<
export class CoffeesService {
    ...
    ...
}
----
//}}}

- *First*, in our "CoffeesService" - the `@Injectable()" decorator declares
  a "class" that can be managed by the Nest "container". This decorator marks
  the "CoffeesService" - class as a *"Provider"*.

//{{{ coffee.controller.ts
[source, typescript]
----
// coffee.controller.ts
@Controller("coffees")
export class CoffeesController {
    constructor(private readonly coffeesService: CoffeesService) {}
    //                                  ^^           ^^
    ...
    ...
}
----
//}}}

- *Second*, if we jump to our "CoffeeController". We can see we are requesting the
  "CoffeesService" in our "constructor". This (`"coffeesService: CoffeesService"`) request
  tells Nest to "inject" the *"Provide"* into our "controller()" - class, so that
  we may able to utilize it.

//{{{ coffee.module.ts
[source, typescript]
----
// coffee.module.ts
@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],       // <<<
    providers: [CoffeesService],            // <<<
})
export class CoffeesModule {}
----
//}}}

- *Lastly*, Nest is aware that this class ("CoffeeController") also
  a "Provider", because we've include here in our "CoffeesModule", which
  registers this "Provider" with Nest - "Inversion of Control" - container.

That's how it al works in our code itself. But now let's dive even deeper to see
what Nest does.

//{{{ image::./images/chapter-4-3.png
[#img-chapter]
[link=./images/chapter-4-3.png]
.Dive deep into Dependency Injection
image::./images/chapter-4-3.png[align="center"]
//}}}

When the Nest - container instantiates the "CoffeesController". It first looks
to see if there are-any-dependencies *"needed"*. In our case, there is one, the
"CoffeesService".

When the Nest - container finds the "CoffeesService" - dependencies, it performs
a *"lookup"* on the *"CoffeesService" - token*, which return the
"CoffeesService" - class.

Assuming this "Provider" has a "singleton" - scope, which is the default
behavior of "Injectable - Providers".  Nest will either *create an instance* of
"CoffeesService", *"cache it"* and *"return it"* or if one is-already - cached,
it will return *that* existing - instance.

We are simplifying everything a bit, but hopefully this all helps illustrate the
point.

Analyzing our codebase  for dependencies: is *quite the complex task*, that Nest
handles for us, and it "ALL" happens during "Application Bootstrapping".

This "dependencies - analysis" for creating the "Dependency Graph" is
transitive{fn-transitive_dependencies}.

In this example, if the "CoffeesService" itself has dependencies (which is does).
*Those* dependencies *_need_* to be resolved as well.

//{{{ coffee.service.ts
[source, typescript]
----
// coffee.service.ts
@Injectable() // <<<
export class CoffeesService {

    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,      // It's need to be resolved
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,      // It's need to be resolved
        private readonly connection: Connection,                    // It's need to be resolved
    ) {}
}
----
//}}}

The "Dependencies - Graph{fn-dependencies_graph}" ensures that Dependencies are
resolved in the CORRECT ORDER, or essentially that they are resolved from the
"bottom - up (^)".

This mechanism relieves the developer from having to manage such "complex
- Dependency Graph".

All right, enough theory for now!.

Let's take a closer look at the `@Module()` - decorator.

//{{{ coffee.module.ts
[source, typescript]
----
// coffee.module.ts
@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],       // <<<
    providers: [CoffeesService],            // <<<
})
export class CoffeesModule {}
----
//}}}

In our "CoffeesModule" we declared "[CoffeesService]" in our `"provides[]"`
Array.  So far we've supplied all of our "Providers" by a list of "class
- name".  But in fact!, these syntax is actually a shorthand - version of the
more complex syntax.

//{{{ coffee.module.ts
[source, typescript]
----
// coffee.module.ts
@Module({
    imports: [TypeOrmModule.forFeature([Coffee, Flavor, Event])],
    controllers: [CoffeesController],
    providers: [                        // <<<
        {
            provide: CoffeeService,             // <<<
            useClass: CoffeeService.            // <<<
        },
    ],
})
export class CoffeesModule {}
----
//}}}

Now that we see this explicit construction. We can start to understand the
"Dependencies - Registration process".

With this complete syntax. We can see that we are clearly associating the TOKEN,
"CoffeesService" with the class "CoffeesService". The shorthand notation is
merely a convenience to simplify the most common use-case, where the TOEKN used
to "request an instance of a class", *comes by the same name".

Later on in this chapter, we'll be looking at other useful ways to provide
*"alternative values"* and other Dependency Injection *"tips"* and *"tricks"*.

**⬆xref:_table_of_contents[back to top]**
//}}}

//**⬆xref:_table_of_contents[back to top]**
