//{{{ ** ASCIIDOC HEADER
:description:   SRS 7Express
:url-repo:      https://my-git-repo.com
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Sat Mar 20 07:46:12 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
//}}}

= Chapter-1 Getting Started with nestJS
:figure-caption!:

[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_uc-00:_nestjs_introduction[nestJS Introduction]
|====

//**⬆xref:_use_case_number_specification[back to top]**

[[_nestjs_introduction]]
== NestJS Introduction

[#img-chapter]
[link=./images/chapter-1-0.png]
.Official NestJS
image::./images/chapter-1-0.png[align="center"]

In this course we are going to be covering the NestJS framework from top to
bottom, getting you up to speed and creating Enterprise-grade NodeJS applications
with the help of NestJS, in no-time.

Almost everything we are going to be looking at, learning, and building in this
course will be incremental.

By the end, you will have somewhat *real world application*, and be ready to
fully take advantage of the NestJS framework; even using it as a great jumping
off point for your future application.

[#img-chapter]
[link=./images/chapter-1-1.png]
.NestJS Introduction
image::./images/chapter-1-1.png[align="center"]

Before we dive into exactly what what NestJS is, let's take a step back and look
at the NodeJS ecosystem as a _whole_. NodeJS makes no assumption and includes
almost nothing by default, for it's purposely meant to be very *bare bones*.

NodeJS by design has a minimalistic setup, and developers are in charge of
setting up *_everything_* they want to use for their application.

With this situation, using NodeJS is, have applies to everything form how you
handle _routing_, _API calls_, _setting up WebSockets_, to even
rudimentary things like, _code organization_, _file structure_, and
_naming conventions_.

As NodeJS has been around for may years, and there are plenty of framework that
have helped make some of these requirements simpler, most notably ExpressJS; But
they all *still* require A LOT of configuration and effort on the part of the
developer.

This *ultimately flexibility* can be a bit of a double edged sword. Creating
potential problems as applications or teams grow very large. NestJS tries to
tackle some of these problems by creating an *_abstraction_* or overall
framework around NodeJS; by letting you *_focus on the application problems_* at
hand instead of the tiny implementation details such as, _setting up TypeScript_,
_API routing_, _Error handling_, _middleware setup_, and so on so much more.

NestJS provides an out of the box application architecture that allows developers
and to create _highly testable_, _scalable_, _loosely coupled_, and _easily
maintainable application_.

[#img-chapter]
[link=./images/chapter-1-2.png]
.NestJS pros
image::./images/chapter-1-2.png[align="center"]

But, how is this achieved?

Think of _NestJS as a *layer* above NodeJS itself_, *abstracting away* _difficult
tasks_, _tools_, and _boilerplate code_, while also *adding a full fledged
toolkit* for your application development.

Using NestJS does *not lock you into yet another framework*,

[#gif-chapter]
[link=./images/gif/chapter-1-1.png]
.How NestJS works?
image::./images/gif/chapter-1-1.png[align="center"]

// XXX TODO: move footnote onto single file XXX
:fn-readily: footnote:[utilize easily]
:fn-prominent: footnote:[substantial]
:fn-platform_agnostic: footnote:[Platform agnostic is a concept that refers to the design attributes and philosophies of software products. A platform agnostic product runs equally well across more than one platform.]
:fn-dependency_injection: https://docs.nestjs.com/providers#dependency-injection

But instead leverages readily{fn-readily} available and
prominent{fn-prominent} options and modules in the community, like those
available in ExpressJS applications.

One interesting to note is, that NestJS can even be swapped to use "Fastify"
under the hood instead of ExpressJS (which is used by default).

Just keep in mind, that you may need to use different Fastify compliant library
in your application if you do this.

The flexibility that NestJS provides here, gives us the ability to create modules
that are platform-agnostic{fn-platform_agnostic} not only to HTTP frameworks such
as ExpressJS or Fastify but even agnostic across different types of applications.

[#img-chapter]
[link=./images/chapter-1-4.png]
.NestJS props
image::./images/chapter-1-4.png[align="center"]

With NestJS you can build *REST-API's*, *MVC applications*, *micro services*, *GraphQL
applications*, *WebSockets*, and even *CLI's and Cron jobs*.

With the help of the NestJS {fn-dependency_injection}[dependency injection
system]; We have the ability to swap out the underlying mechanisms effortlessly.

In this course, we are going to be focusing on _creating a *real world example
REST-API application_*, utilizing and learning about all the great NestJS features,
along the way.

By the time we finish, you will be ready to tackle any challenge with NestJS.

**⬆xref:_table_of_contents[back to top]**
