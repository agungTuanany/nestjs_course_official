//{{{ ** ASCIIDOC HEADER
:description:   nestjs official course | chapter-8
:url-repo:      https://github.com/agungTuanany/nestjs_course_official
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Thu Apr 15 08:51:39 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
//}}}

[[_chapter_9_mongodb_with_mongoose]]
= Chapter-9 MongoDB with Mongoose
:figure-caption!:
:source-highlighter: highlight.js

//{{{== Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_before_we_get_started[Before We Get Started]
| 2.    | xref:_prerequisite_instal_docker[Prerequisite Install Docker]
| 3.    | xref:_running_mongodb[Running MongoDB]
|====
//}}}

//{{{ 1 == Before We Get Started
[[_before_we_get_started]]
== Before We Get Started
:fn-link_chapter2: link:../chapter-2-creating-rest-api-application/README.asc

//{{{ image::./images/chapter-9-1.png
[#img-chapter]
[link=./images/chapter-9-1.png]
.Before We Get Started
image::./images/chapter-9-1.png[align="center"]
//}}}

NOTE: This section is a continuation of Chapter-Two.

Before we get started, all of the code used in this entire Mongo - section of
this course is based on the code we've created in {fn-link_chapter2}["Chapter-2:
Creating a Rest API application"].

We are doing this so we can see and easily compare how an application can
leverage either NoSQL or SQL in implementing similar features with NestJS.

By fracturing these NoSQL and SQL sections, you can easily choose and watch
whichever section you need for your project.

//{{{ image::./images/chapter-9-2.png
[#img-chapter]
[link=./images/chapter-9-2.png]
.Before We Get Started
image::./images/chapter-9-2.png[align="center"]
//}}}

If you save your code form Chapter-2. Make sure to switch back to that branch,
if you want to code along with us.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 2 == Prerequisite: Instal Docker
[[_prerequisite_instal_docker]]
== Prerequisite: Instal Docker
:fn-docker_compose_install: footnote:[https://docs.docker.com/compose/install/]
:fn-docker_compose_doc: footnote:[https://docs.docker.com/compose/]

//{{{ image::./images/chapter-9-3.png
[#img-chapter]
[link=./images/chapter-9-3.png]
.Prerequisite
image::./images/chapter-9-3.png[align="center"]
//}}}

Docker is a platform for developers to: Build, Run, and Share applications that
are within containers. The use of containers to deploy applications is called
*_containerization_*. Containerization has become increasingly popular over
years due to many benefits they bring to the development process.

//{{{ image::./images/chapter-9-4.png
[#img-chapter]
[link=./images/chapter-9-4.png]
.Benefit Containerization with Docker
image::./images/chapter-9-4.png[align="center"]
//}}}

Let's go over a few key benefits. Container are:

- *Flexible*,
- *Lightweight*,
- *Portable*, meaning you can build them locally, deploy to the cloud and run
  anywhere.
- *Loosely - Coupled*, this means that containers are highly self-sufficient and
  encapsulated. Allowing them to be replaced or upgraded, without disrupting any
  other containers.

//{{{ image::./images/chapter-9-5.png
[#img-chapter]
[link=./images/chapter-9-5.png]
.Benefit Containerization with Docker
image::./images/chapter-9-5.png[align="center"]
//}}}

There are many other great benefits to containerization and Docker, but
hopefully you get the idea so far.

*Fundamentally* a container is, just a running process with some added
encapsulation features applied to it. This helps keep the container isolated
from the host and other container.

In this course, we'll be using docker to set up a database locally on your
machine. If you do not have Docker installed already, go ahead and pause in
second and check out installation instructions on the official
https://docker.com[docker - website].

//{{{ image::./images/chapter-9-6.png
[#img-chapter]
[link=./images/chapter-9-6.png]
.Benefit Containerization with Docker
image::./images/chapter-9-6.png[align="center"]
//}}}

In addition to Docker, we'll be utilizing *_Docker Compose_*.
`"docker-compose"` is, a tool for defining and running *_multiple container_*
Docker applications.  With *Docker - Compose*, you can use a YAML - file to
configure our *_application - services_*. If you're not familiar with YAML,
don't worry, we'll briefly cover how we'll be setting up the file, but it's
nothing too intimidating.

Once we have all this things set up, with just single command, we can create and
start all the services from our configuration on any machine. Docker is going to
make working with our application _that much simpler_ in the future, not just
for us, but also for other developers, different machines, and can even help us
quickly set up our application in the cloud.

For Mac and Windows users, *Docker - Compose* is includes out of the box with
Docker. But if you're on Linux, there are a few additional steps you'll need to
do in order to get *Docker - Compose* installed{fn-docker_compose_install}.

Make sure to check the *Docker - Compose _documentation_*{fn-docker_compose_doc}
for more information.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 3 == Running MongoDB
[[_running_mongodb]]
== Running MongoDB

All right, so now we now had Docker installed, make sure that you have it
running on you machine before continuing.

Until now we've created a mock data resource for our "CoffeesService". Let's
take it up a notch and use a real database so we can really take our application
to the next level.

In this chapter we are using MongoDB, which is a popular "document oriented
NoSQL" database.

In the past we may have gone to the MongoDB website and installed the database
locally on our machines. But let's take advantage of Docker to handle all of
this for us.

Let's use the "docker-compose" - tool and it's "YAML" - file to set everything
up that our application needs.

First let's create a "docker-compose.yml" - file in the root directory. Then
let's define a database container in YAML - format.

YANL is an interseting configuration file in that *"space indentation"* and
*"dashes"* all matter and do something.  If you want to learn more about YAML.
Please check out link:https://yaml.org[yaml.org]

//{{{ // docker-compose.yml
[source, yaml]
----
# docker-compose.yml
version: "3"

  service:
    db:
      image: mongo
      restart: always
      ports:
        - 27017:27017
      environment:
        MONGODB_DATABASE: nest-course
----
//}}}

There is a lot here. If you look down below the course video, you will be able
to copy what you need for this file.

The most important pieces here are, that we have `*"db"*` - *service*, that is
using the Docker "image" of "Mongo".

A "Docker - *images*" is, just a multilayered file, that will execute code
within our "Docker - *container*".  In this case it will be creating a "Mongo"
- database.

Next up we have *"ports"*. We can see that we'll be using the default port for
MongoDB of `*"27017"*`, but notice the colon `" : "` and the *same port* again.
This indicate to Docker, that internally within the "container", it should have
the database setup on *"PORT 27017"*; and also we have it accessible outside of
Docker on the same port as well.

This actually lets us be able to access this database, that's inside a "Docker
- container", outside the "container" on our current machine.

Lastly we setup a *name" for our database which we are calling `*"nest-course"*.


I know all of that might seem like a lot but with all of that in place. We can
use the "docker-compose" - CLI to run the `*"_db"_ - service*` effortlessly
- with one command.

Let's bring our container up using "docker-compose".  In our terminal let's
enter:

//{{{
[script, shel]
----
docker-compose up -d
Creating network "iluvcoffe_default" with the default driver
Creating iluvcoffe_db_1 ... done
----
//}}}

The `"-d"` - flag means that we wnat to run "containers" in *detached mode*.
Meaning that they are running in the background.

We only have one "service* listed in our "docker-compose.yml" - file but for
a future reference: If you have other *"services"* here and wanted to run
specific one, you can pass the *"name"* of the service you want to run by
entering the name of it.

//{{{ docker-compose up db -d
[script, shel]
----
docker-compose up db -d
                 ~~~~
----
//}}}

Just remember that when you pass nothing. "docker-compose" will spawn all of
the services defined.

**⬆xref:_table_of_contents[back to top]**
//}}}
