//{{{ ** ASCIIDOC HEADER
:description:   nestjs official course | chapter-8
:url-repo:      https://github.com/agungTuanany/nestjs_course_official
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Thu Apr 15 08:51:39 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
//}}}

[[_chapter_9_mongodb_with_mongoose]]
= Chapter-9 MongoDB with Mongoose
:figure-caption!:
:source-highlighter: highlight.js

//{{{== Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_before_we_get_started[Before We Get Started]
| 2.    | xref:_prerequisite_instal_docker[Prerequisite Install Docker]
| 3.    | xref:_running_mongodb[Running MongoDB]
| 4.    | xref:_creating_a_mongoose_model[Creating a Mongoose Model]
| 5.    | xref:_using_a_mongoose_model[Using a Mongoose Model]
|====
//}}}

//{{{ 1 == Before We Get Started
[[_before_we_get_started]]
== Before We Get Started
:fn-link_chapter2: link:../chapter-2-creating-rest-api-application/README.asc

//{{{ image::./images/chapter-9-1.png
[#img-chapter]
[link=./images/chapter-9-1.png]
.Before We Get Started
image::./images/chapter-9-1.png[align="center"]
//}}}

NOTE: This section is a continuation of Chapter-Two.

Before we get started, all of the code used in this entire Mongo - section of
this course is based on the code we've created in {fn-link_chapter2}["Chapter-2:
Creating a Rest API application"].

We are doing this so we can see and easily compare how an application can
leverage either NoSQL or SQL in implementing similar features with NestJS.

By fracturing these NoSQL and SQL sections, you can easily choose and watch
whichever section you need for your project.

//{{{ image::./images/chapter-9-2.png
[#img-chapter]
[link=./images/chapter-9-2.png]
.Before We Get Started
image::./images/chapter-9-2.png[align="center"]
//}}}

If you save your code form Chapter-2. Make sure to switch back to that branch,
if you want to code along with us.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 2 == Prerequisite: Instal Docker
[[_prerequisite_instal_docker]]
== Prerequisite: Instal Docker
:fn-docker_compose_install: footnote:[https://docs.docker.com/compose/install/]
:fn-docker_compose_doc: footnote:[https://docs.docker.com/compose/]

//{{{ image::./images/chapter-9-3.png
[#img-chapter]
[link=./images/chapter-9-3.png]
.Prerequisite
image::./images/chapter-9-3.png[align="center"]
//}}}

Docker is a platform for developers to: Build, Run, and Share applications that
are within containers. The use of containers to deploy applications is called
*_containerization_*. Containerization has become increasingly popular over
years due to many benefits they bring to the development process.

//{{{ image::./images/chapter-9-4.png
[#img-chapter]
[link=./images/chapter-9-4.png]
.Benefit Containerization with Docker
image::./images/chapter-9-4.png[align="center"]
//}}}

Let's go over a few key benefits. Container are:

- *Flexible*,
- *Lightweight*,
- *Portable*, meaning you can build them locally, deploy to the cloud and run
  anywhere.
- *Loosely - Coupled*, this means that containers are highly self-sufficient and
  encapsulated. Allowing them to be replaced or upgraded, without disrupting any
  other containers.

//{{{ image::./images/chapter-9-5.png
[#img-chapter]
[link=./images/chapter-9-5.png]
.Benefit Containerization with Docker
image::./images/chapter-9-5.png[align="center"]
//}}}

There are many other great benefits to containerization and Docker, but
hopefully you get the idea so far.

*Fundamentally* a container is, just a running process with some added
encapsulation features applied to it. This helps keep the container isolated
from the host and other container.

In this course, we'll be using docker to set up a database locally on your
machine. If you do not have Docker installed already, go ahead and pause in
second and check out installation instructions on the official
https://docker.com[docker - website].

//{{{ image::./images/chapter-9-6.png
[#img-chapter]
[link=./images/chapter-9-6.png]
.Benefit Containerization with Docker
image::./images/chapter-9-6.png[align="center"]
//}}}

In addition to Docker, we'll be utilizing *_Docker Compose_*.
`"docker-compose"` is, a tool for defining and running *_multiple container_*
Docker applications.  With *Docker - Compose*, you can use a YAML - file to
configure our *_application - services_*. If you're not familiar with YAML,
don't worry, we'll briefly cover how we'll be setting up the file, but it's
nothing too intimidating.

Once we have all this things set up, with just single command, we can create and
start all the services from our configuration on any machine. Docker is going to
make working with our application _that much simpler_ in the future, not just
for us, but also for other developers, different machines, and can even help us
quickly set up our application in the cloud.

For Mac and Windows users, *Docker - Compose* is includes out of the box with
Docker. But if you're on Linux, there are a few additional steps you'll need to
do in order to get *Docker - Compose* installed{fn-docker_compose_install}.

Make sure to check the *Docker - Compose _documentation_*{fn-docker_compose_doc}
for more information.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 3 == Running MongoDB
[[_running_mongodb]]
== Running MongoDB

All right, so now we now had Docker installed, make sure that you have it
running on you machine before continuing.

Until now we've created a mock data resource for our "CoffeesService". Let's
take it up a notch and use a real database so we can really take our application
to the next level.

In this chapter we are using MongoDB, which is a popular "document oriented
NoSQL" database.

In the past we may have gone to the MongoDB website and installed the database
locally on our machines. But let's take advantage of Docker to handle all of
this for us.

Let's use the "docker-compose" - tool and it's "YAML" - file to set everything
up that our application needs.

First let's create a "docker-compose.yml" - file in the root directory. Then
let's define a database container in YAML - format.

YANL is an interseting configuration file in that *"space indentation"* and
*"dashes"* all matter and do something.  If you want to learn more about YAML.
Please check out link:https://yaml.org[yaml.org]

//{{{ // docker-compose.yml
[source, yaml]
----
# docker-compose.yml
version: "3"

  service:
    db:
      image: mongo
      restart: always
      ports:
        - 27017:27017
      environment:
        MONGODB_DATABASE: nest-course
----
//}}}

There is a lot here. If you look down below the course video, you will be able
to copy what you need for this file.

The most important pieces here are, that we have `*"db"*` - *service*, that is
using the Docker "image" of "Mongo".

A "Docker - *images*" is, just a multilayered file, that will execute code
within our "Docker - *container*".  In this case it will be creating a "Mongo"
- database.

Next up we have *"ports"*. We can see that we'll be using the default port for
MongoDB of `*"27017"*`, but notice the colon `" : "` and the *same port* again.
This indicate to Docker, that internally within the "container", it should have
the database setup on *"PORT 27017"*; and also we have it accessible outside of
Docker on the same port as well.

This actually lets us be able to access this database, that's inside a "Docker
- container", outside the "container" on our current machine.

Lastly we setup a *name" for our database which we are calling `*"nest-course"*.


I know all of that might seem like a lot but with all of that in place. We can
use the "docker-compose" - CLI to run the `*"_db"_ - service*` effortlessly
- with one command.

Let's bring our container up using "docker-compose".  In our terminal let's
enter:

//{{{
[script, shel]
----
docker-compose up -d
Creating network "iluvcoffe_default" with the default driver
Creating iluvcoffe_db_1 ... done
----
//}}}

The `"-d"` - flag means that we wnat to run "containers" in *detached mode*.
Meaning that they are running in the background.

We only have one "service* listed in our "docker-compose.yml" - file but for
a future reference: If you have other *"services"* here and wanted to run
specific one, you can pass the *"name"* of the service you want to run by
entering the name of it.

//{{{ docker-compose up db -d
[script, shel]
----
docker-compose up db -d
                 ~~~~
----
//}}}

Just remember that when you pass nothing. "docker-compose" will spawn all of
the services defined.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 4 == Introducing the Mongoose Module
[[_introducing_the_mongoose_module]]
== Introducing the Mongoose Module

Nest itself is *"database agnostic"*. Allowing you to easily integrate with any
SQL or NoSQL -- database of your choice.

There are a lot different ways you can integrate Nest with databases, and they
all depend on your personal preferences or projects needs.

For this chapter we'll use the most popular MongoDB - *"object modelling tool"*
called Mongoose.

To get started with Mongoose. Let's get necessary dependencies installed for our
application. We'll need to install `"mongoose"` itself, as well as
`"@nestjs/mongoose"` which helps integrate the two.

//{{{ $ npm i mongoose @nestjs/mongoose
[source, shell]
----
$ npm i mongoose @nestjs/mongoose
----
//}}}

Also for better "Type - safety". Let's install Mongoose typescript definitions
as a "dev" dependencies.

//{{{ $ npm i -D @types/mongoose
[source, shell]
----
$ npm i -D @types/mongoose
----
//}}}

We will continue ahead as we already have these installed. But if you are
following along, just pause a second and comeback when it's finished.

All right, so you can see we have Mongoose itself, along with "TypeScript
- definitions" for it, as well as the `@nestjs/mongoose"` - package which helps
simplify Nest integration with Mongoose.

This package ships with a set of useful decorators and the *"MongooseModule"*.
Which allows us ti connect our application to Mongo effortlessly.

Once the installation process is complete. Let's get Mongoose setup in our
"iluvcoffe" - app.

Let's open up our "AppModule" - file, and head over to the `"imports:"` Array.
Adding `"MongooseModule"` which accepts a database "connection URI" - String,
where our Mongo database located, and as a second argument a configuration
- Object that gets passed through to the Mongoose connect - method itself.

//{{{ app.module.ts
[source, typescript]
----
// app.module.ts
import { Module } from "@nestjs/common";
import { MongooseModule } from "@nestjs/mongoose";

import { AppController } from "./app.controller";
import { AppService } from "./app.service";
import { CoffeesModule } from "./coffees/coffees.module";

@Module({
    imports: [CoffeesModule,
        MongooseModule.forRoot("mongodb://localhost:27017/nest-course"),
    ],
    controllers: [AppController],
    providers: [AppService],
})
export class AppModule {}
----
//}}}

You can see we are using the standard "MongoDB - URI" - scheme of
`"mongodb://localhost"` (and the port we set up in "docker-compose.yml" - file,
which was `"27017"`, followed by a slash `" / "` and our MongoDB database name
which we set to be `"nest-course"`).

We don't need to pass any configuration options to Mongoose, so we are not going
to pass the *second - parameter*.

We are all set.

Now let's open up a terminal and start the application in *development* - mode.

//{{{ npm run start:dev
[source, shell]
----
$ npm run start:dev
[Nest] 3712922   - 04/18/2021, 7:33:48 PM   [NestFactory] Starting Nest application...
[Nest] 3712922   - 04/18/2021, 7:33:48 PM   [InstanceLoader] MongooseModule dependencies initialized +54ms
							     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Nest] 3712922   - 04/18/2021, 7:33:48 PM   [InstanceLoader] AppModule dependencies initialized +0ms
...
...
----
//}}}

If we look carefully we should see `"MongooseModule  depend intiliazed"`,
meaning we have successfully established a connection to our "Docker Mongo"
- database

If you having any issues setting up "MongooseModule" here. Make sure that Docker
is runnig with `$ "docker-compose up -d"`.

Also make sure the "db - name" inside your `"MongooseModule.forRott()"` matches
what you have in your "docker-compose.yml" - file.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 5 == Creating a Mongoose Model
[[_creating_a_mongoose_model]]
== Creating a Mongoose Model

//{{{ image::./images/chapter-9-7.png
[#img-chapter]
[link=./images/chapter-9-7.png]
.Creating A Mongoose Model
image::./images/chapter-9-7.png[align="center"]
//}}}

One of the most vital concepts in MongoDB is, the idea of *"data - models"*.

//{{{ image::./images/chapter-9-8.png
[#img-chapter]
[link=./images/chapter-9-8.png]
.Creating A Mongoose Model
image::./images/chapter-9-8.png[align="center"]
//}}}

These *models* are responsible for *"Creating"*, *"Reading"*, and *"Deleting"*
- documents from the Mongo - database.

If you are coming from SQL background, one thing to remember about Mongo
- databases is, that these *documents* are being stored in *_"collections"_*,
*NOT* *"tables"*.

//{{{ image::./images/chapter-9-9.png
[#img-chapter]
[link=./images/chapter-9-9.png]
.Creating A Mongoose Model
image::./images/chapter-9-9.png[align="center"]
//}}}

To create a Mongoose - *Model*. We first have to define a *Schema definition*
for it.  Every "schema" we create *maps* to a MongoDB - *collections* and
defines the shape of the *documents* within that *collection*.

These "Schemas" ca be created with NestJS - decorators or even with Mongoose
itself manually.  Whatever works best for you.

In this course we'll be using Nest - decorators to create a *schemas*.
Since they are much easier to make, greatly reduced boilerplate, and improve
overall code readability.

So let's get started and create our first MongoDB - Model and Schema.

Let's head over to our mock - "Coffee - Entity", and set it up NestJS
- Mongoose.

//{{{ coffee.entity.ts
[source, typescript]
----
// coffee.entity.ts
import { Schema } from "@nestjs/mongoose";

@Schema()
export class Coffee {
    id: number;
    name: string;
    brand: string;
    flavors: string[];
}
----
//}}}

First, let's add the new `"@Schema()"` - decorator on top, making sure to import
it from `"@nestjs/mongoose"`.

This `"@Schema()"` - decorator *maps* our Coffee - class to our MongoDB
- *collection* of the same name, but we have an additional `*"s"*` at the end.
So the final Mongo - *collection* name will be `*"coffees"`.

Mongo automatically makes all *"collections"* *plural* and *lowercase* by
default.  So keep that in mind when naming your *"Schema"* - classes.

With that setup. Now we can start defining the properties of our "Coffee
- Schema".

To define properties. All we need to do is use a `"Prop()"` - decorator. Before
we use this new decorator. Let's remove the `"id"` - property form our class,
since we won't need it anymore.

//{{{ coffee.entity.ts
[source, typescript]
----
// coffee.entity.ts
import { Schema, Prop, SchemaFactory } from "@nestjs/mongoose";
import { Document } from "mongoose";

@Schema()
export class Coffee extends Document {
    @Prop()
    name: string;

    @Prop()
    brand: string;

    @Prop([String])
    flavors: string[];
}

export const CoffeeSchema = SchemaFactory.createForClass(Coffee)
----
//}}}

Mongoose adds on underscore `"_Id"` - property to Schemas by default and if we
want to stick with that standard best practice.

With `"Id"` removed from our Schema, let's add the `@Prop()` - decorator to all
the rest of our properties, "name:", "brand:", and "flavors:".

Since "flavors" is an Array of Strings. We need to do something a little bit
different since NestJS is not capable of reflecting the expected Type.

Inside this `"@Prop()"` - decorator. Let's pass an Array with String inside it,
to indicate that this property represents an Array of String.

Last but not least, we need to make sure we *extend* our Coffee - "Schema
Definition" with the `"Document"` - class from the `"mongoose"` - package.

With all in place, we created our first "Schema - Definition".

Now that we have our definitions set up. Let's actually create the *real*
"Mongoose - Schema".

To create actual Mongoose - Schema. Let's "export" a "const variable" and call
it Uppercase `*"CoffeeSchema"*`, and make it equal to
`"SchemaFactory.createForClass()"` and pass it in the "Coffee - Schema
Definition" that we just create it.

NOTE: You can also generate a raw Schema Definition using the
`DefinitionFactoryClass()` from `"@nestjs/mongoose"`

This allows you to manually modify the "Schema - Definition", generated based on
the metadata you provided.

This useful for certain *edge-cases* where it might be hard to represent
everything with decorators.

All right, the last thing we need to do is wire everything up.

Since our application is now a bit modularized, and we are dealing with this
"Schema" inside of the "CoffeesModule". We need to make Mongoose aware of the
Schema inside of THIS "*child* - Module".

To do this. Let's open up our "CoffeesModule", and create an `"imports:[]"`
Array.

//{{{ coffees.module.ts
[source, typescript]
----
// coffees.module.ts
import { Module } from "@nestjs/common";
import { MongooseModule } from "@nestjs/mongoose";

import { CoffeesController } from "./coffees.controller";
import { CoffeesService } from "./coffees.service";
import {Coffee, CoffeeSchema } from "./entities/coffee.entity";


@Module({
    imports: [MongooseModule.forFeature([
        {
            name: Coffee.name,
            schema: CoffeeSchema
        }
    ])
    ],
    controllers: [CoffeesController],
    providers: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

Adding "MongooseModule.forFeature()", passing in an Array with an Object inside.
`[{name: Coffee.name, schema: Coffee.schema}]`.

We used `"forFeature()"` to register Mongoose within our child - Module.
Previously we used `"forRoot()"` in our main "AppModule", but we only do that
once.  Every other Module in our application will use `"forFeature()"` when
registering Schemas and Model based on them.

Inside of `"forFeature()"`, we passed in an Array of Objects that consist of two
properties.  "name:"` (name of the model), and `"schema:"` (Schema to be used to
compiled the Model).

Note, that `"Coffee.name"`, is just a way to get the function name from
a JavaScript - class, which in this case will give us the String of `"coffee"`.

That's all we need to do!.

Now we can fully interact with our new Coffees - "MongoDB - *collection*".

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 6 == Using a Mongoose Model
[[_using_a_mongoose_model]]
== Using a Mongoose Model

Our Mongoose - Model let us interact with MongoDB. With each Model representing
a separate "collection".

In Mongo, and "*_instance of_* - Model" is called a *"Document"*.

If you familiar with SQL database, it may help to think of "Document" as
something similar to *"rows"*.

There is a class from Mongoose called *"Model"*, that acts as an abstraction
over our data source - exposing a variety of useful methods for interacting with
the "Document" stored in our database.

Since we've already registered "Coffee" in the scope of our "CoffeesModule".
`"@nestjs/module"` automatically generate this "Model" - class that we can use,
simply by injecting it into the "CoffeesService".

//{{{ coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, NotFoundException } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model } from "mongoose";

import { Coffee } from "./entities/coffee.entity";

@Injectable()
export class CoffeesService {
    ...
    ...

    constructor(@InjectModel(Coffee.name) private readonly coffeeModel: Model<Coffee>){}

    ...
    ...
}
----
//}}}

Using the `"@InjectModel()"` - decorator exported from the `"@nestjs/mongoose"`
- package.  We can pass in our `"Coffee.name"` to start utilizing it.

Let's make sure to make our `"coffeeModel"` of type `Model`.

Previously in our "CoffeesService". We used the Coffees Array (`Coffee[]`) as
our mock in-memory data source. Since we are using a real database now. We no
longer need this mock implementation. So let's remove it.

Now let's go inside each method one by one and use our new `"coffeeModel"`.

NOTE: Before we dive into everything here. We'll be using a JavaScript feature
called "async/await" again, which makes *"Promises"* easier to manage and much
more readable.

We'll to update most of our methods to be *async* in order for this to work.

Let's start things off by looking at the `*"findAll()"*` method.

//{{{ coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, NotFoundException } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model } from "mongoose";

import { Coffee } from "./entities/coffee.entity";

@Injectable()
export class CoffeesService {
    constructor(@InjectModel(Coffee.name) private readonly coffeeModel: Model<Coffee>){}

    findAll(){
        return this.coffeeModel.find().exec();
    }

    ...
    ...
}
----
//}}}

First, let's remove the current code inside the method and update it to use our new
`"coffeeModel"`.

//{{{ image::./images/chapter-9-10.png
[#img-chapter]
[link=./images/chapter-9-10.png]
.Using a Mongoose Model to Access MongoDB
image::./images/chapter-9-10.png[align="center"]
//}}}

If we enter `"this.coffeeModel. "` all available methods we have to interact
with our "Coffee - Document" now.

Since we are trying to find ALL Coffees. We are going to use the `find()`
- method without any arguments and then we have to execute this "Mongoose
- Query", by calling the `"exec()"` - method.

Next, let's update the code in our `"findOne()"` method.

//{{{ coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, NotFoundException } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model } from "mongoose";

import { Coffee } from "./entities/coffee.entity";

@Injectable()
export class CoffeesService {
    constructor(@InjectModel(Coffee.name) private readonly coffeeModel: Model<Coffee>){}

    findAll() {
        ...
        ...
    }

    async findOne(id: string) {
        const coffee = await this.coffeeModel.findOne({ _id: id }).exec()

        if (!coffee) {
            // throw new HttpException(`Coffee #${id} not found`, HttpStatus.NOT_FOUND);
            throw new NotFoundException(`Coffee #${id} not found`);
        }

        return coffee;
        // return this.coffees.find(item => item.id === +id);
    }
    ...
    ...
}
----
//}}}

This time using the `"findOne()"` method from Mongoose; and since we are
searching by `"id"`. Remember that Mongoose automatically created an `"_id"`
- property in our Schemas. So let's search by that.  Again, let's make sure this
by calling the `"exec()"` - method.

For our `"create()"` - method, let's replace the old code with the following.

//{{{ coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, NotFoundException } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model } from "mongoose";

import { Coffee } from "./entities/coffee.entity";

@Injectable()
export class CoffeesService {
    constructor(@InjectModel(Coffee.name) private readonly coffeeModel: Model<Coffee>){}

    findAll() {
        ...
        ...
    }

    async findOne(id: string) {
        ...
        ...
    }

    create(createCoffeeDto: any) {
        const coffee = new this.coffeeModel(createCoffeeDto);
        return coffee.save();
    }
    ...
    ...
}
----
//}}}

The first thing we need to do is *"create"* a Coffee - "class instance" based
on our partial DTO and save it to the variable `"coffee"`.

Now all we need to do is call the `"save()"` - method, which return a "Promises".

Just like that. Our new Document will be saved to the database!.



**⬆xref:_table_of_contents[back to top]**
//}}}
