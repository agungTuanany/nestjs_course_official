//{{{ ** ASCIIDOC HEADER
:description:   nestjs official course | chapter-4
:url-repo:      https://github.com/agungTuanany/nestjs_course_official
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Sun Apr  4 05:48:02 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
//}}}

[[_chapter_6_other_building_blocks_by_example]]
= Chapter-6 Other Building Blocks By Example
:figure-caption!:
:source-highlighter: highlight.js

//{{{== Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_introducing_more_building_blocks[Introducing More Building Blocks]
| 2.    | xref:_understanding_building_techniques[Understanding Building Techniques]
|====
//}}}

//{{{ 1 == Introducing More Building Blocks
[[_introducing_more_building_blocks]]
== Introducing More Building Blocks

//{{{ image::./images/chapter-6-1.png
[#img-chapter]
[link=./images/chapter-6-1.png]
.Introducing More Bulding Blocks
image::./images/chapter-6-1.png[align="center"]
//}}}

As we've seen throughout the course so far. In NestJS - applications everything
has its place.

//{{{ image::./images/chapter-6-2.png
[#img-chapter]
[link=./images/chapter-6-2.png]
.Introducing More Bulding Blocks - 2
image::./images/chapter-6-2.png[align="center"]
//}}}

This "structured - application" organization, helps us mange complexity and
develop with SOLID principles.

This Type of organization is, especially useful as the size of our application
or team grows.  Keeping code organized, establishing clear boundaries, and
having dedicated architectural building blocks, all with the separate of
responsibilities. Help us make sure that our application remain easily
maintainable and scalable over time.

//{{{ image::./images/chapter-6-3.png
[#img-chapter]
[link=./images/chapter-6-3.png]
.Introducing More Bulding Blocks - 3
image::./images/chapter-6-3.png[align="center"]
//}}}

In NestJS we have *4* additional "building blocks" for features, that we haven't
showcased yet!. These are:

- xref:_exception_filters[*Exception Filters*]
- xref:_pipes[*Pipes*]
- xref:_guards[*Guards*]
- xref:_interceptor[*Interceptor*]

[[_exception_filters]]
=== Exception Filters

//{{{ image::./images/chapter-6-4.png
[#img-chapter]
[link=./images/chapter-6-4.png]
.Introducing More Bulding Blocks - Exception Filters
image::./images/chapter-6-4.png[align="center"]
//}}}

*Exception Filters* are responsible for handling and processing "*unhandled -
exception*" that *might* occur in our application.  They let us control the
"Exact - flow" and "Content - flow" of any or *specific Responses*, we send back
to the client.

[[_pipes]]
=== Pipes
:fn-acl: footnote:[Access Control List]
:fn-aop: footnote:[In computing, aspect-oriented programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns.It does so by adding additional behavior to existing code (an advice) without modifying the code itself, instead separately specifying which code is modified via a "pointcut" specification, https://en.wikipedia.org/wiki/Aspect-oriented_programming]

//{{{ image::./images/chapter-6-5.png
[#img-chapter]
[link=./images/chapter-6-5.png]
.Introducing More Bulding Blocks - Pipe
image::./images/chapter-6-5.png[align="center"]
//}}}

*Pipes* are typically useful to handle *2* - things:

- *Transition*, meaning to transform "*input* - data" to *"desired output"*, and
- *Validation*, meaning to *"evaluate input data"* and if VALID - let it pass
  through the "Pipe" unchanged. But if "*NOT* - VALID", throwing an Exception.

[[_guards]]
=== Guards

//{{{ image::./images/chapter-6-6.png
[#img-chapter]
[link=./images/chapter-6-6.png]
.Introducing More Bulding Blocks - Guards
image::./images/chapter-6-6.png[align="center"]
//}}}

*Guards* determine whether a given Request meets certain condition, like
*"authentication"*, *"authorization"*, *"roles"*, *"ACLs{fn-acl}"*, etc. And if
the conditions are met, the requests will be *allowed* to access the *route*.

[[_interceptor]]
=== Interceptor

//{{{ image::./images/chapter-6-7.png
[#img-chapter]
[link=./images/chapter-6-7.png]
.Introducing More Bulding Blocks - Interceptor
image::./images/chapter-6-7.png[align="center"]
//}}}

*Interceptor* have many useful capabilities inspired by the "Aspect Oriented
Programming{fn-aop} - technique". Interceptors make it possible to:

1. Bind *extra logic*, before or after method execution.
2. Transform the *result* returned from a method.
3. Extend "*basic - method*" behavior.
4. Completely "*override* a method", depending on specific conditions. For
example: handling something like *"caching - responses"*.

So now that we've covered the basics. Let's dive into all *4* these new building
blocks in the next few lessons.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 2 == Understanding Building Techniques
[[_understanding_building_techniques]]
== Understanding Building Techniques

//{{{ image::./images/chapter-6-8.png
[#img-chapter]
[link=./images/chapter-6-8.png]
.Understanding Building Techniques
image::./images/chapter-6-8.png[align="center"]
//}}}

Before we jump into the specifics of each Nest "building - block". Let's take a step back and talk about a few
approaches we can take to bind any of these "building - blocks", to different parts of our application.

//{{{ image::./images/chapter-6-9.png
[#img-chapter]
[link=./images/chapter-6-9.png]
.Understanding Building Techniques - 2
image::./images/chapter-6-9.png[align="center"]
//}}}

Basically there are *3* different ways of binding to our "*route - handlers*"
with a bonus "4th" way that specific to (*Pipes*).

- *Filters*
- *Guards*
- *Interceptors*
- *Pipes*

Nest "building - blocks" can be:

- *Globally* - scoped
- *Controller* - scoped
- *Method* - scoped
- *Param* - scope, which said is *available to Pipes* only.

NOTE: These different "binding - techniques" give you *granularity* and
*control* at different levels in you application.

Each one does NOT *override* another, but rather "*layers each one* - "on top".

So be *careful* on how you implement these.

For example, if you have a *globally*-"scoped - Pipe", it will be applied as
well as any other (Pipe) you might add. Whether it's "controlled - scoped",
"method - scoped", etc.

So far in this course we've already seen *globally*-"scoped - pipes" in action,
when we use the "ValidationPipe" to helps us validate *incoming* - "request
- payloads", amongst other things.

If we open up our `"main.ts"` - file.

//{{{ // main.ts
[source, typescript]
----
// main.ts
import { NestFactory } from "@nestjs/core";
import { ValidationPipe } from "@nestjs/common";
import { AppModule } from "./app.module";

async function bootstrap() {
    const app = await NestFactory.create(AppModule);

    app.useGlobalPipes(         // <<<
        new ValidationPipe({
            whitelist: true,
            transform: true,
            forbidNonWhitelisted: true,
            transformOptions: {
                enableImplicitConversion: true,
            },
        }),
    );
    await app.listen(3002);

    // console.log("app is run on port: 3002");
}
bootstrap();
----
//}}}

We'll see that we previously bound the "ValidationPipe" globally by calling
`*"useGlobalPipes()"*` - method of our "*`"app"`* - instance".

//{{{ image::./images/chapter-6-10.png
[#img-chapter]
[link=./images/chapter-6-10.png]
.Understanding Building Techniques - intellisence
image::./images/chapter-6-10.png[align="center"]
//}}}

You could see that if we type `app.use` *"intellisence"* shows us corresponding
methods for every other "building - block" available here. Respectively
`*"useGlobalPipes()"*`, `*"useGlobalGuard()"*`, `*"useGlobalInterceptors()"*`,
and `*"useGlobalFilters()"*`, etc..

Going back to our `"ValidationPipe()"` here. One big limitation of setting it up
and instantiating it by ourselves like this, is that we can *NOT* - "*inject any
dependencies*" here!. Since we're setting it up *outside* of context of any
"NestJS - *Module*".

So how do we work around this?.

One option we have, is to *set up* a *"Pipe"* directly from inside a "Nest
- *Module*" using the *"custom - provider"* based syntax, we saw in earlier lessons.

Let's open up our "AppModule" - file, and define something called the `"APP_PIPE"` - Provider.

//{{{ app.module.ts
[source, typescript]
----
// app.module.ts
import { Module, ValidationPipe } from "@nestjs/common";
import { APP_PIPE } from "@nestjs/core";
...
...

@Module({
    imports: [
        ...
        ...
    ],
    controllers: [AppController],
    providers: [
        AppService,
        {
            provide: APP_PIPE,          // <<<
            useClass: ValidationPipe,   // <<<<
        },
    ],
})
export class AppModule {}
----
//}}}

This `"APP_PIPE"` - "provider" is a "*special* - TOKEN" exported from
`"@nestjs/core"` - packages.

Providing - `"ValidationPipe"` in this manner. Let's Nest instantiate the
`"ValidationPipe"` within the *scope* of the "AppModule" and once created,
registers it as a "Global Pipe".

Note that there are also "corresponding - tokens" for every other "building
- block" feature!, such as `*"APP_INTERCEPTOR"*`, `*"APP_GUARD"*`, and
`*"APP_FILTER"*`.

Back to our `"ValidationPipe"`. What if we *don't* want to use it globally? But
some are more specific like on a "certain - Controller".

Let's imagine that we want to *bind* a `"ValidationPipe"` to *every* - "route
handler" defined only within our "CoffeesController".

Let's open up our "CoffeesController" - file and make use a new decorator
`"@UsePipes()"` that we haven't seen yet.

//{{{ coffees.controller.ts
[source, typescript]
----
// coffees.controller.ts
import { Controller, Get, Param, Body, Post, Patch, Delete, Query, Inject, UsePipes, ValidationPipe } from "@nestjs/common";

@UsePipes(ValidationPipe)           // <<<
@Controller("coffees")
export class CoffeesController {
    constructor(
        private readonly coffeesService: CoffeesService,
        @Inject(REQUEST)
        private readonly request: Request,
    ) {
        console.log("[!!] CoffeesController created");
    }
    ...
    ...
}
----
//}}}

This `@UsePipes()` decorator can be passed in a "single - Pipe Class" or
a "comma separated list of Pipe - Classes".  Just like in other scenarios.

There are also "corresponding - decorators" for every other "building - block"
that can be used here as well.  Named `*"@UseInterceptors()"*`,
`*"@UseGuards()"*`, and `*"@UseFilters()"*`.

//{{{ coffees.controller.ts
[source, typescript]
----
// coffees.controller.ts
import { Controller, Get, Param, Body, Post, Patch, Delete, Query, Inject, UsePipes, ValidationPipe } from "@nestjs/common";

@UsePipes(new ValidationPipe())     // <<<
@Controller("coffees")
export class CoffeesController {
    constructor(
        private readonly coffeesService: CoffeesService,
        @Inject(REQUEST)
        private readonly request: Request,
    ) {
        console.log("[!!] CoffeesController created");
    }
    ...
    ...
}
----
//}}}

Alternatively, you can even pass an *"instance"* of class here. Take for example
providing `"new ValidationPipe()"` inside of the decorator.

This is super useful when you want to pass in a specific - "configuration
object" to the `"ValidationPipe"` for *this* exact scenario.

NOTE: As the best practice, try to apply *"filters'* by using *"classes"*
instead of *"instances"* whenever possible.

This best practice *"reduces memory usage"* since Nest can easily *reuse
instances* of the "same class", across your entire Module.

All "building - blocks" can also be *"Method - scoped"*. Imagine that you want to
bind a "Pipe" to a "specific - Route". We can achieve this by simply applying
the same decorator we just saw `"@UsePipes()"`, but on top of the specific method we
want to declare it on.

Let's say we want to add "specific validation" to our GET - `findALL()` - method,
within "CoffeesController".

//{{{ coffees.controller.ts
[source, typescript]
----
// coffees.controller.ts
import { Controller, Get, Param, Body, Post, Patch, Delete, Query, Inject, UsePipes, ValidationPipe } from "@nestjs/common";

@Controller("coffees")
export class CoffeesController {
    constructor(
        private readonly coffeesService: CoffeesService,
        @Inject(REQUEST)
        private readonly request: Request,
    ) {
        console.log("[!!] CoffeesController created");
    }

    @UsePipes(new ValidationPipe())     // <<<
    @Get()
    findAll(@Query() paginationQuery: PaginationQueryDto) {
        // const { limit, offset } = paginationQuery;
        return this.coffeesService.findAll(paginationQuery);
    }
    ...
    ...
}
----
//}}}

With this setup, This `"ValidationPipe"` is *only* applied to this single `findALl()` - "Route - handler".

We are already familiar with the *3* different ways of tying *"filters"*, *"guards"*, *"pipes"*, and *"Interceptors"* to our "Route - handlers".
But as we said, there is a "4th" bonus way - that's only available to "Pipes", and it's called *"Param-based scope"*.

"Param-scoped Pipes", are useful when the "validation - logic" *concern* ONLY ONE "specific parameter".

Let's scroll down to the `update()` - method.

//{{{ coffees.controller.ts
[source, typescript]
----
// coffees.controller.ts
import { Controller, Get, Param, Body, Post, Patch, Delete, Query, Inject, UsePipes, ValidationPipe } from "@nestjs/common";

@Controller("coffees")
export class CoffeesController {
    constructor(
        private readonly coffeesService: CoffeesService,
        @Inject(REQUEST)
        private readonly request: Request,
    ) {
        console.log("[!!] CoffeesController created");
    }

    @UsePipes(new ValidationPipe())     // <<<
    @Get()
    findAll(@Query() paginationQuery: PaginationQueryDto) {
        // const { limit, offset } = paginationQuery;
        return this.coffeesService.findAll(paginationQuery);
    }
    ...
    ...
    @Patch(":id")
    update(@Param("id") id: string, @Body(ValidationPipe) updateCoffeeDto: UpdateCoffeeDto) {     // <<<
        return this.coffeesService.update(id, updateCoffeeDto);
    }
}
----
//}}}

This method takes "*2* - arguments": the "resource - *id*", as well as the
"payload" required to update the existing entity.

What if we want to bind a "Pipe" to the *"body"* of the request but not the
"*id* - parameter".  This is exactly where the "param - based" - Pipe comes in
handy.

By passing the `"ValidationPipe" - class reference, directly to the `"@Body"`
- decorator here, we can let Nest know to run *this particular - Pipe*
-exclusively for just this specific parameter!, and there we have it.

With these *4* powerful "building - blocks". We can now control the *"flow"*,
*"content"*, *"validation"* on anything in our application, globally, all the
way down to a specific *"controller"*, *"method"*, or even a *"parameter"*.

=== Reference

- link:https://docs.nestjs.com/pipes#pipes[NestJS - Pipes]
- link:https://docs.nestjs.com/pipes#global-scoped-pipes[Global Scoped Pipes]

**⬆xref:_table_of_contents[back to top]**
//}}}

