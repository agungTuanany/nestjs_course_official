//{{{ ** ASCIIDOC HEADER
:description:   nestjs official course | chapter-4
:url-repo:      https://github.com/agungTuanany/nestjs_course_official
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Sun Apr  4 05:48:02 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
//}}}

[[_chapter_6_other_building_blocks_by_example]]
= Chapter-6 Other Building Blocks By Example
:figure-caption!:
:source-highlighter: highlight.js

//{{{== Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_introducing_more_building_blocks[Introducing More Building Blocks]
| 2.    | xref:_understanding_building_techniques[Understanding Building Techniques]
| 3.    | xref:_catch_exception_with_filters[Catch Exception With Filters]
| 4.    | xref:_protect_routes_with_guards[Protect Routes With Guards]
|====
//}}}

//{{{ 1 == Introducing More Building Blocks
[[_introducing_more_building_blocks]]
== Introducing More Building Blocks

//{{{ image::./images/chapter-6-1.png
[#img-chapter]
[link=./images/chapter-6-1.png]
.Introducing More Bulding Blocks
image::./images/chapter-6-1.png[align="center"]
//}}}

As we've seen throughout the course so far. In NestJS - applications everything
has its place.

//{{{ image::./images/chapter-6-2.png
[#img-chapter]
[link=./images/chapter-6-2.png]
.Introducing More Bulding Blocks - 2
image::./images/chapter-6-2.png[align="center"]
//}}}

This "structured - application" organization, helps us mange complexity and
develop with SOLID principles.

This Type of organization is, especially useful as the size of our application
or team grows.  Keeping code organized, establishing clear boundaries, and
having dedicated architectural building blocks, all with the separate of
responsibilities. Help us make sure that our application remain easily
maintainable and scalable over time.

//{{{ image::./images/chapter-6-3.png
[#img-chapter]
[link=./images/chapter-6-3.png]
.Introducing More Bulding Blocks - 3
image::./images/chapter-6-3.png[align="center"]
//}}}

In NestJS we have *4* additional "building blocks" for features, that we haven't
showcased yet!. These are:

- xref:_exception_filters[*Exception Filters*]
- xref:_pipes[*Pipes*]
- xref:_guards[*Guards*]
- xref:_interceptor[*Interceptor*]

[[_exception_filters]]
=== Exception Filters

//{{{ image::./images/chapter-6-4.png
[#img-chapter]
[link=./images/chapter-6-4.png]
.Introducing More Bulding Blocks - Exception Filters
image::./images/chapter-6-4.png[align="center"]
//}}}

*Exception Filters* are responsible for handling and processing "*unhandled -
exception*" that *might* occur in our application.  They let us control the
"Exact - flow" and "Content - flow" of any or *specific Responses*, we send back
to the client.

[[_pipes]]
=== Pipes
:fn-acl: footnote:acl[Access Control List]
:fn-aop: footnote[In computing, aspect-oriented programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns.It does so by adding additional behavior to existing code (an advice) without modifying the code itself, instead separately specifying which code is modified via a "pointcut" specification, https://en.wikipedia.org/wiki/Aspect-oriented_programming]

//{{{ image::./images/chapter-6-5.png
[#img-chapter]
[link=./images/chapter-6-5.png]
.Introducing More Bulding Blocks - Pipe
image::./images/chapter-6-5.png[align="center"]
//}}}

*Pipes* are typically useful to handle *2* - things:

- *Transition*, meaning to transform "*input* - data" to *"desired output"*, and
- *Validation*, meaning to *"evaluate input data"* and if VALID - let it pass
  through the "Pipe" unchanged. But if "*NOT* - VALID", throwing an Exception.

[[_guards]]
=== Guards

//{{{ image::./images/chapter-6-6.png
[#img-chapter]
[link=./images/chapter-6-6.png]
.Introducing More Bulding Blocks - Guards
image::./images/chapter-6-6.png[align="center"]
//}}}

*Guards* determine whether a given Request meets certain condition, like
*"authentication"*, *"authorization"*, *"roles"*, *"ACLs{fn-acl}"*, etc. And if
the conditions are met, the requests will be *allowed* to access the *route*.

[[_interceptor]]
=== Interceptor

//{{{ image::./images/chapter-6-7.png
[#img-chapter]
[link=./images/chapter-6-7.png]
.Introducing More Bulding Blocks - Interceptor
image::./images/chapter-6-7.png[align="center"]
//}}}

*Interceptor* have many useful capabilities inspired by the "Aspect Oriented
Programming{fn-aop} - technique". Interceptors make it possible to:

1. Bind *extra logic*, before or after method execution.
2. Transform the *result* returned from a method.
3. Extend "*basic - method*" behavior.
4. Completely "*override* a method", depending on specific conditions. For
example: handling something like *"caching - responses"*.

So now that we've covered the basics. Let's dive into all *4* these new building
blocks in the next few lessons.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 2 == Understanding Building Techniques
[[_understanding_building_techniques]]
== Understanding Building Techniques

//{{{ image::./images/chapter-6-8.png
[#img-chapter]
[link=./images/chapter-6-8.png]
.Understanding Building Techniques
image::./images/chapter-6-8.png[align="center"]
//}}}

Before we jump into the specifics of each Nest "building - block". Let's take a step back and talk about a few
approaches we can take to bind any of these "building - blocks", to different parts of our application.

//{{{ image::./images/chapter-6-9.png
[#img-chapter]
[link=./images/chapter-6-9.png]
.Understanding Building Techniques - 2
image::./images/chapter-6-9.png[align="center"]
//}}}

Basically there are *3* different ways of binding to our "*route - handlers*"
with a bonus "4th" way that specific to (*Pipes*).

- *Filters*
- *Guards*
- *Interceptors*
- *Pipes*

Nest "building - blocks" can be:

- *Globally* - scoped
- *Controller* - scoped
- *Method* - scoped
- *Param* - scope, which said is *available to Pipes* only.

NOTE: These different "binding - techniques" give you *granularity* and
*control* at different levels in you application.

Each one does NOT *override* another, but rather "*layers each one* - "on top".

So be *careful* on how you implement these.

For example, if you have a *globally*-"scoped - Pipe", it will be applied as
well as any other (Pipe) you might add. Whether it's "controlled - scoped",
"method - scoped", etc.

So far in this course we've already seen *globally*-"scoped - pipes" in action,
when we use the "ValidationPipe" to helps us validate *incoming* - "request
- payloads", amongst other things.

If we open up our `"main.ts"` - file.

//{{{ // main.ts
[source, typescript]
----
// main.ts
import { NestFactory } from "@nestjs/core";
import { ValidationPipe } from "@nestjs/common";
import { AppModule } from "./app.module";

async function bootstrap() {
    const app = await NestFactory.create(AppModule);

    app.useGlobalPipes(         // <<<
        new ValidationPipe({
            whitelist: true,
            transform: true,
            forbidNonWhitelisted: true,
            transformOptions: {
                enableImplicitConversion: true,
            },
        }),
    );
    await app.listen(3002);

    // console.log("app is run on port: 3002");
}
bootstrap();
----
//}}}

We'll see that we previously bound the "ValidationPipe" globally by calling
`*"useGlobalPipes()"*` - method of our "*`"app"`* - instance".

//{{{ image::./images/chapter-6-10.png
[#img-chapter]
[link=./images/chapter-6-10.png]
.Understanding Building Techniques - intellisence
image::./images/chapter-6-10.png[align="center"]
//}}}

You could see that if we type `app.use` *"intellisence"* shows us corresponding
methods for every other "building - block" available here. Respectively
`*"useGlobalPipes()"*`, `*"useGlobalGuard()"*`, `*"useGlobalInterceptors()"*`,
and `*"useGlobalFilters()"*`, etc..

Going back to our `"ValidationPipe()"` here. One big limitation of setting it up
and instantiating it by ourselves like this, is that we can *NOT* - "*inject any
dependencies*" here!. Since we're setting it up *outside* of context of any
"NestJS - *Module*".

So how do we work around this?.

One option we have, is to *set up* a *"Pipe"* directly from inside a "Nest
- *Module*" using the *"custom - provider"* based syntax, we saw in earlier lessons.

Let's open up our "AppModule" - file, and define something called the `"APP_PIPE"` - Provider.

//{{{ app.module.ts
[source, typescript]
----
// app.module.ts
import { Module, ValidationPipe } from "@nestjs/common";
import { APP_PIPE } from "@nestjs/core";
...
...

@Module({
    imports: [
        ...
        ...
    ],
    controllers: [AppController],
    providers: [
        AppService,
        {
            provide: APP_PIPE,          // <<<
            useClass: ValidationPipe,   // <<<<
        },
    ],
})
export class AppModule {}
----
//}}}

This `"APP_PIPE"` - "provider" is a "*special* - TOKEN" exported from
`"@nestjs/core"` - packages.

Providing - `"ValidationPipe"` in this manner. Let's Nest instantiate the
`"ValidationPipe"` within the *scope* of the "AppModule" and once created,
registers it as a "Global Pipe".

Note that there are also "corresponding - tokens" for every other "building
- block" feature!, such as `*"APP_INTERCEPTOR"*`, `*"APP_GUARD"*`, and
`*"APP_FILTER"*`.

Back to our `"ValidationPipe"`. What if we *don't* want to use it globally? But
some are more specific like on a "certain - Controller".

Let's imagine that we want to *bind* a `"ValidationPipe"` to *every* - "route
handler" defined only within our "CoffeesController".

Let's open up our "CoffeesController" - file and make use a new decorator
`"@UsePipes()"` that we haven't seen yet.

//{{{ coffees.controller.ts
[source, typescript]
----
// coffees.controller.ts
import { Controller, Get, Param, Body, Post, Patch, Delete, Query, Inject, UsePipes, ValidationPipe } from "@nestjs/common";

@UsePipes(ValidationPipe)           // <<<
@Controller("coffees")
export class CoffeesController {
    constructor(
        private readonly coffeesService: CoffeesService,
        @Inject(REQUEST)
        private readonly request: Request,
    ) {
        console.log("[!!] CoffeesController created");
    }
    ...
    ...
}
----
//}}}

This `@UsePipes()` decorator can be passed in a "single - Pipe Class" or
a "comma separated list of Pipe - Classes".  Just like in other scenarios.

There are also "corresponding - decorators" for every other "building - block"
that can be used here as well.  Named `*"@UseInterceptors()"*`,
`*"@UseGuards()"*`, and `*"@UseFilters()"*`.

//{{{ coffees.controller.ts
[source, typescript]
----
// coffees.controller.ts
import { Controller, Get, Param, Body, Post, Patch, Delete, Query, Inject, UsePipes, ValidationPipe } from "@nestjs/common";

@UsePipes(new ValidationPipe())     // <<<
@Controller("coffees")
export class CoffeesController {
    constructor(
        private readonly coffeesService: CoffeesService,
        @Inject(REQUEST)
        private readonly request: Request,
    ) {
        console.log("[!!] CoffeesController created");
    }
    ...
    ...
}
----
//}}}

Alternatively, you can even pass an *"instance"* of class here. Take for example
providing `"new ValidationPipe()"` inside of the decorator.

This is super useful when you want to pass in a specific - "configuration
object" to the `"ValidationPipe"` for *this* exact scenario.

NOTE: As the best practice, try to apply *"filters'* by using *"classes"*
instead of *"instances"* whenever possible.

This best practice *"reduces memory usage"* since Nest can easily *reuse
instances* of the "same class", across your entire Module.

All "building - blocks" can also be *"Method - scoped"*. Imagine that you want to
bind a "Pipe" to a "specific - Route". We can achieve this by simply applying
the same decorator we just saw `"@UsePipes()"`, but on top of the specific method we
want to declare it on.

Let's say we want to add "specific validation" to our GET - `findALL()` - method,
within "CoffeesController".

//{{{ coffees.controller.ts
[source, typescript]
----
// coffees.controller.ts
import { Controller, Get, Param, Body, Post, Patch, Delete, Query, Inject, UsePipes, ValidationPipe } from "@nestjs/common";

@Controller("coffees")
export class CoffeesController {
    constructor(
        private readonly coffeesService: CoffeesService,
        @Inject(REQUEST)
        private readonly request: Request,
    ) {
        console.log("[!!] CoffeesController created");
    }

    @UsePipes(new ValidationPipe())     // <<<
    @Get()
    findAll(@Query() paginationQuery: PaginationQueryDto) {
        // const { limit, offset } = paginationQuery;
        return this.coffeesService.findAll(paginationQuery);
    }
    ...
    ...
}
----
//}}}

With this setup, This `"ValidationPipe"` is *only* applied to this single `findALl()` - "Route - handler".

We are already familiar with the *3* different ways of tying *"filters"*, *"guards"*, *"pipes"*, and *"Interceptors"* to our "Route - handlers".
But as we said, there is a "4th" bonus way - that's only available to "Pipes", and it's called *"Param-based scope"*.

"Param-scoped Pipes", are useful when the "validation - logic" *concern* ONLY ONE "specific parameter".

Let's scroll down to the `update()` - method.

//{{{ coffees.controller.ts
[source, typescript]
----
// coffees.controller.ts
import { Controller, Get, Param, Body, Post, Patch, Delete, Query, Inject, UsePipes, ValidationPipe } from "@nestjs/common";

@Controller("coffees")
export class CoffeesController {
    constructor(
        private readonly coffeesService: CoffeesService,
        @Inject(REQUEST)
        private readonly request: Request,
    ) {
        console.log("[!!] CoffeesController created");
    }

    @UsePipes(new ValidationPipe())     // <<<
    @Get()
    findAll(@Query() paginationQuery: PaginationQueryDto) {
        // const { limit, offset } = paginationQuery;
        return this.coffeesService.findAll(paginationQuery);
    }
    ...
    ...
    @Patch(":id")
    update(@Param("id") id: string, @Body(ValidationPipe) updateCoffeeDto: UpdateCoffeeDto) {     // <<<
        return this.coffeesService.update(id, updateCoffeeDto);
    }
}
----
//}}}

This method takes "*2* - arguments": the "resource - *id*", as well as the
"payload" required to update the existing entity.

What if we want to bind a "Pipe" to the *"body"* of the request but not the
"*id* - parameter".  This is exactly where the "param - based" - Pipe comes in
handy.

By passing the `"ValidationPipe" - class reference, directly to the `"@Body"`
- decorator here, we can let Nest know to run *this particular - Pipe*
-exclusively for just this specific parameter!, and there we have it.

With these *4* powerful "building - blocks". We can now control the *"flow"*,
*"content"*, *"validation"* on anything in our application, globally, all the
way down to a specific *"controller"*, *"method"*, or even a *"parameter"*.

=== Reference

- link:https://docs.nestjs.com/pipes#pipes[NestJS - Pipes]
- link:https://docs.nestjs.com/pipes#global-scoped-pipes[Global Scoped Pipes]

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 3 == Catch Exception With Filters
[[_catch_exception_with_filters]]
== Catch Exception With Filters
:fn-exception_filter: footnote:[https://github.com/nestjs/nest/blob/master/packages/common/exceptions/http.exception.ts]

//{{{ image::./images/chapter-6-11.png
[#img-chapter]
[link=./images/chapter-6-11.png]
.Catch Exception With Filters
image::./images/chapter-6-11.png[align="center"]
//}}}

NestJS comes with a built-in Exception "layer", responsible for processing all
"unhandled - Exceptions" across our application. When Expection is *NOT* handled
by our application, it is automatically caught by this "layer*, which send the
appropriate user-friendly response.

Out of the box. This action is performed by a built-in "global
- *ExceptionFilter*".  While this base built-in "ExceptionFilter" can
automatically handle many use cases for us.  We *may* want "full control" over
it.

//{{{ image::./images/chapter-6-12.png
[#img-chapter]
[link=./images/chapter-6-12.png]
.Catch Exception With Filters - 2
image::./images/chapter-6-12.png[align="center"]
//}}}

For example, we may want to add exception "logging" or "return" our Errors back
in a different "JSON - schema".  "Exception - Filters" are designed for exactly
this purpose!.

They let us be in charge of the exact *"flow of control"* and the "content" of
the Response being sent back to the client.

Let's create an "ExceptionFilter", that is responsible for "catching exception"
that are an instance of the "HttpException" - Class, and implement our own
*custom* "response - logic" for it.

Let's get started by firing up our terminal, and generating a *"filter"* - class
using the NEST - CLI "filter - schematic", by entering:

//{{{ $ nest g filter common/filters/http-exception
[source, shell]
----
$ nest g filter common/filters/http-exception
CREATE src/common/filters/http-exception.filter.spec.ts (201 bytes)
CREATE src/common/filters/http-exception.filter.ts (195 bytes)
----
//}}}

Note that we generated this *"filter"* in a `"/common/"` - directory, where we
can keep things that are *not* tied to any specific domain.

Let's open up he newly generated "HttpExceptionFilter", and see what we have
inside.

//{{{ http-exception-filter.ts
[source, typescript]
----
// http-exception-filter.ts
import { ArgumentsHost, Catch, ExceptionFilter, HttpException } from '@nestjs/common';

@Catch(HttpException) // <<<
export class HttpExceptionFilter<T> implements ExceptionFilter {
  catch(exception: T, host: ArgumentsHost) {}
}
----
//}}}

As you can see, the NEST - CLI generated and example  "filter", without any
"business logic" of course.

The `"@Catch()"` - decorator on top, *binds* the "required metadata" to the
"ExceptionFilter".  This `"@Catch()"` - decorator can take a "single
- parameter" or a "comma separated list".

This allows us to set up a "filter" for several "types of exceptions" at once if
we want it.

Since we want to process all exceptions that are instances of "HttpException".
Let's pass the "HttpException" - class between the parentheses `"()"`.

All "ExceptionFilter's" should implement the
`"ExceptionFilter{fn-exception_filter}"` - interface exported from
`@nestjs/common`.  This interface requires that we provide the `"catch()"`
- method with its indicated *"method signature"*.  Also we can see that our
class accepts a "Type - Argument", which indicates the Type of the *"exception
argument"* in our `"catch()"` - method.

Again, since we want to process all exceptions that are instances of
a `"HttpException"`. Let's changes this to `*"<T extends HttpException>"*`.

//{{{ http-exception-filter.ts
[source, typescript]
----
// http-exception-filter.ts
import { ArgumentsHost, Catch, ExceptionFilter, HttpException } from "@nestjs/common";
import { Response } from "express";

@Catch(HttpException)
export class HttpExceptionFilter<T extends HttpException> implements ExceptionFilter {  // <<<
    catch(exception: T, host: ArgumentsHost) {
        const ctx = host.switchToHttp();
        const response = ctx.getResponse<Response>();

        const status = exception.getStatus();
        const exceptionResponse = exception.getResponse();

        const error = typeof response === "string" ? { message: exceptionResponse } : (exceptionResponse as object);

        response.status(status).json({
            ...error
        })
    }
}
----
//}}}

All right, with all of that setup now, we can implement our *custom* - "response
- logic".  To do this, we'll need to access the "underlying - platform"
- `"Response{}"` Object so that we can *manipulate or transform* it and CONTINUE
sending the response - afterwards.

So where we get a *hold* of the "original Response"?

Let's use the second parameter here, `"host:"` which we can see as an instance
of `"ArgumentsHost"`, and call the method `"switchToHttp()"` on it. Saving this
as the variable `"ctx"`, short for "context".  This `"switchToHttp()"` - method
gives us access to the *native in-flight* "Request or Response Objects".  Which
is exactly what we need here.

Next, let use this `"ctx"` - variable, and call the `"getResponse()"` - method
on it.  This method will return our "underlying platforms" - Response.

NOTE: Remember in NestJS, this is ExpressJS by default, but could also be
swapped for Fastify.

For better "Type - safety" here. Let's specify the "Type" as a `"<Response>"`,
importing this Type from the `"express"` - packages.

Now we have our "Response". Let's use the "exception - parameter" available to
us in *this* - method, and extract "*2* - things".  The `*"statusCode"*`, and
`*"body"*` from the "current - exception".

To get the *"status"*, we can simply call the `"getStatus()"` - method as we see
above.

Let's also get a *hold* of a "raw - `"exceptionResponse"` ", by calling to
`"getResponse()"` - method and saving that variable as well.

Since for demonstration purposes - we're trying to pass back this *original
- "Error - Response", we need to do a little bit of work here.

First we need to test whether the Response is a String or an Object. If it's
a string, we're going to create an Object an put that String inside of the
"message - property". Otherwise we're all set in our "exceptionResponse" is
already an Object.

By doing of this. Our Errors will now be fairly "uniform", and we can (`"..."`)
*spread* this "error - variable" into our "final - response", which we'll do in
a moment!.

Great, so now that we have everything we need. Let's start building our
"response" *back* that we'll be sending.

First, let's set the "StatusCode" for the response we're going to send back via
the `"status()"` - method (`*"response.status(status)"*`).

Lastly, we need to send the `"exceptionResponse"` back. Our application
underlying platform is ExpressJS, which is the default. So there are several
ways we could do this!.

In our case. Let's just use Express's `".json()"` - method. We ca  simply chain
this method after our `"status()"` - call (as we see above), and using the
(`"..."`) "spread - operator", we can pass the original Error from our Exception
inside this `".json()"` - method.

As of right now. Our `"ExceptionFilter"` here isn't really doing anything unique
yet. So let's pass in something custom here along with the "original
- exception". This way we have something we can look for in all of our "errors"
to make sure everything with the `"ExceptionFilter"` works!.

Let's add a new `"timestamp"` - property and give it the value of `*"new
Date().toISOString()"*`.

Great. Now with all this in place, let's *bind* this "global
- `"ExceptionFilter"` " to our application.

Since we *don't need* any "external - providers" here, we can just *bind* this
"ExceptionFilter - globally" using the " `"app"` - instance" in our `"main.ts"`
- file.

Let's head over to the `"main.ts"` - file and add it real quick with
`"app.useGlobalFilters()"`.

//{{{ main.ts
[source, typescript]
----
// main.ts
import { NestFactory } from "@nestjs/core";
import { HttpException, ValidationPipe } from "@nestjs/common";

import { AppModule } from "./app.module";
import { HttpExceptionFilter } from  "./common/filters/http-exception.filter";

async function bootstrap() {
    const app = await NestFactory.create(AppModule);

    app.useGlobalPipes(
        new ValidationPipe({
            whitelist: true,
            transform: true,
            forbidNonWhitelisted: true,
            transformOptions: {
                enableImplicitConversion: true,
            },
        }),
    );
    app.useGlobalFilters(new HttpExceptionFilter()); // <<<
    await app.listen(3002);

    // console.log("app is run on port: 3002");
}
bootstrap();
----
//}}}

Now that everything's in place. Let's test it out by triggering some "AP
errors!".  Let's make sure that our app is running in our terminal, and if not,
make sure we run: `"npm run start:dev"`.

With our applications running. Let's open up `insomnia`, and perform a GET
- request to a "non existing* - resource and purposely make an Error happen!.

Let's hit someting `/coffees/-1` where "-1" is obviously an `"id"` we don't have
in the database.

//{{{ request: 'GET - http://localhost:3002/coffees/-1'
[source, json]
----
// request: 'GET - http://localhost:3002/coffees/-1'

// Body - raw: JSON
{}

// response, 404 -  NOT FOUND
{
    "statusCode": 404,
    "message": "Coffee with 'id: #-1' not found",
    "error": "Not Found",
    "timestamp": "2021-04-06T07:30:31.156Z"
}
----
//}}}

As we can see, the Response came back with an Error and clearly used new custom
"ExceptionFilter". Since the response contains our new `"timestamp"` - property.
Perfect!.

So naturally this exception we created was a basic example implementation. But
you can see that within this "ExceptionFilter", we could have just as easily
used some sort of "logging - Service" to track our errors, maybe even called an
"Analytics - API".  Anything we'd want to do whenever an "HttpException" occurs
in our application.

=== Reference

- link:https://docs.nestjs.com/exception-filters#exception-filters-1[Exception Filters, window=_blank]

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 4 == Protect Routes With Guards
[[_protect_routes_with_guards]]
== Protect Routes With Guards

//{{{ image::./images/chapter-6-13.png
[#img-chapter]
[link=./images/chapter-6-13.png]
.Protect Routes With Guards
image::./images/chapter-6-13.png[align="center"]
//}}}

Guards have a single responsibility. Which is to determine whether a "given
request" is allowed access to something.

If the "request" meets certain conditions, such as *"permissions"*. *"roles"*,
*"ACLs.footnote:acl[]"*, etc..  It *will* be allowed access to that route.

If the condition are *NOT* met, that it will be *denied* and an Error will be
thrown.

One of the best use-cases for "Guard": is *"Authentication"* and
*"Authorization"*.

//{{{ image::./images/chapter-6-14.png
[#img-chapter]
[link=./images/chapter-6-14.png]
.Protect Routes With Guards - 2
image::./images/chapter-6-14.png[align="center"]
//}}}

For example, we could implement a "Guard" that "extract" and "validates
a Token", and uses the extracted information to determine whether the "request
can *proceed* or *not*".

Since there are many different approaches and strategies to handle
authentication and authorization. In this lessons we'll focus on a simplified
example and learn how to leverage Guards themselves in our projects.

NOTE: If you're interested in learning more about Authentication itself, check
out our separate Course extension, which particularly focused on implementation
of an Enterprise-grade Authentication feature, and all the complexities that go
along with that.

All right. So to learn how to Guard - "*work conceptually*", let's create
a Guard that is responsible for *"2"* things:

1. Validating whether an API_KEY is present within an "authorization" - Header.
2. Validating whether the route being accessed is specified as *"public"*.

Let's call this new - Guard `*"ApiKeyGuard"*`. Let's fire up the terminal and
generate a "Guard - class" using the Nest - CLI.

//{{{ $ nest g guard common/guard/api-key
[source, shell]
----
$ nest g guard common/guard/api-key
CREATE src/common/guard/api-key.guard.spec.ts (169 bytes)
CREATE src/common/guard/api-key.guard.ts (301 bytes)
----
//}}}

NOTE: We generate this Guard in the `"/common/"` - *directory*, where we can
keep things that aren't tied to any specific domain.

All right, let's open up this newly generated "ApiKeyGuard" - file, and see what
we have inside.

//{{{ api-key.guard.ts
[source, typescript]
----
// api-key.guard.ts
import { CanActivate, ExecutionContext, Injectable } from "@nestjs/common";
import { Observable } from "rxjs";

@Injectable()
export class ApiKeyGuard implements CanActivate {
    canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
        return true;
    }
}
----
//}}}

As we can see the Nest - CLI generated an example Guard for us, *without any
logic* inside of course.  Similar to Providers. A Guard is just a Class with the
`"@Injectable()"` - decorator which we've seen in previous lessons.

One important requirement of Guard is, that they should *implement* the
`"canActivate"` - interface exported from `@nestjs/common`.  This interface
requires us to provide the `"canActivate()"` - method within our class.

This `"canActivate()"` - method should return *Boolean*, indicating whether the
"current - request" is allowed to proceed OR denied access.  This method *can
also* "return a Response" that's either synchronous or asynchronous, such as
a `"Promise"` or `"Observable"`.

Nest will use the "return - value" to control the next action. If it return
- `*"true"*`: the request will be processed. If it return `*"false"*`: Nest will
deny the request.

Looking at the example code, the Nest - CLI generated for us here. We have
`*"return true"*` hard-coded for now.  This means that currently, every request
will be allowed to proceed!.

Just for testing purposes, let's changes a couple line,

//{{{ api-key.guard.ts
[source, typescript]
----
// api-key.guard.ts
import { CanActivate, ExecutionContext, Injectable } from "@nestjs/common";
import { Observable } from "rxjs";

@Injectable()
export class ApiKeyGuard implements CanActivate {
    canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
        return false;   // <<<
    }
}
----
//}}}

We change `*"return true"*` to `*"return false"*`, indicating that every request
should be "*denied* - access".

Now that our initial "Mock Guard" is all set.  Let's bind it to our application
"globally".

Let's open up the "main.ts" - file, and add `*"AppUseGlobalGuards()"*`, passing
in our new "ApiKeyGuard" inside of it.

//{{{ main.ts
[source, typescript]
----
// main.ts
import { NestFactory } from "@nestjs/core";
import { HttpException, ValidationPipe } from "@nestjs/common";

import { AppModule } from "./app.module";
import { ApiKeyGuard } from  "./common/guard/api-key.guard";    // <<<

async function bootstrap() {
    const app = await NestFactory.create(AppModule);

    app.useGlobalPipes(
        new ValidationPipe({
            whitelist: true,
            transform: true,
            forbidNonWhitelisted: true,
            transformOptions: {
                enableImplicitConversion: true,
            },
        }),
    );
    app.useGlobalGuard( new ApiKeyGuard());     // <<<
    await app.listen(3002);

    // console.log("app is run on port: 3002");
}
bootstrap();
----
//}}}

Let's make sure that our applications is running in the background, and let's navigate
to `insomnia` and test any endpoint.

//{{{ request: 'GET - http://localhost:3002/coffees/'
[source, json]
----
// request: 'GET - http://localhost:3002/coffees/'

// Body - raw: JSON
{}

// response, 403 -  FORBIDDEN
{
    "statusCode": 403,
    "message": "Forbidden resource",
    "error": "Forbidden"
}
----
//}}}

As we can see ALL of our endpoints now responds with status `"403 Forbidden Resource"`,
just as we expected. It works perfectly.

But right now our Guard is not programmatically determining anything about our "Route" or the
"Caller" yet. It's simply always returning `"false"`.

That doesn't make much sense right? Instead let's set up our Guard to handle the
scenario we talked about in the beginning of this lesson. Which is to "validate an API_KEY that should be
present within each request", but-only-on routes that are *NOT* specified as *"public"*.

So how can we get started here?.

Well, first let's define this "API_KEY" that we're talking about. To make sure that we *never* push this *secret key* to our *Git - Repo*.
Let's define the "API_KEY" as an "environment - variable".

Open up our `".env"` - file that we created in a previous lesson and let's add the following `"API_KEY"` - line.

//{{{ .env
[source, typescript]
----
// .env
/*
* CAUTION:  never SUBMIT or PUSH this crendential '.env' - file in github or track on Git!.
* This only for course and education purpose.
*/

...
...
API_KEY=7AddwM8892Pbsewqaxx00wqaMMzal
----
//}}}

NOTE: The "API_KEY" here is just a random generated String, so feel free to use
whatever you'd like for this example.

Within this in place. Let's head back to our Guard.

Here in our Guard. We want to retrieve the API_KEY from any "incoming - request"
that is not labeled as "public". We'll be handling this "public - part" in
a moment.

//{{{ api-key.guard.ts
[source, typescript]
----
// api-key.guard.ts
import { CanActivate, ExecutionContext, Injectable } from "@nestjs/common";
import { Observable } from "rxjs";

@Injectable()
export class ApiKeyGuard implements CanActivate {
    canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
        const request = context.switchToHttp().getResponse<Request>()
        const authHeader = request.header("Authorization")
        return false;   // <<<
    }
}
----
//}}}

For our "API_KEY". Let's assume that the "caller" is passing this "key" as an
*"authorization - header"*.  To get the information about this "HTTP - request".
We'll need to access it all from the "ExecutionContext" ("contex' - param),
which inherits from `*"ArgumentsHost"*`, which we've already familiarized
yourself with when we used it with the "ExceptionFilter".

We can actually use those same "helper - methods" from before, but this time, to
get the reference of the "Request - Object" instead of the Response.

This `"switchToHttp"` - method, guves us access to the native "in-flight Request", "Response", and "Next" Objects!
Which is exactly what we need.

Next we need to call the `"getRequest()"` - method on it, which will return our underlying platform's "Request wrapper object".

Remember in Nest this is ExpressJS by default. But you could also be swapped for Fastify.

For better "Type - safety" here. Let's specify type as a `<Request>` importing this Type from the `express` - package again.

Now let's use this "Request - object" to retrieve the "*authorization* - header" from each request,
if it's even there.

Lastly, let's compare the "authorization header" passed in, with the "registered API_KEY" we have stored in our "environment - variable".

For now we'll simply access the "environment - variables" using the `"process.env"` - Object but *ideally* you'd want to leverage the
(`@nestjs/config`) `"ConfigService"` instead.

With all of this in place. Let's open `insomnia` and test *any* endpoint in our application, and see if our Guard works so far.

//{{{ request: 'GET - http://localhost:3002/coffees/'
[source, json]
----
// request: 'GET - http://localhost:3002/coffees/'

// Body - raw: JSON
{}

// response, 403 -  FORBIDDEN
{
    "statusCode": 403,
    "message": "Forbidden resource",
    "error": "Forbidden"
}
----
//}}}

As we can see our application responded with the status `"403 Forbidden Resource"`.

Since we didn't pass in any authorization header especially one with our specific "API_KEY". It looks like our Guard is working perfectly.

Let's try the same API - request again but this time let's add an "*authorization* - header" with the "correct - API_KEY".

With these in place. Let's hit send and call the endpoint again.

//{{{ request: 'GET - http://localhost:3002/coffees/'
[source, json]
----
// request: 'GET - http://localhost:3002/coffees/'

// Body - raw: JSON
{}

// Header
{
    Authorization: 7AddwM8892Pbsewqaxx00wqaMMzal
}

// response, 200 -  OK
[
    {
        "id": 1,
        "title": "Salemba Roast#1",
        "description": null,
        "brand": "Salemba Brew",
        "recomendations": 0,
        "flavors": [
            {
                "id": 1,
                "name": "chocolate"
            },
            {
                "id": 2,
                "name": "vanilla"
            }
        ]
    },
    {
        "id": 2,
        "title": "Salemba Roast#2",
        "description": null,
        "brand": "Salemba Brew",
        "recomendations": 0,
        "flavors": []
    },
    {
        "id": 3,
        "title": "Salemba Roast#3",
        "description": null,
        "brand": "Salemba Brew",
        "recomendations": 0,
        "flavors": []
    }
]
----
//}}}

Perfect. We've got a `"200"` response back and no error this time!.

Our Guard was able to verify that the "Authorization - header" matched our "secret - API_KEY"
and we were allowed access to continue the "API - Request".

So far we've finished setting up the "API_KEY - validation" - functionality we wanted, *but* still aren't checking
whether the "specific - route" being accessed is *"public"* or *not*.

In the next chapter we'll look at how Metadata and a few Nest features can help us achieve just that!.

**⬆xref:_table_of_contents[back to top]**
//}}}

