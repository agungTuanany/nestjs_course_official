//{{{ ** ASCIIDOC HEADER
:description:   SRS 7Express
:url-repo:      https://my-git-repo.com
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Mon Mar 22 05:22:36 AM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
//}}}

[[_chapter_2_getting_started_with_nestjs]]
= Chapter-2 Getting Started with nestJS
:figure-caption!:
:source-highlighter: highlight.js

//{{{== Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_creating_a_basic_controller[Creating a Basic Controller]
| 2.    | xref:_use_route_parameters[Use Route Parameters]
| 3.    | xref:_handling_request_body[Handling Request Body]
|====

//**⬆xref:_use_case_number_specification[back to top]**
//}}}

//{{{== Creating a Basic Controller
[[_creating_a_basic_controller]]
== Creating a Basic Controller

_Controllers_ are one of the most important building blocks of NestJS
applications as they *_handle request_*.

Let's generate a Controllers with Nest CLI by running

[source, bash]
----
$ nest generate controller
//or
$ nest g co
----

Since were working with our amazing new app called `iluvecoffe`, let's call our
first controller `coffees`

[source, bash]
----
$ nest g co
? What name would you like to use for the controller? coffees
CREATE src/coffees/coffees.controller.spec.ts (499 bytes)
CREATE src/coffees/coffees.controller.ts (103 bytes)
UPDATE src/app.module.ts (340 bytes)
----

As we can see in our terminal, Nest automatically created a Controller and
a corresponding *test* file (`.coffees.controller.spec.ts`) for us.

Also, we can see it updated module in our `AppModule`. If we open up the `app.module.ts`,

[source, javascript]
----
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { CoffeesController } from './coffees/coffees.controller';

@Module({
    imports: [],
    controllers: [AppController, CoffeesController],
    providers: [AppService],
})
export class AppModule {}
----

We'll see that the CLI automatically added this new `CoffeesController` to the
`controller:[]` array.

Note, that if we didn't want to generate a *test* file, we could have simply
passed the `--no-spec` flag like so.

[source, bash]
----
$ nest g co --no-spec
----

Now, taking a look back at our project structure, we can see the files we just
created ended up in a directory based on the name we selected, in our case:
`/src/coffees/`

[source, bash]
----
├── nest-cli.json
├── package.json
├── package-lock.json
├── README.md
├── src
│   ├── app.controller.spec.ts
│   ├── app.controller.ts
│   ├── app.module.ts
│   ├── app.service.ts
│   ├── coffees                             <<<
│   │   ├── coffees.controller.spec.ts      <<<
│   │   └── coffees.controller.ts           <<<
│   └── main.ts
├── test
│   ├── app.e2e-spec.ts
│   └── jest-e2e.json
├── tsconfig.build.json
└── tsconfig.json
----

If we want to generate something within a specific folder, just type in the
_directory_ or _directories_ which slashes `/` prior to the Controllers name,

[source, bash]
----
$ nest g co --no-spec modules/abc
----

For example, Nest generate Controllers `module/abc`, will be placed within `/src/module/abc`.

If you are not sure if the generator will place the file in the right directory,
use `--dry-run` flag to see the simulated output form the CLI,

[source, bash]
----
$ nest generate controller modules/abc --dry-run
CREATE src/modules/abc/abc.controller.spec.ts (471 bytes)
CREATE src/modules/abc/abc.controller.ts (95 bytes)
UPDATE src/app.module.ts (417 bytes)
----

This *_won't actually create any files_*. So it's a perfect way of testing any
command to see what it will do, and where it might _place things_.

Back to our newly created `CoffeesController`.

[source, javascript]
----
import { Controller } from '@nestjs/common';

@Controller('coffees')
export class CoffeesController {}
----

As we previously saw, the basic building blocks of Controllers in NestJS are
*_classes_* and *_decorators_*.

We know that Controllers are something that _handle *request_* in our
application. But how does the application know which _URL_ accesses 'which'
Controller?

// XXX Footnote XXX
:fn-tying: footnote:[binding]

You might already spotted it here, but the `@Controller()` decorator, can be
passed a _String_. This String then passed the _metadata_ needed for Nest to
create a *_routing map_*. Tying{fn-tying} incoming request to this
*corresponding controller*. In the case of our `CoffeesController`, we can see
it has the string of `'coffees'` passed to the _decorator_. Tying the `/coffees`
URL for our application to this controller.

If we open up `insomnia` or `postman` and make request a 'GET' request to
`http://localhost:3000/coffees`, we are going to see _`404`-error_.

[source, json]
----
{
    "statusCode": 404,
    "message": "Cannot GET /coffees",
    "error": "Not Found"
}
----

We have the Controller setup, but it's empty; and as the error message is
hinting to us *"Cannot GET /coffees"*; We haven't actually set up a *_'GET'
route_* in this Controller just yet!.

Lucky for us, Nest _has_ decorators for all the _common HTTP verbs_, all
includes in the `@nestjs/common` package, making this as easy as can be.

[source, javascript]
----
import { Controller, Get } from '@nestjs/common';

@Controller('coffees')
export class CoffeesController {
    @Get()                                                    //[2]
    findAll() {                                               //[1]
        return "This action returns all the coffers.";        //[3]
    }
}
----

Inside our `CoffeesController`, let's create a _'GET HTTP'-*handler_*, using one
of the Nest decorators. Start by creating a method inside the controller. The
name of the method itself doesn't matter, but let's called `findAll()`; as this
request, will be use to *fetch all the result* for this controller.

Now, let's decorate this method with the `@GET()` decorator; Make sure to import
it from `@nestjs/common`.

For now, let's just add a quick `return` statement and echo some text back.
Let's return a string that says something like, "This action returns all the coffers."

Within just like above, we mapped our first _GET_ requests within the `/coffees` route.

Other _HTTP verbs_ will be done in the same fashion; and it placed inside of
this Controller, they would be mapped to `/coffees` as well. Let's save our
progress and see if we can access this _GET-route_ from `insomnia` or `postman`.

Great, it works perfectly!. We can see that we got: "This action returns all the
coffers." back from the API just like we expected.

[[_nested_url]]
=== Nested URL

Now, what if we wanted to have a *_nested URL_* for this specific GET-request?
Just as we saw with Controllers, all of the HTTP decorator's take _one
parameter_, a *String*; which create a "*nested-path*" and appends it to the one
included form the controller itself.

[source, javascript]
----
import { Controller, Get } from '@nestjs/common';

@Controller('coffees')
export class CoffeesController {
    @Get('flavors')                 //<<<<
    findAll() {
        return "This action returns all the coffers.";
    }
}
----

If we updated our GET request, to `@GET('flavors')`, we can now access this
route via `/coffees/flavors`. Let's save our changes, and head back to
`insomnia` and hit this new endpoint `/coffees/flavors`. Perfect, the routes
works at its new nested URL.

Everything we've shown so far gives  us amazing control and flexibility over our
_HTTP verbs_. Making them easy to read, and uniform throughout our application.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{== Use Route Parameters
[[_use_route_parameters]]
== Use Route Parameters

[#img-chapter]
[link=./images/chapter-2-1.png]
.Use Route Parameters
image::./images/chapter-2-1.png[align="center"]

Routes with specific paths *wont's works* when you need to *accept dynamic data*
as part of you request. Let's say we made a GET request to `/coffees/123`, where
`123` us dynamic and referring to an `ID`. In order to define routes with
parameters, we can add _root parameters *tokens_* to the path of the routes.

This lets us capture these dynamic values at that position in the _request-URL_,
and passed them into the method as parameter.

Let's learn how all of this works by creating a new endpoint in our
`CoffeesController` for this exact scenario.

[source, javascript]
----
import { Controller, Get, Param } from '@nestjs/common';

@Controller('coffees')
export class CoffeesController {
    @Get('flavors')
    findAll() {
        return "This action returns all the coffers.";
    }

    @Get(':id')
    findOne(@Param() id) {
        return "This action returns #${params.id} the coffers.";
    }
}
----

Let's create a method called `findOne()`, and add the Nest `@Get()` decorator on
top. This time, let's pass in `:id` inside of the `@Get()` decorator. This
signifies that we're expecting a dynamic root parameter named "id".

Next, let's go inside of the `findOne()` parameters and use a new Nest decorator
called `@Param()`, also form `@nest/common` and name it "`params`". The
`@Param()` decorator let us *grab all incoming request parameters* and use them
inside of the function body of our method.

When we don't pass anything inside of the `@Param()` decorator, we receive all
request parameters, letting us access `${params.id}` from the object.

=== Constraint Params Objects

[source, javascript]
----
import { Controller, Get, Param } from '@nestjs/common';

@Controller('coffees')
export class CoffeesController {
    @Get('flavors')
    findAll() {
        return "This action returns all the coffers.";
    }

    @Get(':id')
    findOne(@Param('id') id: string) {
        return "This action returns #${params.id} the coffers.";
    }
}
----

Sometimes, we don't want to access the entire _params objects_. With the
`@Params()` decorator, we have the options of passing in a String inside of it,
to access a specific portion of the params. Let's enter in `'id'` directly
inside of the decorator. But let's make sure we update our `@Param()` name to
`id:` of type String to reflect these changes.

Let's save everything, head over to `insomnia` and access, `GET /coffees/123`,
to see if it's able to grab `'123'` from the URL. If we changes this to `10`, we
can see that it's entirely dynamic picking up any number we pass in.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ == Handling Request Body

[[_handling_request_body]]
== Handling Request Body

In this lesson, let's look at how we can work with _POST-request_ and retrieve
*_request payloads_* that are typically passed alongside them.

Similar to the `@Param()` decorator we just learned about, Nest also has
a helpful decorator for getting all or specific portions of the `reqeust.body`
know as the `@Body()` decorator.

[source, javascript]
----
import { Controller, Get, Param, Post, Body } from '@nestjs/common';

@Controller('coffees')
export class CoffeesController {
    @Get('flavors')
    findAll() {
        return "This action returns all the coffers.";
    }

    @Get(':id')
    findOne(@Param('id') id: string) {
        return `This action returns #${id} the coffers.`;
    }

    @Post()
    create(@Body() body) {
        return body;
    }
}
----

:fn-payload: footnote:[A payload in API is, the actual data pack that is sent with the GET method in HTTP. It is the crucial information that you submit to the server when you are making an API request. The payload can be sent or received in various formats, including JSON. Usually, the payload is denoted using the "{}" in a query string]

Let's add new `create()` _POST method_ to our `CoffeesController`, making sure we
import both the `@Post()` and `@Body()` decorators from `@nestjs/common`.

Notice: we're using the `@Body()` decorator in our method parameters, just like
we did with `@Param()'s`.

To testing if everthing's working, let's `return body` in our method, so we can
if the payload{fn-payload} comes back with the response.

Back to `insomnia. Let's execute _POST request_ to http://localhost:300/coffees,
and pass in some arbitrary _key/values_ for the request body by selecting JSON
as our payload format.

We're going to pass in any sort of JSON shape, so enter whatever you fill like.

[source, json]
----
{
    "name": "Old Florida Roast",
    "brand": "Salemba Brew"
}
----

As we can see, the _request Body_ is automatically accessed from within our
endpoint method!.

=== Access Specific Request

Sometimes we don't want to access entire body. If we want to access just
a specific portion of it, we can actually pass in a String to the
`@Body(/* String here */)` decorator, just like we do with `@Param()`.

[source, javascript]
----
import { Controller, Get, Param, Post, Body } from '@nestjs/common';

@Controller('coffees')
export class CoffeesController {
    @Get('flavors')
    findAll() {
        return "This action returns all the coffers.";
    }

    @Get(':id')
    findOne(@Param('id') id: string) {
        return `This action returns #${id} the coffers.`;
    }

    @Post()
    create(@Body('name') body) {
        return body;
    }
}
----

Let's test it out by adding the String `'name'` inside and save our changes.

Back over to `insomnia`. Let's hit the endpoint again. But this time we'll see
that we only get the `_name` value_ returned. It worked!.

When using this approach, just keep in mind that you may run into *potential
validation* issues by doing this. Because if we access ta specific properties,
other properties WON'T be validated. So, use this with *CAUTION*.

Let's *revert these changes* and remove `name` from our `@Body()` decorator.
Let's save everything and test the endpoint again in `insomnia`, just to make
sure.

Great, we see the entire Body response being passed back again!.


**⬆xref:_table_of_contents[back to top]**
//}}}

















**⬆xref:_table_of_contents[back to top]**
