//{{{ ** ASCIIDOC HEADER
:description:   SRS 7Express
:url-repo:      https://my-git-repo.com
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Mon Mar 22 05:22:36 AM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
//}}}

= Chapter-2 Getting Started with nestJS
:figure-caption!:
:source-highlighter: highlight.js

//{{{== Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_creating_a_basic_controller[Creating a Basic Controller]
|====

//**⬆xref:_use_case_number_specification[back to top]**
/*}}}*/

//{{{== Creating a Basic Controller
[[_creating_a_basic_controller]]
== Creating a Basic Controller

_Controllers_ are one of the most important building blocks of NestJS
applications as they *_handle request_*.

Let's generate a Controllers with Nest CLI by running

[source, bash]
----
$ nest generate controller
//or
$ nest g co
----

Since were working with our amazing new app called `iluvecoffe`, let's call our
first controller `coffees`

[source, bash]
----
$ nest g co
? What name would you like to use for the controller? coffees
CREATE src/coffees/coffees.controller.spec.ts (499 bytes)
CREATE src/coffees/coffees.controller.ts (103 bytes)
UPDATE src/app.module.ts (340 bytes)
----

As we can see in our terminal, Nest automatically created a Controller and
a corresponding *test* file (`.coffees.controller.spec.ts`) for us.

Also, we can see it updated module in our `AppModule`. If we open up the `app.module.ts`,

[source, javascript]
----
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { CoffeesController } from './coffees/coffees.controller';

@Module({
    imports: [],
    controllers: [AppController, CoffeesController],
    providers: [AppService],
})
export class AppModule {}
----

We'll see that the CLI automatically added this new `CoffeesController` to the
`controller:[]` array.

Note, that if we didn't want to genrate a *test* file, we could have simply
passed the `--no-spec` flag like so.

[source, bash]
----
$ nest g co --no-spec
----

Now, taking a look back at our project structure, we can see the files we just
created ended up in a directory based on the name we selected, in our case:
`/src/coffees/`

[source, bash]
----
├── nest-cli.json
├── package.json
├── package-lock.json
├── README.md
├── src
│   ├── app.controller.spec.ts
│   ├── app.controller.ts
│   ├── app.module.ts
│   ├── app.service.ts
│   ├── coffees                             <<<<
│   │   ├── coffees.controller.spec.ts      <<<<
│   │   └── coffees.controller.ts           <<<<
│   └── main.ts
├── test
│   ├── app.e2e-spec.ts
│   └── jest-e2e.json
├── tsconfig.build.json
└── tsconfig.json
----

If we want to generate something within a specific folder, just type in the
_directory_ or _directories_ which slashes `/` prior to the Controllers name,

[source, bash]
----
$ nest g co --no-spec modules/abc
----

For example, Nest generate Controllers `module/abc`, will be placed within `/src/module/abc`.

If you are not sure if the generator will place the file in the right directory,
use `--dry-run` flag to see the simulated output form the CLI,

[source, bash]
----
$ nest generate controller modules/abc --dry-run
CREATE src/modules/abc/abc.controller.spec.ts (471 bytes)
CREATE src/modules/abc/abc.controller.ts (95 bytes)
UPDATE src/app.module.ts (417 bytes)
----

This *_won't actually create any files_*. So it's a perfect way of testing any
command to see what it will do, and where it might _place things_.

Back to our newly created `CoffeesController`.

[source, javascript]
----
import { Controller } from '@nestjs/common';

@Controller('coffees')
export class CoffeesController {}
----

As we previously saw, the basic building blocks of Controllers in NestJS are
*_classes_* and *_decorators_*.

We know that Controllers are something that _handle *request_* in our
application. But how does the application know which _URL_ accesses 'which'
Controller?

// XXX Footnote XXX
:fn-tying: footnote:[binding]

You might already spotted it here, but the `@Controller()` decorator, can be
passed a _String_. This String then passed the _metadata_ needed for Nest to
create a *_routing map_*. Tying{fn-tying} incoming request to this
*corresponding controller*. In the case of our `CoffeesController`, we can see
it has the string of `'coffees'` passed to the _decorator_. Tying the `/coffees`
URL for our application to this controller.

If we open up `insomnia` or `postman` and make request a 'GET' request to
`http://localhost:3000/coffees`, we are going to see _`404`-error_.

[source, json]
----
{
    "statusCode": 404,
    "message": "Cannot GET /coffees",
    "error": "Not Found"
}
----

We have the Controller setup, but it's empty; and as the error message is
hinting to us *"Cannot GET /coffees"*; We haven't actually set up a *_'GET'
route_* in this Controller just yet!.

Luck for us, Nest _has_ decorators for all the _common HTTP verbs_, all includes
in the `@nestjs/common` package, making this as easy as can be.

[source, javascript]
----
import { Controller, Get } from '@nestjs/common';

@Controller('coffees')
export class CoffeesController {
    @Get()                                                   //[2]
    findAll() {                                               //[1]
        return "This action returns all the coffers.";        //[3]
    }
}
----

Inside our `CoffeesController`, let's create a _'GET HTTP'-*handler_*, using one
of the Nest decorators. Start by creating a method inside the controller. The
name of the method itself doesn't matter, but let's called `findAll()`; as this
request, will be use to *fetch all the result* for this controller.

Now, let's decorate this method with the `@GET()` decorator; Make sure to import
it from `@nestjs/common`.

For now, let's just add a quick `return` statement and echo some text back.
Let's return a string that says something like, "This action returns all the coffers."

Within just like above, we mapped our first _GET_ requests within the `/coffees` route.

Other _HTTP verbs_ will be done in the same fashion; and it placed inside of
this Controller, they would be mapped to `/coffees` as well. Let's save our
progress and see if we can access this _GET-route_ from `insomnia` or `postman`.

Great, it works perfectly!. We can see that we got: "This action returns all the
coffers." back from the API just like we expected.

=== Nested URL

Now, what if we wanted to have a *_nested URL_* for this specific GET-request?
Just as we saw with Controllers, all of the HTTP decorator's take _one
parameter_, a *String*; which create a "*nested-path*" and appends it to the one
included form the controller itself.

[source, javascript]
----
import { Controller, Get } from '@nestjs/common';

@Controller('coffees')
export class CoffeesController {
    @Get('flavors')                 //<<<<
    findAll() {
        return "This action returns all the coffers.";
    }
}
----

If we updated our GET request, to `@GET('flavors')`, we can now access this
route via `/coffees/flavors`. Let's save our changes, and head back to
`insomnia` and hit this new endpoint `/coffees/flavors`. Perfect, the routes
works at its new nested URL.

Everything we've shown so far gives  us amazing control and flexibility over our
_HTTP verbs_. Making them easy to read, and uniform throughout our application.

**⬆xref:_table_of_contents[back to top]**
//}}}
