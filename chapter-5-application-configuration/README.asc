//{{{ ** ASCIIDOC HEADER
:description:   nestjs official course | chapter-4
:url-repo:      https://github.com/agungTuanany/nestjs_course_official
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Fri Apr  2 07:50:12 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
//}}}

[[_chapter_5_application_configuration]]
= Chapter-5 Application Configuration
:figure-caption!:
:source-highlighter: highlight.js

//{{{== Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_introduction_the_config_module[Introduction The Config Module]
| 2.    | xref:_custom_environment_file_paths[Custom Environment File Paths]
| 3.    | xref:_schema_validation[Schema Validation]
| 4.    | xref:_using_the_config_service[Using the Config Service]
| 5.    | xref:_custom_configuration_file_[Custom Configuration Files]
|====
//}}}

//{{{ 1 == Introduction The Config Module
[[_introduction_the_config_module]]
== Introduction The Config Module

//{{{ image::./images/chapter-5-1.png
[#img-chapter]
[link=./images/chapter-5-1.png]
.Introduction The Config Module
image::./images/chapter-5-1.png[align="center"]
//}}}

In today's world, our application need to be capable of running in many
different environments.  Depending on what environment we are currently in. We
may need different configuration settings to be used in order to startup or run
our application properly.

//{{{ image::./images/chapter-5-2.png
[#img-chapter]
[link=./images/chapter-5-2.png]
.Introduction The Config Module - 2
image::./images/chapter-5-2.png[align="center"]
//}}}

For example, if we are running our application in our "*Local* - Environment" we
may rely on a specific "database - credentials", but it's only for our "Local
- *database instance*".

The same goes for our "*Production* - Environment", which would have completely
different setup of "database - credentials".

It's a *_common best practice_* in the NodeJS community to store these
*"configuration - variables"*, as a part of their environment in the NodeJS
*"global - `"process.env"` - Object"*.

To help us utilize this *"global - `"process.env"` - Object"* in a more
"automated - fashion" Nest provides us with a package called
`*"@nestjs/config"*` which has several useful features that we will showcase in
the next few lessons.

Let's get everything setup in our application to see it in action.

If we head over to our terminal, let's type in:

//{{{ $ npm install --save nestjs/config
[source, shell]
----
$ npm install --save nestjs/config
----
//}}}

We'll continue ahead as we already have it installed. But if you are following
along, just pause in a second and come back when it's finished.

Once the installation is complete, Let's open our "AppModule" - file, and add
"ConfigModule" from `@nestjs/config`, to our `imports:[]` Array.

//{{{ // app.module.ts
[source, typescript]
----
// app.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import{ ConfigModule } from "@nestjs/config";                   // <<<

...
...

@Module({
    imports: [
        ConfigModule.forRoot(),
        CoffeesModule,
        TypeOrmModule.forRoot({
            ...
            ...
        }),
        CoffeeRatingModule,
        DatabaseModule,
    ],
    controllers: [AppController],
    providers: [AppService],
})
export class AppModule {}
----
//}}}

Now, let's call `forRoot()` - "static method" on it (`ConfigModule.forRoot()`).
Which will load and parser our `*".env"*` - file from the default location,
which is our "project - Root directory".

The `"ConfigModule"` is also going to merge "key/value - pairs" from the
`*".env"*` - file with "environment - variables" assigned to `"process.env"`,
storing the result in a *"private structure"* that we can access anywhere in our
application via a "ConfigService" - class. More that in a moment.

But wait, what is this `*".env"*` - file? We don't have one in our applications!.

In NodeJS applications, it's common to use `*".env"*` - files to hold "key/value
- pairs" of "important application *configuration - data*", whether they are
a "SECRET - KEYS", "DATABASE - OPTIONS", "PASSWORDS", etc..

With the help these `*".env"*` - files, running an app in "*different*
- environments", just becomes a matter of swapping in the correct `*".env"*`
- file.

So let's create our first `*".env"*` - file in our "project Root - directory".
Open up this file and let's add a few "configuration key/value - pairs".

//{{{ .env
[source, typescript]
----
// .env
/*
* CAUTION:  never SUBMIT or PUSH this crendential '.env' - file in github or tracked on Git!.
* This only for course and education purpose.
*/

DATABASE_USER=postgres
DATABASE_PASSWORD=pass123
DATABASE_NAME=postgres1
DATABASE_PORT=5432
DATABASE_HOST=localhost
----
//}}}

As you can see all the variables we defined are related to our "database
- configuration", with their values taken from our "Docker - Compose" - file.
Since all these values will vary by environment.  This is exactly why we want to
take advantage of something like this  `*".env"*` - file, instead of hard-coding
these "configuration - values" in our application code.

NOTE: ALWAYS remember that the `*".env"*` - file with "*real* - credentials" and
"*secret* - key" *NEVER* be tracked by Git!.

To make sure that `*".env"*` - file *won't* be "pushed - out" to our *repo*.
Let's open up our `".gitignore"` - file and add the following lines.

//{{{ .gitignore
[source, shell]
----
//.gitignore
...
...

# Env
*.env
----
//}}}

With these in place, let's open up the "AppModule" again, and update the
"options - object" pass into the `"TypeOrmModule"`, and start leverage these
"environmental - variables" we just provided, replacing those previous "hard-coded - values".

//{{{ // app.module.ts
[source, typescript]
----
// app.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import{ ConfigModule } from "@nestjs/config";

...
...

@Module({
    imports: [
        ConfigModule.forRoot(),
        CoffeesModule,
        TypeOrmModule.forRoot({
            type: "postgres",
            host: process.env.DATABASE_HOST,
            port: process.env.DATABASE_PORT,,
            username: process.env.DATABASE_USER,
            password: process.env.DATABASE_PASSWORD,
            database: process.env.DATABASE_NAME,
            autoLoadEntities: true,
            synchronize: true, // COMMENT THIS in production - mode
        }),
        CoffeeRatingModule,
        DatabaseModule,
    ],
    controllers: [AppController],
    providers: [AppService],
})
export class AppModule {}
----
//}}}

Note that by default. Every *"value"* that comes from `*"process.env"*` is a String.
This is why we get an error, for "DATABASE_PORT".

//{{{ Type Error
[source, shell]
----
src/app.module.ts:18:13 - error TS2322: Type 'string' is not assignable to type 'number'.

18             port: process.env.DATABASE_PORT,
               ~~~~
----
//}}}

But if we cast it to a number by adding a simple *"plus"* (`+`) - symbols before it, we are all set.

//{{{ port: +process.env.DATABASE_PORT,
[source, typescript]
----
port: +process.env.DATABASE_PORT,
----
//}}}

Now, let's fire up the app in "development" mode with,

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
[Nest] 2993860   - 04/02/2021, 9:03:58 PM   [NestFactory] Starting Nest application...
[Nest] 2993860   - 04/02/2021, 9:03:58 PM   [InstanceLoader] TypeOrmModule dependencies initialized +49ms
...
...
[Nest] 2993860   - 04/02/2021, 9:03:59 PM   [InstanceLoader] TypeOrmCoreModule dependencies initialized +119ms
[Nest] 2993860   - 04/02/2021, 9:03:59 PM   [InstanceLoader] TypeOrmModule dependencies initialized +1ms 	//<<<
...
...
----
//}}}

If we look carefully, we should see "*TypeOrmModule dependencies initialized*".

Just like before we successfully established a conection to our "Docker
- Postgres" - database.  But now we are using the configuration loaded from our
"current - environment!.

=== Reference

- link:https://docs.nestjs.com/techniques/configuration#configuration[NestJS Configuration Techniques]

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 2 == Custom Environment File Paths
[[_custom_environment_file_paths]]
== Custom Environment File Paths

By default, the "ConfigModule" we've set up in the previous lesson, look for `*".env"*` - file in
the "root - directory" of our application.

To specify another path for this file. Let's pass in an "*options* - Object"
into `.forRoot()` - method, and set the  `*"envFilePath:"*`- property like so.

//{{{ // app.module.ts
[source, typescript]
----
// app.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import{ ConfigModule } from "@nestjs/config";

...
...

@Module({
    imports: [
        ConfigModule.forRoot({
            envFilePath: [".env", ".environment"],
            // ignoreEnvFile: true,
        }),
        CoffeesModule,
        TypeOrmModule.forRoot({
            type: "postgres",
            host: process.env.DATABASE_HOST,
            port: process.env.DATABASE_PORT,,
            username: process.env.DATABASE_USER,
            password: process.env.DATABASE_PASSWORD,
            database: process.env.DATABASE_NAME,
            autoLoadEntities: true,
            synchronize: true, // COMMENT THIS in production - mode
        }),
        CoffeeRatingModule,
        DatabaseModule,
    ],
    controllers: [AppController],
    providers: [AppService],
})
export class AppModule {}
----
//}}}

In this example, we are looking instead for a `*".environment"*` - file. We
could also specify multiple paths for `".env"*` - files by passing an Array of
Strings instead.

NOTE: Just know that, if the same 'variable' is *found* in multiple files, the
*FIRST* - instance found takes *precedence* over the rest.

When deploying your application to a "*Production*  - Environment". You might
not need a `*".env"*` - file be setting all of the "configuration - variables",
via your "provider  - UI". Let's say for example: "Heroku" or something similar.

In that case, you have the option to entirely disable loading `*".env"*` - file
by simply adding `*"ignoreEnvFile:"*`  in your "ConfigModule" - options Object.

With just like that, your `*".env"*` - file will be ignored by the
"ConfigModule" entirely!.

=== Reference

- link:https://docs.nestjs.com/techniques/configuration#custom-env-file-path[Custom File Path]

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 3 == Schema Validation
[[_schema_validation]]
== Schema Validation
:fn-joi: footnote:[The most powerful schema description language and data validator for JavaScript | https://github.com/sideway/joi]

"Environment - variables" we set are essential to our application starting up
and running properly.  Since our application depends on them. We need to make
sure that we have all the "required - variables" we need, so we can connect with
the correct databases, etc.

It is a best practice to "*throw an Exception*" during application startup, if
any "*requirement environment* - variables" have not been provided, or if they
do not meet certain "validation - rules".

The `@nest/config` - package, let's us take advantage of the *"joi"*{fn-joi}
- package to make sure any important "environment - variables" are *validated*.

With *"joi"*, you can define an "Object - Schema" and validate JavaScript
- Objects against it. To get started with *"joi"*, let's install a few packages.

//{{{ $ npm install --save @hapi/joi @types/hapi__joi
[source, shell]
----
$ npm install --save @hapi/joi @types/hapi__joi
----
//}}}

For our *"regular - dependencies"* we need `*"@hapi/joi"*`. For our
*"devDependencies"*, we'll want to make sure we have `*"@types/hapi__joi"*` for
all "Type - declarations".

We'll continue ahead as we already have these packages installed, but if you are
following along. Just pause a second and come back when it's finished.

Now that everything is installed. Let's define our first "*joi* - Validation
Schema"

Inside our `"ConfigModule.forRoot()"` - method. We have the `validationSchema`
- property available to us. Let's use that to ensure "certain - environment variables"
are passed in, and in the correct format.

Let's put all of these "variables - tests" inside of `*"Joi.object({})"*`.

//{{{ // app.module.ts
[source, typescript]
----
// app.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import{ ConfigModule } from "@nestjs/config";
import * as Joi from "@hapi/joi";

...
...

@Module({
    imports: [
        ConfigModule.forRoot({
            validationSchema: Joi.object({
                DATABASE_HOST: Joi.required(),              // <<<
                DATABASE_PORT: Joi.number().default(5432),  // <<<
          })
        }),
        CoffeesModule,
        TypeOrmModule.forRoot({
            type: "postgres",
            host: process.env.DATABASE_HOST,
            port: process.env.DATABASE_PORT,,
            username: process.env.DATABASE_USER,
            password: process.env.DATABASE_PASSWORD,
            database: process.env.DATABASE_NAME,
            autoLoadEntities: true,
            synchronize: true, // COMMENT THIS in production - mode
        }),
        CoffeeRatingModule,
        DatabaseModule,
    ],
    controllers: [AppController],
    providers: [AppService],
})
export class AppModule {}
----
//}}}

Make that sure that `"Joi.object()"` is imported from the `@happi/joi` - package. By default,
all - *"schema - keys"* are considered *optional*.

But, you can see here we are marking `"DATABASE_HOST"` as *required*, using
`Joi.required()`.  For "DATABASE_PORT", we are setting a "default - value" if
*NONE* is passed in a requiring that it must "parse-able" to a Number.

Now, let's fire up our terminal to see if everything works properly so far.

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
[!] DatabaseModule - dynamic module instantiated
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [NestFactory] Starting Nest application...
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] TypeOrmModule dependencies initialized +64ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] DatabaseModule dependencies initialized +0ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] DatabaseModule dependencies initialized +0ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] ConfigHostModule dependencies initialized +1ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] AppModule dependencies initialized +0ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] ConfigModule dependencies initialized +0ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] TypeOrmCoreModule dependencies initialized +94ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] TypeOrmModule dependencies initialized +1ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] CoffeeRatingModule dependencies initialized +1ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] CoffeesModule dependencies initialized +0ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [RoutesResolver] AppController {}: +10ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [RouterExplorer] Mapped {, GET} route +5ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [RoutesResolver] CoffeesController {/coffees}: +1ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [RouterExplorer] Mapped {/coffees, GET} route +1ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [RouterExplorer] Mapped {/coffees/:id, GET} route +0ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [RouterExplorer] Mapped {/coffees, POST} route +1ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [RouterExplorer] Mapped {/coffees/:id, PATCH} route +1ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [RouterExplorer] Mapped {/coffees/:id, DELETE} route +0ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [NestApplication] Nest application successfully started +5ms
----
//}}}

Great. Since we have "both - variables" *defined*. The application bootstrapped
successfully.

Now, let's open up our `*".env"*` - file and just for testing purpose, *remove*
the "DATABASE_HOST" line and save.

//{{{ .env
[source, typescript]
----
// .env
/*
* CAUTION:  never SUBMIT or PUSH this crendential '.env' - file in github or tracked on Git!.
* This only for course and education purpose.
*/

DATABASE_USER=postgres
DATABASE_PASSWORD=pass123
DATABASE_NAME=postgres1
DATABASE_PORT=5432
#DATABASE_HOST=localhost
----
//}}}

NOTE: To trigger Nest application reload, we must save a TypeScript (.ts) - file
The "Nest -CLI" does not watch for changes in `*".env"*` - files by default.

So, just go ahead and open ay TypeScript - file in our `/src/` - folder and hit
save to trigger our compilation.

If we had back to our terminal.

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
/home/User/Project/iluvcoffe/node_modules/@nestjs/config/dist/config.module.js:61
                throw new Error(`Config validation error: ${error.message}`);
                ^

Error: Config validation error: "DATABASE_HOST" is required     // <<<
...
...
----
//}}}

We can see the "Config validation error" appeared in the console, as expected.
Since we didn't provided that "DATABASE_HOST".

It looks our validation is set-up perfectly!.

Although we just barely scratched the surface here. You can see the potential in
this type of VALIDATION, especially with "large - configuration sets"

=== Reference

- link:https://docs.nestjs.com/techniques/configuration#schema-validation[Schema Validation]

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 4 == Using the Config Service
[[_using_the_config_service]]
== Using the Config Service

The "ConfigModule" we've setup in our application, comes with a useful *SERVICE* called *"ConfigService"*.
This service provides a `"get()"` - method for *reading* all parsed "configuration variables".

Just as we use any other "*provider*" in our Nest applications to *inject* the "ConfigService", we must first
import it's containing module: the - "ConfigModule", into any module that needs to use it.

To demonstrate this. Let's open up the "CoffeesModule" and import the "ConfigModule" here.

//{{{ // coffees.module.ts
[source, typescript]
----
// coffees.module.ts
import {Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import { ConfigModule } from "@nestjs/config";

import { CoffeesController } from "./coffees.controller";
import { CoffeesService } from "./coffees.service";
import { Coffee } from "./entities/coffee.entity";
import { Flavor } from "./entities/flavor.entity";
import { Event } from "../events/entities/event.entity";

@Module({
    imports: [
        TypeOrmModule.forFeature([Coffee, Flavor, Event]),
        ConfigModule,                   // <<<
    ],
    controllers: [CoffeesController],
    providers: [CoffeesService],
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

Remember, we use `"forRoot()"` - method in our main "AppModule", but we only do that once.
Here, we won't need to do anything else.

Now, let's navigate to the "CoffeesService" - file, and *inject* the "ConfigService" imported from `@nesjs/config`
into the `constructor()`.

//{{{ // coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, Inject, NotFoundException, Scope } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Connection, Repository } from "typeorm";
import { ConfigService } from "@nestjs/config";

...
...

@Injectable({ scope: Scope.REQUEST })
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,
        private readonly connection: Connection,
        private readonly configService: ConfigService,      // <<<
    ) {
        console.log("[!!] CoffeesService instantiated");
    }

    ...
    ...
}
----
//}}}

As we were saying a moment ago.
This "ConfigService"  provide a `"get()"` - method for reading "configuration - variables".
You can get a *single* - "environment - variable", by passing the "variable - name".

To test it out. Let's add the following code in our "CoffeesService" - constructor.

//{{{ // coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, Inject, NotFoundException, Scope } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Connection, Repository } from "typeorm";
import { ConfigService } from "@nestjs/config";

...
...

@Injectable({ scope: Scope.REQUEST })
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,
        private readonly connection: Connection,
        private readonly configService: ConfigService,
    ) {
        const databaseHost = this.configService.get<string>("DATABASE_HOST"); // <<<

        console.log("[!!] CoffeesService instantiated");
        console.log(`[!!] ConfigService - "DATABASE_HOST": - "${databaseHost}"`); // <<<
    }

    ...
    ...
}
----
//}}}

Note the Type argument String (`"get<string>()"`). It instruct TypeScript that we expect "String - value" here.
However it's just information for the compiler. Even if we specified Number instead, the real value will be String.

NOTE: Remember that every "environment - variable" is a *String* by *default*.

The "ConfigService" will *NOT* perform any type *casting* or *passing* here. So make sure you are doing any "*Type - conversions*"
necessarily with these variables.

All right, let's fire up the terminal and look to see if the console - outputs anything.

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
...
...
[Nest] 693727   - 04/03/2021, 10:52:47 AM   [InstanceLoader] TypeOrmModule dependencies initialized +1ms
[!!] CoffeesService - instantiated
[!!] ConfigService - "DATABASE_HOST": - "localhost"
[Nest] 693727   - 04/03/2021, 10:52:47 AM   [InstanceLoader] CoffeeRatingModule dependencies initialized +1ms
...
...
----
//}}}

Great. We can see that `"localhost"` got logged in our console.

The `"get()"` - method also takes an *_optional_* - "second argument". Which allows you set a *"default"* - value, to be used
if the *key* does "NOT exist".

//{{{ // coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, Inject, NotFoundException, Scope } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Connection, Repository } from "typeorm";
import { ConfigService } from "@nestjs/config";

...
...

@Injectable({ scope: Scope.REQUEST })
export class CoffeesService {
    constructor(
	...
	...
    ) {
        const databaseHost = this.configService.get<string>("DATABASE_HOST", "localhost"); // <<<

        console.log("[!!] CoffeesService instantiated");
        console.log(`[!!] ConfigService - "DATABASE_HOST": - "${databaseHost}"`);
    }

    ...
    ...
}
----
//}}}

Now even if we don't set "DATABASE_HOST", our application will fall back to the value "localhost".

This is extremely helpful in setting some "sane default" in our application, in situation where some environments
may not pass all the "key/value" we need!.

=== Reference

- link:https://docs.nestjs.com/techniques/configuration#using-the-configservice[Using the "ConfigService"]

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ == Custom Configuration Files
[[_custom_configuration_file_]]
== Custom Configuration Files

For more complex projects. We may need custom configuration files to return
"nested - Objects", these "custom - config" - files can allow us to group
related "configuration settings", by *"business domain"*.

Let's say for example that we want to group all of our "database" related
settings together.  This gives us the ability to store related settings in
individual files, and manage them independently.

For demonstration purposes. Let's create a new file named `"app.config.ts"` in
the `"/src/config"` - directory, which we will use to represent our *"global"*
application configuration.

In this newly created file. Let's export our *"factory"* - function that returns
a "configuration - object".

//{{{ // app.config.ts
[source, typescript]
----
// app.config.ts
export default () => ({
    environment: process.env.NODE_ENV || "development",
    database: {
        host: process.env.DATABASE_HOST,
        port: parseInt(process.env.DATABASE_PORT, 10) || 5432
    }
})
----
//}}}

The 'configuration - object" *CANNOT* by any arbitrary nested plain JavaScript
- Object.

The `"process.env"` - Object will contain the fully resolved environment
variable "key/value - pairs", from our `*.env"*` - file.

Since we have full control of the returned "configuration - object", we can add
any "required - logic", to cast the values to "appropriate - Types", set any
default values needed, anything would like!.

In our example here, you can see that we specified an Object with "two
- properties", `*"environment"*` and `*"database"*`.  The *"environment"*`
- String represents the "current - environment", while `*"database"*` is an
Object that has `"host"` and `"port"` - properties, grouping any
configuration related to our "database - connection" here.

As you can see, we are parsing "DATABASE_PORT" to a Number as every
`"process.env"` variable is a String by *default*.

We even set-up our "fall-back" - value `"port"`, in case none was provided.

So, how can w utilize this new - "configuration - files" we created?.

If we open up the "AppModule" and look at our `"ConfigModule.forRoot()"` again,
we can pass in a new property called `*"load"*`, which takes in an Array of
"configuration - factories".

//{{{ // app.module.ts
[source, typescript]
----
// app.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import{ ConfigModule } from "@nestjs/config";
import appConfig from "./config/app.config";

...
...

@Module({
    imports: [
        ConfigModule.forRoot({
            load: [appConfig]   // <<<
        }),
        CoffeesModule,
        TypeOrmModule.forRoot({
            ...
            ...
        }),
        CoffeeRatingModule,
        DatabaseModule,
    ],
    controllers: [AppController],
    providers: [AppService],
})
export class AppModule {}
----
//}}}

Inside this Array we can pass in ur new - `*"appConfig"*`, making sure to import
it from the correct location, and we are wired up.

Great!. So how we can access this `"appConfig"` - object from within our classes
now? Well, we can actually use the "ConfigService" from the previous lesson.

The `"ConfigService.get()"` - method not only allows you to retrieve the
"environment - variable" by *"key"*, but it can ALSO traverse a nested "custom
- configuration" - Object we created in our "custom - config" - file!.

Let's open up the "CoffeesService" - file, and update our code to use it!.

//{{{ // coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, Inject, NotFoundException, Scope } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Connection, Repository } from "typeorm";
import { ConfigService } from "@nestjs/config";

...
...

@Injectable({ scope: Scope.REQUEST })
export class CoffeesService {
    constructor(
	...
	...
    ) {

        const databaseHost = this.configService.get<string>("database.host", "localhost");
        console.log(`[!!] ConfigService - "DATABASE_HOST": - "${databaseHost}"`);
    }

    ...
    ...
}
----
//}}}

First, let's remove the String `"DATABASE_HOST"` that is the name of the
`".env"` - file *_key_*, and access our custom "configuration - object" instead
by entering: `"database.host"`.

While we are added at it, let's also remove the "Type -assertion" (`<string>`)
since it is a default Type anyway.

All right, let's fire up the terminal and check to make sure our application still
runs properly.

Perfect, we can see the `[!!] ConfigService - "DATABASE_HOST": - "localhost"` is
still showing up in our console.  But how did this works?.

When we pass `"database.host"` to the `"ConfigService.get()"` - method.  This
*"dot - notation"* - naming format, is in fact a *"path"* to our `"host"`
- property.

If you look up the "appConfig" - file again, you will see this Object. To access
the `"host"` - property we need to traverse this Object and pass in the `"dot
- notation"` name you would use to access it normally in JavaScript.

While this approach is acceptable for relatively simple configurations that do
not have large deep "nested - structures". This might quickly become
*"un-maintainable"* for complex "configuration Object" - hierarchies.

This is because with this approach there is no "Type - *inference*" and we keep
entering magical Strings to access these values, which can potentially lead to
more errors,just from a small typo!.

For more sophisticated structures. We'll use another features called
"configuration -  *namespaces*" in the next lesson, that help tackle some of
these shortcomings.

**⬆xref:_table_of_contents[back to top]**
//}}}

//**⬆xref:_table_of_contents[back to top]**
