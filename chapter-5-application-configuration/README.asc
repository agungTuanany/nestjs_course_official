//{{{ ** ASCIIDOC HEADER
:description:   nestjs official course | chapter-4
:url-repo:      https://github.com/agungTuanany/nestjs_course_official
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Fri Apr  2 07:50:12 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
//}}}

[[_chapter_5_application_configuration]]
= Chapter-5 Application Configuration
:figure-caption!:
:source-highlighter: highlight.js

//{{{== Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_introduction_the_config_module[Introduction The Config Module]
| 2.    | xref:_custom_environment_file_paths[Custom Environment File Paths]
| 3.    | xref:_schema_validation[Schema Validation]
| 4.    | xref:_using_the_config_service[Using the Config Service]
| 5.    | xref:_custom_configuration_file_[Custom Configuration Files]
| 6.    | xref:_configuration_namespaces_and_partial_registration[Configuration Namespaces and Partial Registration]
| 7.    | xref:_asynchronously_configure_dynamic_modules[Asynchronously Configure Dynamic Modules]
|====
//}}}

//{{{ 1 == Introduction The Config Module
[[_introduction_the_config_module]]
== Introduction The Config Module

//{{{ image::./images/chapter-5-1.png
[#img-chapter]
[link=./images/chapter-5-1.png]
.Introduction The Config Module
image::./images/chapter-5-1.png[align="center"]
//}}}

In today's world, our application need to be capable of running in many
different environments.  Depending on what environment we are currently in. We
may need different configuration settings to be used in order to startup or run
our application properly.

//{{{ image::./images/chapter-5-2.png
[#img-chapter]
[link=./images/chapter-5-2.png]
.Introduction The Config Module - 2
image::./images/chapter-5-2.png[align="center"]
//}}}

For example, if we are running our application in our "*Local* - Environment" we
may rely on a specific "database - credentials", but it's only for our "Local
- *database instance*".

The same goes for our "*Production* - Environment", which would have completely
different setup of "database - credentials".

It's a *_common best practice_* in the NodeJS community to store these
*"configuration - variables"*, as a part of their environment in the NodeJS
*"global - `"process.env"` - Object"*.

To help us utilize this *"global - `"process.env"` - Object"* in a more
"automated - fashion" Nest provides us with a package called
`*"@nestjs/config"*` which has several useful features that we will showcase in
the next few lessons.

Let's get everything setup in our application to see it in action.

If we head over to our terminal, let's type in:

//{{{ $ npm install --save nestjs/config
[source, shell]
----
$ npm install --save nestjs/config
----
//}}}

We'll continue ahead as we already have it installed. But if you are following
along, just pause in a second and come back when it's finished.

Once the installation is complete, Let's open our "AppModule" - file, and add
"ConfigModule" from `@nestjs/config`, to our `imports:[]` Array.

//{{{ // app.module.ts
[source, typescript]
----
// app.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import{ ConfigModule } from "@nestjs/config";                   // <<<

...
...

@Module({
    imports: [
        ConfigModule.forRoot(),
        CoffeesModule,
        TypeOrmModule.forRoot({
            ...
            ...
        }),
        CoffeeRatingModule,
        DatabaseModule,
    ],
    controllers: [AppController],
    providers: [AppService],
})
export class AppModule {}
----
//}}}

Now, let's call `forRoot()` - "static method" on it (`ConfigModule.forRoot()`).
Which will load and parser our `*".env"*` - file from the default location,
which is our "project - Root directory".

The `"ConfigModule"` is also going to merge "key/value - pairs" from the
`*".env"*` - file with "environment - variables" assigned to `"process.env"`,
storing the result in a *"private structure"* that we can access anywhere in our
application via a "ConfigService" - class. More that in a moment.

But wait, what is this `*".env"*` - file? We don't have one in our applications!.

In NodeJS applications, it's common to use `*".env"*` - files to hold "key/value
- pairs" of "important application *configuration - data*", whether they are
a "SECRET - KEYS", "DATABASE - OPTIONS", "PASSWORDS", etc..

With the help these `*".env"*` - files, running an app in "*different*
- environments", just becomes a matter of swapping in the correct `*".env"*`
- file.

So let's create our first `*".env"*` - file in our "project Root - directory".
Open up this file and let's add a few "configuration key/value - pairs".

//{{{ .env
[source, typescript]
----
// .env
/*
* CAUTION:  never SUBMIT or PUSH this crendential '.env' - file in github or tracked on Git!.
* This only for course and education purpose.
*/

DATABASE_USER=postgres
DATABASE_PASSWORD=pass123
DATABASE_NAME=postgres1
DATABASE_PORT=5432
DATABASE_HOST=localhost
----
//}}}

As you can see all the variables we defined are related to our "database
- configuration", with their values taken from our "Docker - Compose" - file.
Since all these values will vary by environment.  This is exactly why we want to
take advantage of something like this  `*".env"*` - file, instead of hard-coding
these "configuration - values" in our application code.

NOTE: ALWAYS remember that the `*".env"*` - file with "*real* - credentials" and
"*secret* - key" *NEVER* be tracked by Git!.

To make sure that `*".env"*` - file *won't* be "pushed - out" to our *repo*.
Let's open up our `".gitignore"` - file and add the following lines.

//{{{ .gitignore
[source, shell]
----
//.gitignore
...
...

# Env
*.env
----
//}}}

With these in place, let's open up the "AppModule" again, and update the
"options - object" pass into the `"TypeOrmModule"`, and start leverage these
"environmental - variables" we just provided, replacing those previous "hard-coded - values".

//{{{ // app.module.ts
[source, typescript]
----
// app.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import{ ConfigModule } from "@nestjs/config";

...
...

@Module({
    imports: [
        ConfigModule.forRoot(),
        CoffeesModule,
        TypeOrmModule.forRoot({
            type: "postgres",
            host: process.env.DATABASE_HOST,
            port: process.env.DATABASE_PORT,,
            username: process.env.DATABASE_USER,
            password: process.env.DATABASE_PASSWORD,
            database: process.env.DATABASE_NAME,
            autoLoadEntities: true,
            synchronize: true, // COMMENT THIS in production - mode
        }),
        CoffeeRatingModule,
        DatabaseModule,
    ],
    controllers: [AppController],
    providers: [AppService],
})
export class AppModule {}
----
//}}}

Note that by default. Every *"value"* that comes from `*"process.env"*` is a String.
This is why we get an error, for "DATABASE_PORT".

//{{{ Type Error
[source, shell]
----
src/app.module.ts:18:13 - error TS2322: Type 'string' is not assignable to type 'number'.

18             port: process.env.DATABASE_PORT,
               ~~~~
----
//}}}

But if we cast it to a number by adding a simple *"plus"* (`+`) - symbols before it, we are all set.

//{{{ port: +process.env.DATABASE_PORT,
[source, typescript]
----
port: +process.env.DATABASE_PORT,
----
//}}}

Now, let's fire up the app in "development" mode with,

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
[Nest] 2993860   - 04/02/2021, 9:03:58 PM   [NestFactory] Starting Nest application...
[Nest] 2993860   - 04/02/2021, 9:03:58 PM   [InstanceLoader] TypeOrmModule dependencies initialized +49ms
...
...
[Nest] 2993860   - 04/02/2021, 9:03:59 PM   [InstanceLoader] TypeOrmCoreModule dependencies initialized +119ms
[Nest] 2993860   - 04/02/2021, 9:03:59 PM   [InstanceLoader] TypeOrmModule dependencies initialized +1ms 	//<<<
...
...
----
//}}}

If we look carefully, we should see "*TypeOrmModule dependencies initialized*".

Just like before we successfully established a conection to our "Docker
- Postgres" - database.  But now we are using the configuration loaded from our
"current - environment!.

=== Reference

- link:https://docs.nestjs.com/techniques/configuration#configuration[NestJS Configuration Techniques]

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 2 == Custom Environment File Paths
[[_custom_environment_file_paths]]
== Custom Environment File Paths

By default, the "ConfigModule" we've set up in the previous lesson, look for `*".env"*` - file in
the "root - directory" of our application.

To specify another path for this file. Let's pass in an "*options* - Object"
into `.forRoot()` - method, and set the  `*"envFilePath:"*`- property like so.

//{{{ // app.module.ts
[source, typescript]
----
// app.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import{ ConfigModule } from "@nestjs/config";

...
...

@Module({
    imports: [
        ConfigModule.forRoot({
            envFilePath: [".env", ".environment"],
            // ignoreEnvFile: true,
        }),
        CoffeesModule,
        TypeOrmModule.forRoot({
            type: "postgres",
            host: process.env.DATABASE_HOST,
            port: process.env.DATABASE_PORT,,
            username: process.env.DATABASE_USER,
            password: process.env.DATABASE_PASSWORD,
            database: process.env.DATABASE_NAME,
            autoLoadEntities: true,
            synchronize: true, // COMMENT THIS in production - mode
        }),
        CoffeeRatingModule,
        DatabaseModule,
    ],
    controllers: [AppController],
    providers: [AppService],
})
export class AppModule {}
----
//}}}

In this example, we are looking instead for a `*".environment"*` - file. We
could also specify multiple paths for `".env"*` - files by passing an Array of
Strings instead.

NOTE: Just know that, if the same 'variable' is *found* in multiple files, the
*FIRST* - instance found takes *precedence* over the rest.

When deploying your application to a "*Production*  - Environment". You might
not need a `*".env"*` - file be setting all of the "configuration - variables",
via your "provider  - UI". Let's say for example: "Heroku" or something similar.

In that case, you have the option to entirely disable loading `*".env"*` - file
by simply adding `*"ignoreEnvFile:"*`  in your "ConfigModule" - options Object.

With just like that, your `*".env"*` - file will be ignored by the
"ConfigModule" entirely!.

=== Reference

- link:https://docs.nestjs.com/techniques/configuration#custom-env-file-path[Custom File Path]

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 3 == Schema Validation
[[_schema_validation]]
== Schema Validation
:fn-joi: footnote:[The most powerful schema description language and data validator for JavaScript | https://github.com/sideway/joi]

"Environment - variables" we set are essential to our application starting up
and running properly.  Since our application depends on them. We need to make
sure that we have all the "required - variables" we need, so we can connect with
the correct databases, etc.

It is a best practice to "*throw an Exception*" during application startup, if
any "*requirement environment* - variables" have not been provided, or if they
do not meet certain "validation - rules".

The `@nest/config` - package, let's us take advantage of the *"joi"*{fn-joi}
- package to make sure any important "environment - variables" are *validated*.

With *"joi"*, you can define an "Object - Schema" and validate JavaScript
- Objects against it. To get started with *"joi"*, let's install a few packages.

//{{{ $ npm install --save @hapi/joi @types/hapi__joi
[source, shell]
----
$ npm install --save @hapi/joi @types/hapi__joi
----
//}}}

For our *"regular - dependencies"* we need `*"@hapi/joi"*`. For our
*"devDependencies"*, we'll want to make sure we have `*"@types/hapi__joi"*` for
all "Type - declarations".

We'll continue ahead as we already have these packages installed, but if you are
following along. Just pause a second and come back when it's finished.

Now that everything is installed. Let's define our first "*joi* - Validation
Schema"

Inside our `"ConfigModule.forRoot()"` - method. We have the `validationSchema`
- property available to us. Let's use that to ensure "certain - environment variables"
are passed in, and in the correct format.

Let's put all of these "variables - tests" inside of `*"Joi.object({})"*`.

//{{{ // app.module.ts
[source, typescript]
----
// app.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import{ ConfigModule } from "@nestjs/config";
import * as Joi from "@hapi/joi";

...
...

@Module({
    imports: [
        ConfigModule.forRoot({
            validationSchema: Joi.object({
                DATABASE_HOST: Joi.required(),              // <<<
                DATABASE_PORT: Joi.number().default(5432),  // <<<
          })
        }),
        CoffeesModule,
        TypeOrmModule.forRoot({
            type: "postgres",
            host: process.env.DATABASE_HOST,
            port: process.env.DATABASE_PORT,,
            username: process.env.DATABASE_USER,
            password: process.env.DATABASE_PASSWORD,
            database: process.env.DATABASE_NAME,
            autoLoadEntities: true,
            synchronize: true, // COMMENT THIS in production - mode
        }),
        CoffeeRatingModule,
        DatabaseModule,
    ],
    controllers: [AppController],
    providers: [AppService],
})
export class AppModule {}
----
//}}}

Make that sure that `"Joi.object()"` is imported from the `@happi/joi` - package. By default,
all - *"schema - keys"* are considered *optional*.

But, you can see here we are marking `"DATABASE_HOST"` as *required*, using
`Joi.required()`.  For "DATABASE_PORT", we are setting a "default - value" if
*NONE* is passed in a requiring that it must "parse-able" to a Number.

Now, let's fire up our terminal to see if everything works properly so far.

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
[!] DatabaseModule - dynamic module instantiated
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [NestFactory] Starting Nest application...
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] TypeOrmModule dependencies initialized +64ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] DatabaseModule dependencies initialized +0ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] DatabaseModule dependencies initialized +0ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] ConfigHostModule dependencies initialized +1ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] AppModule dependencies initialized +0ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] ConfigModule dependencies initialized +0ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] TypeOrmCoreModule dependencies initialized +94ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] TypeOrmModule dependencies initialized +1ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] CoffeeRatingModule dependencies initialized +1ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [InstanceLoader] CoffeesModule dependencies initialized +0ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [RoutesResolver] AppController {}: +10ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [RouterExplorer] Mapped {, GET} route +5ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [RoutesResolver] CoffeesController {/coffees}: +1ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [RouterExplorer] Mapped {/coffees, GET} route +1ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [RouterExplorer] Mapped {/coffees/:id, GET} route +0ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [RouterExplorer] Mapped {/coffees, POST} route +1ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [RouterExplorer] Mapped {/coffees/:id, PATCH} route +1ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [RouterExplorer] Mapped {/coffees/:id, DELETE} route +0ms
[Nest] 3503598   - 04/03/2021, 12:47:15 AM   [NestApplication] Nest application successfully started +5ms
----
//}}}

Great. Since we have "both - variables" *defined*. The application bootstrapped
successfully.

Now, let's open up our `*".env"*` - file and just for testing purpose, *remove*
the "DATABASE_HOST" line and save.

//{{{ .env
[source, typescript]
----
// .env
/*
* CAUTION:  never SUBMIT or PUSH this crendential '.env' - file in github or tracked on Git!.
* This only for course and education purpose.
*/

DATABASE_USER=postgres
DATABASE_PASSWORD=pass123
DATABASE_NAME=postgres1
DATABASE_PORT=5432
#DATABASE_HOST=localhost
----
//}}}

NOTE: To trigger Nest application reload, we must save a TypeScript (.ts) - file
The "Nest -CLI" does not watch for changes in `*".env"*` - files by default.

So, just go ahead and open ay TypeScript - file in our `/src/` - folder and hit
save to trigger our compilation.

If we had back to our terminal.

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
/home/User/Project/iluvcoffe/node_modules/@nestjs/config/dist/config.module.js:61
                throw new Error(`Config validation error: ${error.message}`);
                ^

Error: Config validation error: "DATABASE_HOST" is required     // <<<
...
...
----
//}}}

We can see the "Config validation error" appeared in the console, as expected.
Since we didn't provided that "DATABASE_HOST".

It looks our validation is set-up perfectly!.

Although we just barely scratched the surface here. You can see the potential in
this type of VALIDATION, especially with "large - configuration sets"

=== Reference

- link:https://docs.nestjs.com/techniques/configuration#schema-validation[Schema Validation]

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 4 == Using the Config Service
[[_using_the_config_service]]
== Using the Config Service

The "ConfigModule" we've setup in our application, comes with a useful *SERVICE* called *"ConfigService"*.
This service provides a `"get()"` - method for *reading* all parsed "configuration variables".

Just as we use any other "*provider*" in our Nest applications to *inject* the "ConfigService", we must first
import it's containing module: the - "ConfigModule", into any module that needs to use it.

To demonstrate this. Let's open up the "CoffeesModule" and import the "ConfigModule" here.

//{{{ // coffees.module.ts
[source, typescript]
----
// coffees.module.ts
import {Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import { ConfigModule } from "@nestjs/config";

import { CoffeesController } from "./coffees.controller";
import { CoffeesService } from "./coffees.service";
import { Coffee } from "./entities/coffee.entity";
import { Flavor } from "./entities/flavor.entity";
import { Event } from "../events/entities/event.entity";

@Module({
    imports: [
        TypeOrmModule.forFeature([Coffee, Flavor, Event]),
        ConfigModule,                   // <<<
    ],
    controllers: [CoffeesController],
    providers: [CoffeesService],
    exports: [CoffeesService],
})
export class CoffeesModule {}
----
//}}}

Remember, we use `"forRoot()"` - method in our main "AppModule", but we only do that once.
Here, we won't need to do anything else.

Now, let's navigate to the "CoffeesService" - file, and *inject* the "ConfigService" imported from `@nesjs/config`
into the `constructor()`.

//{{{ // coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, Inject, NotFoundException, Scope } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Connection, Repository } from "typeorm";
import { ConfigService } from "@nestjs/config";

...
...

@Injectable({ scope: Scope.REQUEST })
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,
        private readonly connection: Connection,
        private readonly config: ConfigService,      // <<<
    ) {
        console.log("[!!] CoffeesService instantiated");
    }

    ...
    ...
}
----
//}}}

As we were saying a moment ago.
This "ConfigService"  provide a `"get()"` - method for reading "configuration - variables".
You can get a *single* - "environment - variable", by passing the "variable - name".

To test it out. Let's add the following code in our "CoffeesService" - constructor.

//{{{ // coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, Inject, NotFoundException, Scope } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Connection, Repository } from "typeorm";
import { ConfigService } from "@nestjs/config";

...
...

@Injectable({ scope: Scope.REQUEST })
export class CoffeesService {
    constructor(
        @InjectRepository(Coffee)
        private readonly coffeeRepository: Repository<Coffee>,
        @InjectRepository(Flavor)
        private readonly flavorRepository: Repository<Flavor>,
        private readonly connection: Connection,
        private readonly configService: ConfigService,
    ) {
        const databaseHost = this.configService.get<string>("DATABASE_HOST"); // <<<

        console.log("[!!] CoffeesService instantiated");
        console.log(`[!!] ConfigService - "DATABASE_HOST": - "${databaseHost}"`); // <<<
    }

    ...
    ...
}
----
//}}}

Note the Type argument String (`"get<string>()"`). It instruct TypeScript that we expect "String - value" here.
However it's just information for the compiler. Even if we specified Number instead, the real value will be String.

NOTE: Remember that every "environment - variable" is a *String* by *default*.

The "ConfigService" will *NOT* perform any type *casting* or *passing* here. So make sure you are doing any "*Type - conversions*"
necessarily with these variables.

All right, let's fire up the terminal and look to see if the console - outputs anything.

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
...
...
[Nest] 693727   - 04/03/2021, 10:52:47 AM   [InstanceLoader] TypeOrmModule dependencies initialized +1ms
[!!] CoffeesService - instantiated
[!!] ConfigService - "DATABASE_HOST": - "localhost"
[Nest] 693727   - 04/03/2021, 10:52:47 AM   [InstanceLoader] CoffeeRatingModule dependencies initialized +1ms
...
...
----
//}}}

Great. We can see that `"localhost"` got logged in our console.

The `"get()"` - method also takes an *_optional_* - "second argument". Which allows you set a *"default"* - value, to be used
if the *key* does "NOT exist".

//{{{ // coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, Inject, NotFoundException, Scope } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Connection, Repository } from "typeorm";
import { ConfigService } from "@nestjs/config";

...
...

@Injectable({ scope: Scope.REQUEST })
export class CoffeesService {
    constructor(
	...
	...
    ) {
        const databaseHost = this.configService.get<string>("DATABASE_HOST", "localhost"); // <<<

        console.log("[!!] CoffeesService instantiated");
        console.log(`[!!] ConfigService - "DATABASE_HOST": - "${databaseHost}"`);
    }

    ...
    ...
}
----
//}}}

Now even if we don't set "DATABASE_HOST", our application will fall back to the value "localhost".

This is extremely helpful in setting some "sane default" in our application, in situation where some environments
may not pass all the "key/value" we need!.

=== Reference

- link:https://docs.nestjs.com/techniques/configuration#using-the-configservice[Using the "ConfigService"]

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 5 ==  Custom Configuration Files
[[_custom_configuration_file_]]
== Custom Configuration Files

For more complex projects. We may need custom configuration files to return
"nested - Objects", these "custom - config" - files can allow us to group
related "configuration settings", by *"business domain"*.

Let's say for example that we want to group all of our "database" related
settings together.  This gives us the ability to store related settings in
individual files, and manage them independently.

For demonstration purposes. Let's create a new file named `"app.config.ts"` in
the `"/src/config"` - directory, which we will use to represent our *"global"*
application configuration.

In this newly created file. Let's export our *"factory"* - function that returns
a "configuration - object".

//{{{ // app.config.ts
[source, typescript]
----
// app.config.ts
export default () => ({
    environment: process.env.NODE_ENV || "development",
    database: {
        host: process.env.DATABASE_HOST,
        port: parseInt(process.env.DATABASE_PORT, 10) || 5432
    }
})
----
//}}}

The 'configuration - object" *CANNOT* by any arbitrary nested plain JavaScript
- Object.

The `"process.env"` - Object will contain the fully resolved environment
variable "key/value - pairs", from our `*.env"*` - file.

Since we have full control of the returned "configuration - object", we can add
any "required - logic", to cast the values to "appropriate - Types", set any
default values needed, anything would like!.

In our example here, you can see that we specified an Object with "two
- properties", `*"environment"*` and `*"database"*`.  The *"environment"*`
- String represents the "current - environment", while `*"database"*` is an
Object that has `"host"` and `"port"` - properties, grouping any
configuration related to our "database - connection" here.

As you can see, we are parsing "DATABASE_PORT" to a Number as every
`"process.env"` variable is a String by *default*.

We even set-up our "fall-back" - value `"port"`, in case none was provided.

So, how can w utilize this new - "configuration - files" we created?.

If we open up the "AppModule" and look at our `"ConfigModule.forRoot()"` again,
we can pass in a new property called `*"load"*`, which takes in an Array of
"configuration - factories".

//{{{ // app.module.ts
[source, typescript]
----
// app.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import{ ConfigModule } from "@nestjs/config";
import appConfig from "./config/app.config";

...
...

@Module({
    imports: [
        ConfigModule.forRoot({
            load: [appConfig]   // <<<
        }),
        CoffeesModule,
        TypeOrmModule.forRoot({
            ...
            ...
        }),
        CoffeeRatingModule,
        DatabaseModule,
    ],
    controllers: [AppController],
    providers: [AppService],
})
export class AppModule {}
----
//}}}

Inside this Array we can pass in ur new - `*"appConfig"*`, making sure to import
it from the correct location, and we are wired up.

Great!. So how we can access this `"appConfig"` - object from within our classes
now? Well, we can actually use the "ConfigService" from the previous lesson.

The `"ConfigService.get()"` - method not only allows you to retrieve the
"environment - variable" by *"key"*, but it can ALSO traverse a nested "custom
- configuration" - Object we created in our "custom - config" - file!.

Let's open up the "CoffeesService" - file, and update our code to use it!.

//{{{ // coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, Inject, NotFoundException, Scope } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Connection, Repository } from "typeorm";
import { ConfigService } from "@nestjs/config";

...
...

@Injectable({ scope: Scope.REQUEST })
export class CoffeesService {
    constructor(
	...
	...
    ) {

        const databaseHost = this.configService.get("database.host", "localhost");
        console.log(`[!!] ConfigService - "DATABASE_HOST": - "${databaseHost}"`);
    }

    ...
    ...
}
----
//}}}

First, let's remove the String `"DATABASE_HOST"` that is the name of the
`".env"` - file *_key_*, and access our custom "configuration - object" instead
by entering: `"database.host"`.

While we are added at it, let's also remove the "Type -assertion" (`<string>`)
since it is a default Type anyway.

All right, let's fire up the terminal and check to make sure our application still
runs properly.

Perfect, we can see the `[!!] ConfigService - "DATABASE_HOST": - "localhost"` is
still showing up in our console.  But how did this works?.

When we pass `"database.host"` to the `"ConfigService.get()"` - method.  This
*"dot - notation"* - naming format, is in fact a *"path"* to our `"host"`
- property.

If you look up the "appConfig" - file again, you will see this Object. To access
the `"host"` - property we need to traverse this Object and pass in the *"dot
- notation"* name you would use to access it normally in JavaScript.

While this approach is acceptable for relatively simple configurations that do
not have large deep "nested - structures". This might quickly become
*"un-maintainable"* for complex "configuration Object" - hierarchies.

This is because with this approach there is no "Type - *inference*" and we keep
entering magical Strings to access these values, which can potentially lead to
more errors,just from a small typo!.

For more sophisticated structures. We'll use another features called
"configuration -  *namespaces*" in the next lesson, that help tackle some of
these shortcomings.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 6 == Configuration Namespaces and Partial Registration
[[_configuration_namespaces_and_partial_registration]]
== Configuration Namespaces and Partial Registration
:fn-configtype: footnote:[https://github.com/nestjs/config/blob/master/lib/types/config.type.ts]

The "ConfigModule" allows us to define and load multiple "custom configuration"
- files, with "nested - Objects", and access these variables via the "provided
- ConfigService" (from `@nestjs/config`).

But what if our application grows tremendously, and we have a very complex
"project - structure".  We may need *"feature - specific"* configuration - files
located in multiple different directories.

As we have more and more "configuration - keys", getting all of the "config
- values" using the *"un-Typed"* - `ConfigService.get()` - method, can be quite
*"error - prone"*. Since we have to use *"dot - notation"* (ie: a.b), to
retrieve" nested - items".

To prevent this from happening. Let's combine *two - techniques*:

- *Configuration - NameSpaces*, and
- *Partial Registration*.

To future proof our configuration setup!.

First, let's create a new `*"/config/"*` - directory within the `/coffees/`
- folder.  Inside this directory, let's create a new file named
`*"coffees.config.ts"*`, which we will use to represent configuration, specific
to "CoffeesModule".

Let's open our `"coffees.config.ts"` - file.  For demonstration purposes. Let's
add a configuration "foo" equal to "bar".

//{{{ // coffees.config.ts
[source, typescript]
----
// coffees.config.ts
import { registerAs } from "@nestjs/config";

export default registerAs("coffees", () => ({
    foo: "bar",
}));
----
//}}}

One "key - *difference*" compared to our `"appConfig"` we've created in the
previous lessons, is the use of `"registerAs"` - function here, which was
imported from `"@nestjs/config"`.  This `"registerAs"` - function lets us
register a *namespaced* - "configuration Object" under the `"key"` past as our
first argument - which in this case is `"coffees"`.

Alright. Which this in place let's ipen up the "CoffeesModule" - file and
register this *"coffeesConfig"* using the `"ConfigModule.forFeature()"`
- method.

//{{{ // coffees.module.ts
[source, typescript]
----
// coffees.module.ts
...
...
import coffeesConfig from "./config/coffees.config";

@Module({
    imports: [
        TypeOrmModule.forFeature([Coffee, Flavor, Event]),
        ConfigModule.forFeature(coffeesConfig)  // <<<
    ],
    controllers: [CoffeesController],
    providers: [CoffeesService],
    exports: [CoffeesService],
})
export class CoffeesModule {
    constructor() {
        console.log("[!!] CoffeesModule - instantiated");
    }
}
----
//}}}

This techniques is called *"partial - registration"*.

Thus far. We've *processed* "configuration - file" in our "root - module",
with `"ConfigModule.forRoot()"` - method.

As your application grows. You may end up with several feature-specific
"configuration - file", located in multiple different directories. Rather than
loading all of these files in the "root - module", the "ConfigModule" allows you
*register* them, close to their domain!.

Let's move onto the "CoffeesService" - `constructor()` - *definition* now, and
use the "ConfigService" to *retrieve* these "feature-level" - configurations.

To get the "coffeesConfig" - Object. Let's use the "`ConfigService.get()`"
- method again.

//{{{ // coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, Inject, NotFoundException, Scope } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Connection, Repository } from "typeorm";
import { ConfigService } from "@nestjs/config";

...
...

@Injectable({ scope: Scope.REQUEST })
export class CoffeesService {
    constructor(
	...
	...
    ) {
        const coffeesConfig = this.configService.get("coffees");
        console.log(`[!!] ConfigService - instantiated | 'coffeesConfig': -`, coffeesConfig);
    }
    ...
    ...
}
----
//}}}

This time passing our "*partial registration* - name" of "coffees". Also, let's
change the "variable - name" to "coffeesConfig".

Now let's fire up our terminal, and see what got logged in the console.

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
...
...
[Nest] 221135   - 04/04/2021, 7:02:32 AM   [InstanceLoader] TypeOrmCoreModule dependencies initialized +156ms
[Nest] 221135   - 04/04/2021, 7:02:32 AM   [InstanceLoader] TypeOrmModule dependencies initialized +1ms
[!!] CoffeesService - instantiated
[!!] ConfigService - instantiated | 'coffeesConfig': - { foo: 'bar' } // <<<
[Nest] 221135   - 04/04/2021, 7:02:32 AM   [InstanceLoader] CoffeeRatingModule dependencies initialized +9ms
[Nest] 221135   - 04/04/2021, 7:02:32 AM   [InstanceLoader] CoffeesModule dependencies initialized +1ms
...
...
----
//}}}

Great. It looks like the entire "coffeesConfig" - Object was logged back to us,
which is perfect!.

We can access "specific - properties" of this "Partial - Config", just like we
did before, using *"dot notation"* (`coffees.foo`) again.

//{{{ // coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, Inject, NotFoundException, Scope } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Connection, Repository } from "typeorm";
import { ConfigService } from "@nestjs/config";

...
...

@Injectable({ scope: Scope.REQUEST })
export class CoffeesService {
    constructor(
	...
	...
    ) {
        const coffeesConfig = this.configService.get("coffees.foo");                            // <<<
        console.log(`[!!] ConfigService - instantiated | "DATABASE_FOO": - ${coffeesConfig}`);  // <<<
    }
    ...
    ...
}
----
//}}}

Now, we'll retrieve the specific `*"foo"*` and get `*"bar"*`.

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
...
...
[Nest] 221135   - 04/04/2021, 7:02:32 AM   [InstanceLoader] TypeOrmCoreModule dependencies initialized +156ms
[Nest] 221135   - 04/04/2021, 7:02:32 AM   [InstanceLoader] TypeOrmModule dependencies initialized +1ms
[!!] CoffeesService - instantiated
[!!] ConfigService - instantiated | "DATABASE_FOO": - bar
[Nest] 221135   - 04/04/2021, 7:02:32 AM   [InstanceLoader] CoffeeRatingModule dependencies initialized +9ms
[Nest] 221135   - 04/04/2021, 7:02:32 AM   [InstanceLoader] CoffeesModule dependencies initialized +1ms
...
...
----
//}}}

Using the `"ConfigService.get()"` - method, is a *generic way* of accessing
various "configuration - properties" registered within your application. It
comes in handy while getting `*".env"*` - variables, or when you need to
interact with many different "configuration - object" at once in a *"single
- service"*.

But here we are using that String *"dot notation"* again!.

We still don't have full *"Type - safety"* when we retrieve "nested
- properties", and we know how "error - prone" that could be.

Not only that, but this approach makes *testing more difficult*, because we
would need to "Mock" the `"get()"` - method, hard-code "environment - logic",
and return different values based on "different - keys".

So, what's the ideal alternative?

When dealing with these configurations. It is a best practice to inject the
entire *namespace* - "configuration object" directly.

//{{{ // coffees.service.ts
[source, typescript]
----
// coffees.service.ts
import { Injectable, Inject, NotFoundException, Scope } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Connection, Repository } from "typeorm";
import { ConfigService, ConfigType } from "@nestjs/config";

...
...

@Injectable({ scope: Scope.REQUEST })
export class CoffeesService {
    constructor(
	...
	...
	@Inject(coffees.KEY)
	private readonly coffeesConfiguration: ConfigType<typeof coffeesConfig>,    //<<<
    ) {
        console.log(`[!!] ConfigService - instantiated | "DATABASE_FOO": - ${coffeesConfiguration.foo}`);
    }
    ...
    ...
}
----
//}}}

Each "*namespaces* - configuration" exposes a *"key"* - property, which we can
use in order to inject the "ENTIRE - Object" to any class, registered within the
"Nest - container".

In addition, "ConfigType{fn-configtype}" is a "*helper* - Type" provided out of
the box, which *"infers"* the return type of our function!.

Now we can access this Object *directly* instead of using the `"get()"`
- method. We even have the benefit of "*strong* -  Typing" now. No more *"dot
notation"*, no more "magical String" (`"coffees.foo"`), and hopefully no more
errors!.

Now the compiler will warns us anytime we try to use a property, that does NOT
exist", or if we mess up any of the Types.

=== Reference

- link:https://docs.nestjs.com/techniques/configuration#partial-registration[Partial Registration - Techniques]


**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 7 == Asynchronously Configure Dynamic Modules
[[_asynchronously_configure_dynamic_modules]]
== Asynchronously Configure Dynamic Modules
:fn-deterministic: footnote:[measurable]
:fn-for_root_async: footnote:[https://docs.nestjs.com/graphql/quick-start#async-configuration]
:fn-async_factories: footnote:[https://docs.nestjs.com/techniques/database#async-configuration]

As we learned in previous lessons. "Dynamic - modules", such ash that
"TypeOrmModule", can be configured by *"consumers"* - modules, by calling
"*static* - method", and passing them `*"options"*` as arguments.

For example, in our application we are calling the `"TypeOrmModule.forRoot()"`
- method to specify "database - connection" options for "TypeOrm".

//{{{ // app.module.ts
[source, typescript]
----
// app.module.ts
...
...

@Module({
    imports: [
        ConfigModule.forRoot({
            ...
            ...
            load: [appConfig],
        }),
        CoffeesModule,
        TypeOrmModule.forRoot({
            type: "postgres",
            host: process.env.DATABASE_HOST,            // <<<
            port: +process.env.DATABASE_PORT,           // <<<
            username: process.env.DATABASE_USER,        // <<<
            password: process.env.DATABASE_PASSWORD,    // <<<
            database: process.env.DATABASE_NAME,        // <<<
            autoLoadEntities: true,
            synchronize: true, // COMMENT THIS in production - mode
        }),
        CoffeeRatingModule,
        DatabaseModule,
    ],
    controllers: [AppController],
    providers: [AppService],
})
export class AppModule {}
----
//}}}

In above code ("AppModule") here, we've used the `"process.env"` - Object, to
extract the environment variables loaded by the "ConfigModule" we import above.

But what happens, if we move the `"TypeOrmModule.forRoot()"` - lines inside our
`"import: []"` Array, so that is ABOVE the `"ConfigModule.forRoot()"` call?

//{{{ // app.module.ts
[source, typescript]
----
// app.module.ts
...
...

@Module({
    imports: [
        TypeOrmModule.forRoot({
            type: "postgres",
            host: process.env.DATABASE_HOST,            // <<<
            port: +process.env.DATABASE_PORT,           // <<<
            username: process.env.DATABASE_USER,        // <<<
            password: process.env.DATABASE_PASSWORD,    // <<<
            database: process.env.DATABASE_NAME,        // <<<
            autoLoadEntities: true,
            synchronize: true, // COMMENT THIS in production - mode
        }),
        ConfigModule.forRoot({
            ...
            ...
            load: [appConfig],
        }),
        CoffeesModule,
        CoffeeRatingModule,
        DatabaseModule,
    ],
    controllers: [AppController],
    providers: [AppService],
})
export class AppModule {}
----
//}}}

Let's try it real quick, save our changes, and open up the terminal.

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
...
...
error: password authentication failed for user "Users"
...
...
----
//}}}

Surprisingly, it doesn't work now!.  Our application is throwing an Error,
because our *process* - "environment - variables" are being loaded AFTER the
`"TypeOrmModule.forRoot()"` - call happens.

Thus, all these value, "DATABASE_HOST", "DATABASE_PORT", etc... Will *fallback*
undefined.

It is a best practice for our applications, to always be deterministic{fn-deterministic}!.
The `@Mdule()`- "`"imports:"` - order" should *NOT* matter at all.

So, how can we fix this and prevent it from happening in the future?
Luckily for us, most NestJS - modules in the ecosystem, expose additional "static - method"
with the " `*'async'*` - suffix", which can help us solve this *exac* problem.

In this particular case. `"TypOrmModule"` has a `"forRootAsync(){fn-for_root_async}"` - method which we
can use to asynchronously load the configuration options.

There are several ways to deal with "async - configuratio", but we will focus on the most common one,
which "asynchronous - factories{fn-async_factories}". You can check out the other options in the official documentation.

Let's go back to "AppModule",

//{{{ // app.module.ts
[source, typescript]
----
// app.module.ts
...
...

@Module({
    imports: [
        TypeOrmModule.forRootAsync({    // <<<
            type: "postgres",
            host: process.env.DATABASE_HOST,
            port: +process.env.DATABASE_PORT,
            username: process.env.DATABASE_USER,
            password: process.env.DATABASE_PASSWORD,
            database: process.env.DATABASE_NAME,
            autoLoadEntities: true,
            synchronize: true, // COMMENT THIS in production - mode
        }),
        ConfigModule.forRoot({
            ...
            ...
            load: [appConfig],
        }),
        CoffeesModule,
        CoffeeRatingModule,
        DatabaseModule,
    ],
    controllers: [AppController],
    providers: [AppService],
})
export class AppModule {}
----
//}}}


First, let's change the `"forRoot()"` - method we are using on the `"TypeOrmModule"` and
use the `"forRootAsync"` - method instead.

Now, let's update the "input - argument" and use the "factory - function".

Our "*factory*" behaves like any other "asynchronous - Provider" we've learned about in the "Dependency - Injection" (DI) related lesson.
It can be `"async"` and it's able to *"inject - dependencies"*, through the " `*"inject"*` - property"

So in our example, we could even inject the "ConfigService" and use it here instead of using process `*".env"*` directly.

Let's save everything and open up our terminal again.

//{{{ $ npm run start:dev
[source, shell]
----
$ npm run start:dev
...
...
[!] DatabaseModule.register() - instantiated
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [NestFactory] Starting Nest application...
[!!] CoffeesModule - instantiated
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [InstanceLoader] TypeOrmModule dependencies initialized +54ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [InstanceLoader] DatabaseModule dependencies initialized +1ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [InstanceLoader] DatabaseModule dependencies initialized +0ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [InstanceLoader] ConfigHostModule dependencies initialized +1ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [InstanceLoader] AppModule dependencies initialized +0ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [InstanceLoader] ConfigModule dependencies initialized +1ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [InstanceLoader] ConfigModule dependencies initialized +0ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [InstanceLoader] TypeOrmCoreModule dependencies initialized +102ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [InstanceLoader] TypeOrmModule dependencies initialized +1ms
[!!] CoffeesService - instantiated
[!!] ConfigService - instantiated | "DATABASE_FOO": - bar
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [InstanceLoader] CoffeeRatingModule dependencies initialized +1ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [InstanceLoader] CoffeesModule dependencies initialized +0ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [RoutesResolver] AppController {}: +9ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [RouterExplorer] Mapped {, GET} route +5ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [RoutesResolver] CoffeesController {/coffees}: +1ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [RouterExplorer] Mapped {/coffees, GET} route +0ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [RouterExplorer] Mapped {/coffees/:id, GET} route +1ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [RouterExplorer] Mapped {/coffees, POST} route +0ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [RouterExplorer] Mapped {/coffees/:id, PATCH} route +1ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [RouterExplorer] Mapped {/coffees/:id, DELETE} route +0ms
[Nest] 1110345   - 04/04/2021, 5:29:15 PM   [NestApplication] Nest application successfully started +5ms
...
...
----
//}}}


Great. It looks like the application bootstrapped successfully now!.

Our code works because the "asynchronous - configuration" we added, will be loaded "AFTER" every module registered
in the application is *resolved*.

Thus the "imports - order" wont's affect anything for our `"TypeOrmModule"` anymore.



**⬆xref:_table_of_contents[back to top]**
//}}}

//**⬆xref:_table_of_contents[back to top]**
